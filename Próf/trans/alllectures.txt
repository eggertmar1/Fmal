0:41  
Right,

0:42  
so let's continue the course.

0:47  
Last time I started with F sharp.

0:51  
Today, I will tell you a bit more. In particular, I'll continue on these topics that I wanted to cover on Tuesday on tuples.

1:03  
And on multiple argument functions, say particular two plus functions, how do you deal with such a thing in

1:12  
in F sharp

1:14  
I now try to share my screen

1:23  
share.

1:38  
Yes, that should be

1:45  
an F sharp, you do not only have the very basic data types like int or float or basic

1:53  
things also like Boolean or string, you also have composite or compound types. We saw one example of this already, which was

2:06  
function types. So, for T, the type of input values and t prime the type of output values t arrows t prime is a function type.

2:19  
But there are other compound types and the typical one of those is is tuples.

2:25  
You can put together and values of any type in particular of different types. In particular, for example, you can put together two things. So, for example, the following thing

2:38  
is a tuple

2:46  
all integers, so I've got an int and an int, two and three. And this type is, is written like this with a star in times in, you could read it

3:00  
being a tuple is not necessary, the values are of the same type. So I could, for example, put things together, I could say, for example, that My name is darmowe.

3:11  
And my age is 51. That's perfectly

3:16  
possible.

3:19  
Now, what we have is a pair of two different types of string, and integer.

3:25  
And

3:28  
these are first class values, you can give them names and you can pass them around like integers or floats or anything. So, in particular, I could also say, for example, let p be two and three.

3:41  
And then I see the PS two and three.

3:45  
And I can pass them around, right. So I could perhaps say let q

3:50  
be the same as P.

3:54  
and then Q is also a similar thing.

3:57  
In a tuple is not necessary that you have just two elements, it could be any number. So, for example, let's make a tuple of four elements.

4:08  
So here's one that is made of an integer, a Boolean, a float, and a string.

4:18  
You can put together

4:21  
values of different types into a tuple. Sometimes, of course, you might be given a tuple, and you want to extract the value out of it. So what could be an example of this? So I might be interested in projecting out the first component of a pair? How on earth could I do it? Now P is in my environment. Currently, it is the pair of numbers two and three. I might be interested in that in the first number there. Let's let's call it n. One way to do is the following.

4:50  
It uses pattern matching. We already saw pattern matching in defining functions.

4:56  
When you use patterns to describe what arguments

5:00  
As can possibly be, and then you did case distinction on the possible forms of arguments.

5:06  
You can actually also use patterns even in these let

5:13  
in the definitions in inlet expressions,

5:18  
where you say I want to give things names, so I might be interested in calling the first component of the pair p m, and the other one n and then I can write such a thing, let n equal P.

5:34  
And let's see what happens, I do get to know that m is three,

5:39  
sorry, M is two and three, they came out in the wrong order, but correctly, M is the M is the first component of the pair n is the second component of the pair. And what happened here was that I was doing pattern matching.

5:53  
So, this thing here is a pattern. So I'm, since P is a pair, it must be something of the form m and n. So I can give these different parts names. And I can then

6:04  
define what the values of these things are based on what p itself is.

6:09  
I don't necessarily always need to be interested in all components of a tuple, then I could use my,

6:16  
my wildcard pattern. So, I'm I'm, so it's written underscore, and it matches anything. And the point is, later, you can't use its value. So I could, for example, say something like let

6:33  
let the string be no, let

6:39  
underscore, underscore underscore string, v, w.

6:45  
The idea is, W is a quadruple as a four tuple. And I'm interested in the fourth component of it.

6:53  
And was it the fourth, the fourth tuple, I have to write the pattern in this form, there have to be four components, but I really don't care about the first three. So then I don't need to give these things names, I can, I can call them all underscore, when this pattern match happens. This doesn't mean that the first second and third component have to be equal, it means each of them individually can be anything.

7:17  
And then I can extract the string law.

7:23  
One very important use

7:27  
of pairs, and tuples, in particular, is that

7:35  
now and then the function that you're interested in, doesn't necessarily naturally take one argument multiple,

7:45  
like a function might want to take two arguments. Now, there is no such thing really, in F sharp as multi argument functions.

7:58  
You have to fake it in one way or another. There are exactly two ways of doing this.

8:03  
I

8:06  
have covered both in the next few minutes. But here's the first one. So you can define a two plus function as a function that just takes a pair as an argument.

8:18  
So instead of taking two separate arguments, we say there is just one argument and that's a pair.

8:24  
And if you do it like this, then then

8:29  
you get syntax that is very familiar to you from a number of languages, like you have multiple arguments in a row when they are even enclosed in parentheses like here. So for example, I might want

8:44  
to introduce

8:46  
addition, while it's defined as an operation, maybe I want to give it my own name, then I can say let's add

8:54  
my own version of function

8:57  
of or the function of addition.

9:00  
In the following way, let add of a given pair be

9:06  
x plus y. And this is a valid definition.

9:16  
Got the other semicolon.

9:19  
And we see

9:21  
this is the right type. It takes a pair of integers. Well, the formal parameters here were x and y, you also get this information and it returns in and now I can use add instead of plus if I if I want.

9:43  
It is really important to understand that even though it looks like a two place function, this is just one single argument that is a pair. How do I how do I prove this to you? So let's perhaps

9:57  
so maybe one way to prove it to you is to show that

10:00  
I can I can define it differently.

10:07  
But maybe later?

10:12  
Yes.

10:21  
No, let me do it anyway.

10:23  
So let me show you how to define a function that extracts the first component of a path.

10:29  
You can do it like this, we just say, lead

10:35  
first,

10:37  
then some pair, where I don't care about the second component.

10:44  
Equal backs.

10:46  
So this is to define the function first. That takes in the pair, but it extracts its first argument. Yeah.

11:00  
This is an interesting example. Because when you look at the type, you see new things for you. So you see first as the Type A times B, arrow a, where the A and B have these little apostrophes also attached to these letters.

11:16  
So when in the place of a type, you see something of the form apostrophe, a string, then this is really

11:25  
F, sharps notation for type variables.

11:30  
And what this signifies is that this function is polymorphic. To extract the first component of a pair.

11:37  
The first component can be any type, the second component can be any type. But the result, of course has to be the same type

11:45  
as the first component of the pair, because after all, that's what we

11:49  
can similarly define the second component of a pair,

11:54  
maybe like this.

12:02  
And now I can define addition differently just to define to to, to explain to you that addition really takes takes as an argument, the pair is not that this is like a two place function that really

12:14  
somehow takes the first argument x and the second argument y. And this is some special syntax for two places No, I can very well, right, let add

12:26  
of a pair be the first component of the pair p plus the second component of the pair P. This is a valid definition.

12:39  
It has the right time, the same that you saw before.

12:45  
Now interestingly, you can't say that the first integer is x. And the second integer is why F sharp could have told us that the whole pair is B but somehow decided to omit this. And I can use this function addition to add together pairs. So I can seem to add up to one three.

13:04  
And I can get the value of that this is fine.

13:10  
So what I took was useful, in addition to, to, to to capture multiple number of arguments to functions. Another typical thing is, you know, structured information, say, maybe we want to talk about times of the day,

13:28  
when it's natural that you speak of pairs of say, hours and minutes, or maybe triples of hours, minutes and seconds. And here are some typical ones, for example. So noon might be the pair of 12. Zero.

13:43  
Yeah, some particular talk or lecture could start at 1515, etc.

13:51  
This is close to record types.

13:54  
But the difference is that record types would have field names for the different components here, you can just access the different components. positionally, you know, instead of saying these are ours, we just say this is the first component of a pair. Instead of saying these are minutes, we just access this is the second component of a pair. But record types are also possible and we'll get to them very soon.

14:19  
Then, it's also important to realise that you may need to pose

14:25  
So

14:27  
for example, if we do this thing that we talked about hours and minutes, I might want to define a function that finds out if a certain time is earlier than some other time, then you

14:40  
then this naturally is a function of two arguments. But each argument in its own term is a time right so we've got a pair of an hour and the minute and an hour and the minute and when is one time earlier than the other? Well, you have to first compare the hours if the first hour is strictly smaller than the second then

15:00  
really the first time is earlier than the second is the hours are the same, then one time is earlier than the other. If this relation holds between the minute amounts.

15:12  
Yes.

15:18  
So we see that we can have the tuples of two components, three, four, etc, it's important to realise and that's a design choice in the language, that you cannot have tuples of one element.

15:35  
And there are various reasons for this, but maybe I don't go deeper into this. But

15:42  
well, the easiest to say is that also practically, there is no point in in one component tuples, because that's just one value.

15:53  
Which you don't need to group together with anything. So there's pointless, it's pointless to require some additional amount of parentheses around it. But when you think about the closer why,

16:04  
with the simple design of syntax,

16:08  
one component tuples are maybe not a good idea. One of the reasons is exactly that, you know, here we use commas to talk about tuples, parentheses

16:19  
to indicate groups of tuples. But if we also allow

16:24  
Singleton tuples, then it becomes a bit of problem to decide which parentheses are for precedence, and which are to indicate nesting of tuples.

16:36  
So you can have multiple tuples, you cannot have a unary tuple. But interestingly enough, then it has a purpose.

16:43  
You

16:45  
it's possible to have an empty tuple. Well, in fact, there is exactly one empty tuple, the empty tuple, which is just right like this. And it's huge. Its type is called unit. So let me let me show you here. So when I evaluate this thing,

17:04  
then it says, well, it's a legal thing. And it's type is unique.

17:09  
In many languages, this type is also called void. And it's exactly the same thing.

17:16  
Why functional programmers don't like maybe the name void is that void is kind of a misnomer, it means that there is no information. So in that sense, the type is void.

17:28  
I mean, if you if you learn an element of that type of learn no information, because there was only one element there anyway. But the type is not void in the sense that is not empty, it's not true that there isn't any single element in the type that is exactly one element in the type, which is the empty tuple. And it's for that reason, that there is only one element, that if you learn this element, someone tells you, you know, I've got an element of unique, please Guess which one it is,

17:57  
then there is nothing to guess there is no information there, you know, upfront that this must be this.

18:06  
So when do you ever need this thing?

18:11  
In a type

18:13  
of some expression? Well, the empty tuple by itself is not very useful. But there are functions that don't return anything. These are exactly the sort of void or void functions or methods of some other languages.

18:31  
And those indeed do have

18:37  
the return type unit.

18:39  
Now, you might ask, why would I have a function that returns nothing?

18:44  
Well, in a pure functional language, it is pointless to have such functions because they don't find out anything for you, they don't compute anything for you. However,

18:55  
we also have these things called side effects. And one very useful function, for example, that doesn't return anything is printing. So it takes as an argument, the string that you want to show on the screen,

19:09  
it prints it so that's the side effect this is something that the function does while it computes when a given argument, but the end result is well in some sense, nothing is no information, it is the empty tuple. So,

19:24  
let me open this module system again where these things are.

19:29  
And then I can use this function console writeline

19:34  
to just print hello or hello world.

19:39  
And this is what you see Hello is printed. So this is a side effect.

19:44  
But the return value is the empty tuple of type unit, nothing is returned. I might also just ask what is the type of the function by just saying, you know, evaluate the function alone.

20:05  
Okay,

20:07  
so it should basically say, from the string to the empty type, but there is also overloading involved here. So that's the only, that's not the only possible. Possible type A now this is discussed here. So this is maybe a bit more complicated than I wanted, but, but you can see it has all these possible types. So for example, where is the string thing written?

20:31  
somewhere around here, but but for example, right, right line is able to take an unsigned integer, and to produce a unit.

20:42  
There's multiple types.

20:45  
So there is also the empty, empty,

20:48  
or sorry, the unit type in the picture.

20:53  
Now, let me tell you a bit more about

20:57  
to place functions.

21:00  
So

21:02  
I already indicated to you that there is really nothing like to place functions, or three plays, or four place functions in F sharp at all.

21:15  
Everything you do is kind of fake. But it's very principled and very systematic, fake,

21:21  
or faking. So

21:25  
let's talk about two places. So we're interested in functions that should take two arguments. There's two ways that you can implement these or define these in F sharp.

21:37  
One is that we already saw su say, No, no, it's not the function that takes two arguments is the function takes one argument, but that argument must be other pair type or tuple type for n equal to

21:52  
this representation of functions is often called on curried functions.

21:58  
There is an alternative

22:02  
which takes seriously the fact that in functional languages, functions are first class citizens, which means that they can be used in any role that values of other types say simpler things like integers or Booleans can be so functions cannot only be defined and applied, they can also be passed around as values. And they can be produced as values in the first place. So then the binary function can be understood as a function that works in stages. So it's a function that takes as its argument, well, the thing that we want to give us the first argument, and then the result

22:48  
is not yet the thing that we're interested in, it's not the result, the result is another function that takes our second argument.

22:57  
So, the whole thing is represented as a function,

23:02  
which only wants to see the first argument and already then it produces something but namely it it produces a thing that is still waiting, it produces a function that then wants the second argument.

23:16  
This representation is called curried functions. This has nothing to do with food from India. It has everything to do with the name of the logician,

23:27  
Haskell curry

23:34  
of the 20th century, of course.

23:41  
So his work is very relevant to functional programming in that a certain type of formal logic, namely intuitionistic logic is very closely connected to types in functional programming.

23:57  
And the name Haskell curry has actually not only given you know the name to curried functions, it's also given the name to two languages. So that is the functional language Haskell. But there is also a functional logic programming language called curry. So both exist. So that's that's the origin of the of the work.

24:22  
Now, why the there are these two are alternatives, I should tell you that

24:27  
functional programmers

24:30  
tend to prefer the curried form most of the time.

24:46  
Now, what are these two forms about?

24:49  
I already indicated to you what the first one is too. So so here are these once again just to compare. So So addition done with the type

25:00  
That says Well, we take in a pair and

25:05  
then return what we want here in this case integers. This is the corresponding definition which goes by pattern matching on the given pair. And then the way that you are applying such a function is for example, here at the apply to the pair of 17 at 25, and you hope that you get 42 back.

25:28  
But here's a different alternative.

25:31  
We say this is the curried ad.

25:35  
This one will have typed in arrows in Petrosian. This is how this will be shown to you, it's important to realise it means this thing. So there are some omitted parentheses here, it is a function that takes in an integer,

25:51  
but then the result of applying this function is another function

25:58  
which takes in another integer and gives a result which is an integer.

26:05  
Now, functional programmers often do not write these kinds of parentheses for the reason that the arrow sign is agreed to be right associative. So whenever we receive the two arrow signs in a row, you know that

26:21  
the second one, the rightmost, one has preference. So as priority has, sorry, has precedence has priority. So we can

26:33  
imagine that the parentheses are here. And then the the the the the the first one, that the leftmost one is the one that binds weaker.

26:44  
Now in this notation,

26:47  
sorry, it's under this convention that we work with curried functions, you have to define addition differently.

26:54  
Namely, we say FC is a function that that can apply to a parameter x.

27:00  
And then the result is a function that that can apply to a further parameter y.

27:07  
And what they get is x plus y. So let me demonstrate this.

27:13  
So here's the use case of this thing.

27:19  
Right.

27:24  
The definition is accepted that we can see exactly this type, but you should think that it is a function that takes in x and returns another function, which you may call

27:35  
on y which you may apply to y is another terminology is the other terminology here. And therefore, I can do the following thing I can apply at C to 17 and 25.

27:52  
Now, why this why would this be useful?

27:58  
Why don't we just work with pairs

28:01  
and

28:06  
there are reasons

28:19  
let me come to them. First, I should also tell you that there is there is the function plus right which we have seen anyway, I mean, we do not define ad primitively, we defined ad p through plus and that See also through plus. So, if there are really no two plus functions, then the interesting question is, what is the type of plus Is it this? Or is it this?

28:42  
Well,

28:46  
operators that you use in infix form, they are also just ordinary functions. And if you want to see an operation as a function, you just put parentheses around it. So in particular, I could ask what the type of plus is.

29:01  
And it is

29:04  
its type is take an integer, give a function that takes another integer returns an integer,

29:11  
and here should be its value, but since it is a function, you can't really show a function in any useful sense, which just indicates this is some sort of a function.

29:21  
So plus can really be used in exactly the same way as Add curry. So I can write plus 1725

29:30  
and that is also 40. To

29:37  
know

29:40  
if this is true, so then

29:46  
Anyway, what is the use of curried functions? Great functions are great because they allow something that is called partial application.

29:54  
So here, I use plus unapplied plus is just a function here. I asked what it's doing.

30:00  
Easy to function. Here I've used plus fully applied, I applied it to the first argument and to the second argument, and the result is a number.

30:10  
But I could also,

30:13  
in principle just applied to only the first argument. So I could talk about this thing.

30:20  
Sorry.

30:27  
This is also a function. But it's the function that now needs only one further integer to produce the final result. Yeah.

30:37  
This guy just says at some other function.

30:41  
So what's the possible use of this? Well, I could, for example, say,

30:47  
I can give it the name, it's a function. So I can give it a name.

30:51  
I can say that such a function is called that 17.

30:57  
And then I can use this thing as a function on its own right. So I know that I'm not interested in general addition anymore. I'm just interested in adding 17 to whatever comes in, you know, my way. So here is one use of the function.

31:14  
Here is another

31:17  
here is yet another.

31:23  
Which is, which is one way of of doing these things.

31:31  
Let me also illustrate you one other way that you use these things. So you might ask, okay, so this is a this is a function.

31:42  
Why get it? Why gate? its

31:46  
own name, because, you know,

31:55  
when I finally want to apply, but I need to give the second argument anyway. Right? So it's never really the case that you can fully carry out tradition, until you've seen both arguments that could be, say,

32:09  
a complaint. What Why do you ever need partial application, but partial application is useful, because functions are things in their own right, so let me explain it on this example. So let me define the following function.

32:24  
Let twice,

32:28  
I'm gonna define a function twice, twice is a function

32:33  
that is itself, a two plus function defined in the curried form. What it does, is it takes as a first argument, function f, and a second argument, something that I want to use as an argument. And then what I want to return is F four f of x.

32:53  
This is something that you haven't seen here before yet in this course.

32:59  
But it's a beautiful demonstration of the first use of something called higher order functions that we will later see in much more detail.

33:08  
Holderness already mentioned in my introduction is one of these abstractions that is characteristic to functional programming and just says

33:18  
this is another you know, it is just another way of enhancing usability in the language in general.

33:25  
And this is one example. So

33:30  
if I see the pattern that

33:33  
some activity, you know, is done twice in a row to an argument, then I can encapsulate it by saying, Okay, let's capture this activity itself in a function and, and we can capture the the the aspect of like iterating the activity

33:49  
in a higher order function that says how many times this thing is iterated like here.

33:54  
So, twice is typed like this, it takes in a function, which works on any type and returns exactly the same type. So it takes in any function from A to A, then it takes an argument from type A.

34:09  
And the result is also of type A, the idea is x comes in is of type A, I apply f three, three, the result again has to be a type A, which means that I can repeatedly apply F to it, and I then get that this is again a result of Type A and now I can apply twice to at 17.

34:37  
I'm

34:40  
sorry, no, no need for left anymore. So just want to say I want to apply twice to add 17.

34:48  
Let's see what it's like is

34:52  
now since ad 17 was a function from in three twice is able to send any such function to any

35:00  
function from mean three, which I can actually apply twice here is only partially applied, I've applied it to a function but not yet to, you know that the real argument, I can also supply the real argument I maybe want to say I want to add 17 points to three.

35:18  
And the results should be then three plus 17 plus 17, again, which I think is 37. And that indeed, is the result.

35:31  
Now, what did I cover at this point was

35:35  
or until this point, then in this lecture was

35:40  
tuple types as a way of group together values

35:44  
as a kind of poor man's version of record types. So, conceptually related values can be grouped together, but also you can use tuples to deal with the fact that sometimes you want to apply functions to multiple arguments, then you can collect them together into a tuple say a pair for the case of a to base function, then I also told you that apart from applying a function to a pair or tuple, in general, there is a different way of doing multi way sorry, multiple argument functions, which is to to use the correct form. The current format has the slight disadvantage that it prefers the first argument to the second argument, it allows you to partially apply the function to the first argument, leaving the second arguments waiting. If you'd like to prefer the second argument

36:36  
then the syntax doesn't directly support this you can code it, but, but

36:42  
just in the primitive form, what is supported is

36:48  
is is preferring the first argument.

36:53  
So, let me stop sharing here.

36:56  
So, this was this part of the lecture,

37:00  
I will continue with with the first interesting data type or discriminated union type of the F sharp language which are lists and then go further on to more

37:13  
polymorphism and more higher order functions.

Transcribed by https://otter.ai
4:05  
Hello

4:08  
let us check if this works

4:11  
Can you hear me someone else Yes sir yes very

4:18  
so we can get started

4:21  
my name is thermal. I'm going to be your lecturer this term in the programming languages course

4:31  
This lecture will be recorded is live

4:36  
some of the next times I will have to use pre recorded lectures in combination with live we'll see as we go and the same for for exercises

4:47  
for today, how should we go

4:51  
I will do a short introduction to the course.

4:56  
Then I will use slides

5:00  
And I will see my zoom window on the side. And they will notice when you raise your hand, or so so if you've got the question, please, please do raise your hand, when we actually get to the technical part, I will today start telling you about the F sharp language, then I have to share my whole screen because I want to show multiple windows at once,

5:19  
then it's not so easy for me to see raised hands, then just speak up if you want to

5:25  
ask something Is this okay?

5:31  
Let me see if this machinery works.

5:47  
Can you see my slides?

5:50  
Yes, very

5:54  
bad thing is I can't see the zoom window in the way I want. Still, but I hope I'll see raised hands.

6:02  
So, let me start. So this is a programming languages course you might be interested in the question which programming language is it

6:12  
and in some sense, it's supposed to be all of them at once. So, it's supposed to be a general programming languages concept

6:20  
or programming languages concept course, the idea being that once you already know one or two or three languages, then to learn the next 12 you should just be it should just be sufficient for you to know you know what is different. And there are so many commonalities between different programming languages,

6:42  
where the differences only show maybe in some concrete syntactic detail, but but the idea is a similar There are also languages from different languages, families, that are quite different in the very basic setup, and then of course, the distance between languages is bigger. And to be able to pick up different languages, it may be good to know You know, one or two specimen from each big family, so to say. And that exactly is the is the is the idea of the course. So

7:15  
we will look at one language in quite some detail, which is called F sharp, which is a functional language. But this is only so that we could also use it as a vehicle for demonstrating features of other languages

7:32  
of two broad language classes. imperative, which is languages like C, or Java or Python that you've already seen.

7:41  
And then functional is the is the other big family of languages, there are more but these are the two that we will touch upon.

7:51  
But before I get there, let me let me start from some very basic. So what is the setup of this course, since it has to be run online because of the size, at least

8:02  
for the first weeks of the course, but possibly for the home course.

8:07  
Some details are not fixed, but I hope we will shape them as we go. Seeing what works best.

8:15  
I'll do the lectures My name is thermo here is my email address.

8:20  
For practicals, you're splitting to six or maybe seven groups including HMV.

8:28  
And a number of ta is will will take care of you and try to help you with with problems so that you

8:38  
learn the concepts I'm trying to explain here in in practice.

8:45  
The lectures, I must say also going to be pretty hands on in the sense that I'm going to show you a lot of code. And I'll do a fair amount of live coding and this will start today actually. So there will be very few sets of slides.

9:00  
But quite a few

9:04  
files, pieces of code that you have to work with that I try to annotate with comments, explaining everything as we go.

9:14  
So there is two pairs of lectures a week Tuesdays Thursdays,

9:20  
everything online live or pre recorded or combination

9:24  
practicals we will really see how to organise them and what we could to use. We will not have an official practical session official practical sessions tomorrow at all.

9:37  
But I'll give you work to do that.

9:41  
That will prepare you for the next week and from the next week. We'll start properly

9:48  
as it's common at this university attendance, and the school in particular attendance is not mandatory.

9:54  
But I really really, really really really I cannot say this many times enough I

10:00  
I advise you, that you, you actually follow the lectures.

10:07  
Because I'll tell you quite a few things. I'll try to tell you

10:11  
things maybe in different words, hopefully simpler than then they are in the book. And I cannot answer any infinite amount of questions on Piazza. So it's,

10:23  
it's good, if you if you, if you if you ask during the lecture and also during the practicals. So just for your own benefit, I really do recommend that whatever is live, it's try to try to attend.

10:38  
Now for questions, there are various channels, and I will not be or we will not be able to follow them all. So I really like that question off lecture practical time. But the main channel would be Piazza

10:55  
now

10:57  
be able to change their business model and

11:02  
university visit courses using good capital pay. So these licensee licences are being set up. So this is a bit delayed for this course. But I hope this will work. I'd much prefer that questions arrive on Piazza because it's easier to keep track of which ones are answered which one are not. Email is the next one that you can consider. But I prefer pizza and teams is the last one.

11:30  
Don't

11:32  
try to follow it. But I really prefer that we concentrate on on Piazza.

11:43  
Always assessment.

11:45  
In this course, it will consist of assignments to be done individually or in teams of utmost to people.

11:54  
And then a final exam

12:00  
where all four assignments count towards the final assignment score, which then will be weighed together somehow with the final exam. Now, this course used to have the final exam 50% and the assignments 50. This will not be the case this year. We haven't quite finalised the weights of the assignments versus the final exam in this course yet. But we'll do this in this week or so when those who publish the assignment schedule, trying to synchronise it a bit with other courses or the bigger courses.

12:35  
But the indication is, of course, that the final exam now will be less than 50%, maybe significantly less something like 30 or 20%. And then the assignments and then accordingly less serious.

12:48  
Whereas the assignments will then go a bit deeper.

12:54  
Yes.

12:59  
Is this fine?

13:02  
Now the practicals are meant mostly to be for you to prepare for the assignments.

13:11  
I prepared exercises for each Wednesday. The idea is that you work on them, they are not directly the assignment problems, but they are the sort of simpler, smaller things that should help you to deal with the actual assignment problems. Of course, you can also ask the TA for hints about how to do the you know the compulsory assignments. But mostly they are there to help you with the with the with the problems of a particular Wednesday.

13:42  
But but these are designed so that once once you're able to do those, they're all very small things that will help you also with the problems in the assignments.

13:56  
Finally, there is a book.

13:59  
So I've on the on the canvas main page. And I think some other pages I've already indicated this way, there is mostly one textbook that I will actually follow quite closely.

14:11  
So, you should be able to do the exam also by more or less reading the book

14:17  
and not attending anything provided that you work on your book properly on your own and deeply. So it is it is by a Danish Professor better system called programming language concepts.

14:32  
And then the idea is the one that I explained, teach general concepts

14:37  
characteristic to the whole, whole families of programming languages.

14:44  
The way that the book is organised is that it's quite hands on. So it's not just some English language waffle that things were crafted like this, but actually, I think that is explained is also implemented as kind of a prototype if you wish.

14:59  
So

15:00  
It uses one particular language F sharp, that is new to you, to most of you, at least, I guess, which is a functional language.

15:09  
So learning this is kind of good on its own right, because it's a, it's an example of a well designed functional language.

15:19  
quite different in spirit from C, Java or Python.

15:25  
Because it's functional, not imperative. But then this language is used,

15:31  
actually, to me to to explain other languages. So this is not the compiler course. So we'll we will not write full fledged compilers for other languages or interpreters. But we'll go a bit in this direction. So language features of functional languages like ml, and imperative languages, like C are then explained and sort of quickly, hastily, implemented, often also directly in this F sharp to just get a feel for how these language features actually work.

16:06  
So the book goes some way towards

16:10  
implementing the language that they call micro ml, which is just a small core of ml, a standard functional programming language or classic functional programming language. And then similarly, something that they call micro C, which is then a small subset of C.

16:29  
There are actually many other textbooks that one could use to be slightly different emphasis and coverage.

16:38  
Another one that is sort of short, the nice and also implementation century are kind of hands on is the one by country called foundations for programming languages.

16:51  
And it essentially takes the same, the same approach, but the language is dealt with are different.

17:01  
So it uses c++ to implement one toy imperative language that is called Coco in that book,

17:10  
and ml and prologue, prologue is a logic programming language yet a different kind of language to implement the toy functional language that they were called small. So it's, it's a similar approach, but using

17:23  
and

17:25  
use using a different kind of vehicle language and also demonstrating other aspects of other languages.

17:43  
Any

17:45  
any, any questions this far about the setup, just

17:52  
feel free to make

17:54  
make noise? There are some questions in the chat. There are some questions in the chat. Now I really have to see

18:02  
how I can see them.

18:06  
You want us to just ask you questions like this. So do you want us to use the chat more?

18:11  
You can Well, I can also stop sharing for the time being and then I can see the chat directly. And quickly look up.

18:28  
Would be nice if the lectures are recorded, they will be

18:32  
What is the reason for change of the final exam percentage. That is indeed, it's an instruction from the school that says we should we should

18:43  
give away less than 50% of the final exam, which, which is motivated by so many things. First, we don't know how the pandemic goes although with vaccinations, there is hope but but it's really difficult to organise an exam online in a way where you can

19:06  
test your knowledge in any in any depth really. So that's one and also Yeah, if the circumstances complicate, then an exam is a stressful thing. And these assignments they are like spread out over the term, which is perhaps better.

19:23  
No midterm indeed.

19:26  
Just for assignments before the final exam, when will the assignment list be available in Canvas

19:38  
as we go but the first assignment soon in in like a week or two. And the idea is that each time you do get a new assignment, you will have like two or three weeks to complete them.

19:58  
If you still have

20:00  
The exam to pass the exam, right? I think yes, this is my understanding at least.

20:14  
And there is the question, what was the great for the final exam? Just missed the number this one?

20:21  
I don't know the context of the question anymore.

20:27  
Yeah, for the exam 20 to 30%, likely, at most 14, but I would say 30s is quite likely

20:38  
percent of the weight of the final exam out of the total grade. So these things, some of these things are not up to me or any teachers, some of them are decided, centrally, but by the university, and I'll just follow

20:55  
up

20:57  
something else. So for

21:01  
that, just also feel free to speak up I think right now.

21:05  
There is no issue with this.

21:11  
Happy unhappy?

21:16  
shorts, pretty good. Okay, good. Yeah, sounds good.

21:21  
So I also listed another book. So this is, this helps for for F sharp, I will spend four, or if time runs out five lectures on F sharp as an introduction, you know, I'll still show small language features as we go during the rest of the course. But just to get you started. So there is a whole book on F sharp is not mandatory. But if, if you're interested in this, that's one reason to, to consider buying or renting the book. Another is

21:52  
if the opposite if you're not quite interested, but but but but it seems very difficult. So in this case, it's also good to get the book because it really goes slow and gives a lot of examples. And it's a well written book.

22:04  
So the F sharp book is a much gentler book than the programming language concept book that we will use as the main textbook. But then on the other hand, F sharp is not the main focus of the of the course.

22:19  
So he gives

22:23  
gives these ebooks

22:26  
to you not away but for a special price, or at least according to them. So I've provided the links on the course course page.

22:35  
ciabatta book, you mentioned that the sheep plus plus talk, is that just an optional extra? Or Yeah, this is this I just mentioned as a kind of a period if this is like an optional, optional extra I will I will not go into that direction at all. It was just to point out that, you know, in the past these programming language courses, they used to be fairly theoretical. Well, they still are, because I mean, there is some some hard technical stuff here. But there has been like a general shift of trying to mix them up with

23:04  
with some sort of more hands on activity. So they become a bit more like, going a tiny bit towards towards the real compiler course, which often is a separate course anyway, but

23:18  
you posted some videos on modules for the F sharp programming language. Is that just for our knowledge? Or do we have to watch them all or? So I put a whole lot of links having to do with F sharp that you may need, right there is the language referencing style guide. So these are simply good links, if you need to look up something. Or, or if you're not sure how to how to, you know what, what is considered the right way? I don't know.

23:48  
Yeah, doing the layout of your code, for example.

23:53  
But what I put on the lecture one and two are actually the real code from these two lectures, I will go through these

24:00  
line by line more or less, so to say,

24:03  
there are some videos that I posted, which are

24:07  
some of the more popular ones on YouTube, I don't particularly endorse them. But suppose something goes wrong with with one of my recordings in the sense that it just fades or so

24:18  
these are alternatives, right?

24:21  
So in particular, that there is one five part series where each part is like 20 minutes or so. And there is another one, which is a longer video, but which does a whole tour.

24:35  
Yeah, overall of overall of the most important aspects of F sharp that you can use as alternatives. But the main ones are the ones that I put on the lecture one and two were lecture one is today, lecture two is for Thursday. So that's actually called on I'm going to walk you through and explain things as I go.

24:55  
Yep,

25:00  
But the links on the top part of the page there like there for the background, on the bottom of the page, we put a small instruction on how to instal the system. But if you run into trouble you can you can well, you can ask us but maybe in the first place especially if these are sort of very, very simple hindrances, you should simply look up the official instructions from say Microsoft or the F sharp foundation where where they give like a more detailed download and instal and usage

25:32  
instructions.

25:35  
Right.

25:39  
Okay.

25:42  
Can I activate? Yes, sir. Yes, this is not entirely up to me. But as soon as everything is in order,

25:49  
with with the licence, I will, I hope really one of these days this week.

25:57  
Okay, so let me share my slides. Again, I'll give you a brief intro to to F sharp and then we can actually get going.

26:14  
Someone has a contract on Thursday lectures, the recordings will hopefully be regular Yes, you will get something for every for every Tuesday or Thursday.

26:28  
Either a whole live lecture or something pre recorded complemented with a shorter live session during the timeslot.

26:37  
Okay.

26:39  
But all disclaimers for zoom failing or something else failing with the recordings, it's always possible that

26:47  
that you use one or two recordings I've taught at this university. This is my fourth year. I think I've lost one and a half lecture

26:55  
just because something failed in the recording.

27:04  
Right, let me share again.

27:17  
Can you hear this right?

27:19  
Can you see this?

27:21  
Yes, yeah.

27:24  
So

27:27  
a short intro then to the to the to the course who wants more and under sharp.

27:35  
So why this why this course I already briefly said it's, it's like a fairly standard course that you get in pretty much any university on the planet in computer science. on there, these are some very similar name. And the idea is that once you have your first or the first two programming languages, then you can't have courses for for another 12. Rather, you will have like a general Of course, which is supposed to help you for when you learn any language.

28:06  
So

28:09  
we're after both general principles

28:13  
for the design of a programming language, but also a bit about how they look inside like not from the programmers point of view. But But what's in the machine like what's in a typical language processor, which is what is in an interpreter, or, or in a compiler or in an optimising compiler.

28:30  
And another is to peek beyond imperative. And also object oriented languages, right, c++ and Java are object oriented, are on top of being imperative, which means that they are based on commands, or statements, look at other types of programming languages, and here the main sort of competitor family or functional languages. So here are some names you might have heard of like scheme, or Oh, camel or F sharp, or Haskell.

28:56  
There are more these days, Scala and closure and what they are the functional approach.

29:07  
So, this is the kind of brief overview of the course which more or less agrees with the order of chapters in the book.

29:16  
Except that the book is not dedicated on F sharp, it gives you a crash course in the appendix of the book. And this is where we start, we start at the very end of the book, look at the crash course. And then go to the material proper,

29:30  
which is like some of the things you might know very well, some might be completely

29:38  
a completely new world for you. That's fair. So we look at first some very basic distinctions like interpretation of a programme versus compilation of it.

29:50  
What are intermediate languages, what are virtual machines? What is what is the idea of a stack of languages from highest level to lower level the distinction

30:00  
Between syntax and semantics and how to get from one to the other, a bit about surface level syntax of programmes, like how do you get an abstract syntax tree out of code as just written in a file by lexing and parsing, that these are, these are touched upon, on a very light level. And the idea is you either learn these things in a compiler course rather or another door during your health study.

30:29  
But then we go to the, to the real matter. So both functional languages and imperative languages, they work a lot with expression that is block structure, the idea of local names in blocks, there is the idea of Type C, in particular, higher types. For functional languages, we play a lot with the abstractions that are there. The main most important things are data types in functional languages, as well as higher order and polymorphic functions.

31:01  
So

31:03  
I'll explain what these mean in different languages. And

31:08  
you know, what were some design choices when when people first came up with these things, and what kinds of variations are there and what sort of trade offs are there, you know, and which,

31:17  
for imperative languages, where the aspects are different imperative languages are based on commands,

31:24  
and manipulation of memory or store. So here, we talk quite a bit about programming with pointers.

31:34  
So the heap

31:36  
then something about real world virtual machines, like the Java Virtual Machine, and Microsoft's common language interface,

31:45  
garbage collection for for languages, where memory

31:52  
management is not explicit, but a lot of it is handled by by the computation platform. And then finally continuations as another programming paradigm, and also a language implementation technique.

32:07  
But not very sure how far we will reach to the to last bullet, bullet items, but we should get there.

32:14  
Right. So some things are not covered at all, like object orientation. I don't add anything to it beyond to what you know, this is the whole big world on its own. And there is quite a bit to explain that if one were to go there in some depth, parallel or concurrent programming is also outside the scope. And again, very, very technical, very interesting.

32:37  
And then all sort of

32:40  
what should I say?

32:43  
things on the things on the edges, things on the side, like scripting languages, specifically?

32:49  
Or domain specific languages or web languages? They're also not like specially covered here.

33:02  
Yes, that's what the course is. No, I got the question. It's more questions.

33:23  
Could I tell you a bit about myself? What do you want to know?

33:30  
So I'm a professor at Reykjavik University. I'm

33:35  
originally from Estonia, I've been working in Reykjavik for four years.

33:42  
I find it a very nice place

33:45  
with very nice colleagues.

33:49  
I'm generally interested in programming languages myself sort of on the research side, especially functional and dependently type languages. So, so in some sense, this this material is my favourite part of this material at least.

34:06  
I also do things that have to do with programme analysis and verification.

34:13  
Also a bit with automatic theorem proving

34:17  
which are all related subjects, because if we are if you are to, like prove properties about programmes

34:25  
formally, then this gets such a big work that it's not feasible to do by hand. So you want these automatic theorem provers for example, which are programmes in their own right processing other programmes.

34:40  
Yes.

34:45  
PSR versus slack teams are three units on this court. So I have a meeting with with all the TA this week and we will decide about the exact best media for for labs and then also

35:00  
You know, what is your best way to access the TA?

35:04  
If you want to set up a channel for yourself like, which is not

35:12  
under our control, so to say her own to run, then of course, you're most welcome.

35:18  
For everything he said,

35:20  
copying assignment solutions, obviously.

35:24  
So

35:26  
if you've got good, good suggestions actually,

35:37  
regarding best platforms, for different purposes, then get in touch with us, we are actually quite, quite open at the moment.

35:48  
There is more questions and I cannot answer them all I need to tell you my own thing, Estonia that's where the streets are named based on Icelandic street names.

35:59  
I know exactly one,

36:01  
which is actually called the

36:06  
base that is the one street name that I do know, which is called the square of Iceland,

36:12  
which is actually named in honour of Iceland for the reason that

36:17  
Iceland was the first country in the world that recognised Estonia as an independent country after the

36:26  
the coup d'etat in Soviet Union against Gorbachev in 1991. So

36:36  
so there is a small square

36:40  
in front of the Foreign Minister building,

36:44  
which I think used before to be the Communist Party headquarters. And this square is now called the square of Iceland.

36:51  
Iceland square.

36:57  
Okay.

37:02  
Now, I'd like to take you to

37:09  
thank you to F sharp, in small steps. So we will have four lectures for this. Today, this Thursday, next Tuesday, next Thursday.

37:21  
Today, I'll show you some very basics, and maybe it's not terribly impressive, because we won't really get very far today. But at least so you have a basic idea.

37:31  
How do you get around in the interpreter, and we'll give you more technology to work with this

37:38  
later.

37:39  
Next time, we'll be about lists and recursion and then we go to data types.

37:45  
User Defined data types, I mean, and,

37:48  
and exceptions and programming with references among other things.

37:53  
But But this time, it is really the basics and

38:07  
very little beyond that, I have to stop sharing these slides. Instead I'll go to my other windows.

38:26  
It will now be a bit more interesting in the sense that since I have to share to Windows I really cannot follow

38:33  
the chat at all. So if you want to raise questions, which will be wise to the one that on the fly, then just just make noise. discreetly ask a question.

38:46  
Okay.

39:29  
Okay, I'll show you a text buffer in where I work with the F sharp interpreter and they'll tell you

39:36  
things

39:41  
on the site.

39:54  
What is F sharp, F sharp is a relatively new language from 2005. I think or so.

40:00  
Which is endorsed by Microsoft and,

40:03  
and, and the F sharp foundation by Microsoft as part of dotnet. framework. People call it functional first,

40:15  
which is some sort of mild learning of saying that it's functional because it tries to be functional, but it also incorporates other features. So it's primarily functional.

40:26  
In particular, it is strongly typed strict and has type inference. And I'll have to explain you what these words mean.

40:34  
That also what functional first actually means.

40:37  
But it will be good for you to know that it's

40:42  
it's the third the development of,

40:46  
of a language that was first called ml.

40:51  
And who sort of significant aircraft incarnations are sgml camel, and oh, camel, the old letter was last year.

40:59  
What is functional first mean?

41:01  
It means that you programme first of all with expressions.

41:07  
So, if you think of a language like, like Java, you write expressions like x plus y, but then you write instructions like assign y to x. Now in a functional first language, you don't see so many instructions or commands, you move primarily see expressions. And expressions are something that just denote values, like x plus y might be 17.

41:30  
Which means they don't produce side effects like manipulating memory or performing input, there is no idea like that there are some memory cells around and derived values there and read them off there, or that you print to the screen or read from the keyboard. Although, of course, you need to support those. But but but you strike after expressions that denote pure values, and then you sneak in side effects somehow, hopefully, in some principled way.

41:59  
And when everything is an expression, computation goes by simple simplification of expressions. Like, when you want to know what x plus y is,

42:10  
then your idea is

42:15  
you

42:17  
want to retrieve how you defined x, maybe X was four, you want to retrieve how you defined why maybe y was five, then x plus 5x plus y is four plus five is nine. Yeah. And this should somehow be the idea that of the expression is simplified.

42:35  
And the idea should be that as far as possible computation should be just this simplification of expressions pretty much the same way that you did in high school in in algebra, or I don't know, trigonometry, you got these complicated expressions involving,

42:52  
I don't know,

42:54  
powers, multiplication, maybe trigonometric functions. And then you were asked, you know, can you simplify those by opening parentheses and using some known simplifications.

43:09  
It's the same here strongly statically typed means that for your code to be valid, it must be well typed, which means that

43:19  
for every piece of code, you should really know what kind of value it is whether the whole code means an integer or it means a float. Or it may be means a function that takes an integer and gives an integer or it may be means a function that takes a string string and gives you a Boolean.

43:38  
Any sub expression of your code must obtain a definite type.

43:42  
And that is what it is.

43:44  
So F sharp is like this is strongly typed, everything must have a definite type the types you must get to know before you even run your code way before. So when your combined types are checked or inferred.

44:00  
When you want to run your code in an interpreter before it tries to run it, it first checks types,

44:07  
I'll be more precise about checking an inference. In a short while.

44:15  
Then there was the statement that F sharp is strict. People also say eager

44:20  
or keen. So this means that when a function call, that is to say an application or a function, or an argument is evaluated, then the function and argument are evaluated first.

44:32  
And only then the application.

44:36  
This may sound a bit mysterious,

44:40  
but I'll explain it already today.

44:44  
So there are no strict functional languages as well or people also call them lazy. And the prototypical example of those is Haskell. And that's a very popular functional language of a totally different kind than than the F sharp and the programming.

45:01  
Technology is also a bit different.

45:04  
Then I said the third feature was F sharp has type inference. What does that mean?

45:12  
Although all valid code must be well typed, so you must know what kind of values it transforms to other kinds of values.

45:21  
The programmer doesn't need to tell the language processor all these type annotations, when not all types need to written need to be written down in the code. So you can write quite concise and short code. And it's the task of the language processor to check validity. In particular, the language processor, like interpreter compiler can infer by which we simply mean figure out types. If the code is well typed at all, and if it's impossible to type properly, then then the language processor will complain loudly.

45:57  
And you will have to correct something in your code.

46:02  
So let's play a bit with this. I'll just start with a very basic features of the language, the interpreter is called F sharp pi

46:12  
i for interactive or interpreter.

46:16  
And this is one way to work with the language, you just write simple things at the prompt. Of course, you should be able to load files and work with those which will happen from the next time on. But they are basically work with one liners, so we don't even need this.

46:32  
So what do I mean by an expression, I really mean things like I already said, like four plus five is a perfect expression.

46:40  
And

46:42  
I can use F sharp to find out its value, which by the way is nine.

46:49  
But I get to know a bit more. Namely that nine is an integer. This was the reason why F sharp agreed to find out the value in the first place it first figure out that this expression is well typed I'm, I'm really adding up to integers in order to get the third it's not like I'm adding an apple to an orange and expect an integer. So

47:15  
Moreover, it gave it invented a name for this expression just for my convenience, even if I didn't try to give it the name.

47:26  
And the name is

47:28  
it like the English pronoun.

47:30  
So for example, I can now ask what the value of it is.

47:35  
And it is nine.

47:38  
Yeah.

47:41  
That's not the only possible expression, I may ask the value all.

47:46  
I may also be interested in other things.

47:49  
Maybe like this.

47:53  
Yeah.

47:56  
And the usual things are there. I mean, there is the precedents, obviously. So you can drop parentheses where it's clear where they should be. You'd expect here multiplication happens before addition and it is the case you get 19 etc.

48:12  
But yeah.

48:16  
So, we do arithmetic expressions F F sharp makes sure

48:21  
that your arithmetic expression is well typed attempting to infer its types then it evaluates it for you.

48:28  
And this is the paradigm of of doing things here. And if I try to do something wrong, like I want to add together for an Hello

48:40  
the thing like hello here in quotes is a string for F sharp, then it will complain loudly

48:50  
by saying that Hello is not an integer, which is very true. So therefore addition cannot be carried out and the whole thing is nonsense.

49:00  
Is this fine? So we speak about expressions, expressions take values, which are kind of

49:06  
in some sense, expressions that cannot be simplified any further like four plus five is a complicated expression nine is value.

49:14  
Everything is supposed to have pipes. So for example, four is an integer. Five is an integer plus is a function that takes two integers to an integer. The whole thing is a function application. Therefore the result is an integer again.

49:33  
Is this reasonable?

49:36  
Somebody say this is reasonable.

49:39  
perfectly reasonable. reasonable, yeah. Also too simple. So now let's do first thing we can give names to two expressions. So we can define the name via an expression by writing a thing like let x equal e.

49:56  
in the code, you don't have to put a semicolon here. But that's it.

50:00  
interpret that whenever you want to, like enter something and want that processor to process it, you have to finish it with a double semicolon. Now, don't ask me who invented this I personally find it's very silly and one semicolon to two, but

50:15  
take it as the peculiarity of the language. Anyway. So for example, for this three plus four, say, I can say,

50:24  
maybe I want to give this thing a name.

50:29  
And now more things happen. At this point,

50:36  
the value is found. And

50:40  
your name rest is defined to have this value. And it's it's, it's the name of type integer. I'll speak interchangeably about values and variables, these two are are synonyms in this language.

50:53  
And the first shock to you should be,

50:57  
unless you've seen functional languages, before, I'm sure some of you or maybe quite a few of you have is that

51:04  
you're not allowed to vary the values of your variables. So when rest is seven, then it is seven. And that's it.

51:14  
There is nothing like increment rest by one, you can't do this in this language.

51:21  
or in any functional language for that matter.

51:25  
Now, this may be a bit of a shock, because then if you cannot do assignments, how can you do anything at all, but you'll see that you can do everything you want, actually, and the fact that you've been so useful, so used to writing assignments, like x equals x plus one in some other languages,

51:42  
is just an artefact that you were first taught that way, this is not the most natural thing at all.

51:51  
I mean, there is this, there is nothing there that should be this way, necessarily.

51:56  
Anyway, now rest is a name and it has a particular value. So I can work with the rest. I can, for example, ask what is rest times, let's put something simple, so that we can still verify press times two. And the thing will know that this is 14. And since I didn't give it the name, it's it again.

52:16  
Now, you should complain at this point. Because I just said that a names value can never change. But you see, here it was nine. Here it was 27. Here it was 19. Here it was 14.

52:35  
So it is as if it changes all the time. Right.

52:42  
But that's not true. I mean, it's just appear. So fact these, these are all different. It's they're just named the same.

52:52  
This may sound silly, but I really want to insist on that this is so the idea is that here we work with kind of nested scopes.

53:03  
First I was top level and I said

53:06  
there was the kind of globally to that was nine, then

53:12  
I actually entered the next level in the block structure. And here I have a local it which is 27. But since the other it was in the outer scope, and had the same name, I can't use its value anymore. So the alternate is still nine and the inner it is 27. But the alternate is shadowed out and I can't use it anymore.

53:38  
Moreover, here there is a next step,

53:41  
which is like yet further insight deeper into my code. It's like these Russian dolls that you put inside each other, right. So every doll can have its own namespace. And if names are reused, so it's always the same names that they used, then the inner guys do not see the names of the altar guys, that's it.

54:01  
So the

54:03  
ritual

54:05  
here really not. So this is this is a particularly stupid case where there are basically not reachable and could be discarded, like garbage collected away. But But of course, with proper block structures, you you you can have these nasty names reachable. I mean, this is the whole idea. But we live in a kind of

54:24  
environmentalist age where it's important not to waste any resources. Clearly names are a valuable resource. So, you should be able to use the same name for multiple purposes. And then the idea is to work with scopes properly right. So you maybe are in some outer scope, you enter an inner scope value, reuse some name, the moment you leave the inner scope under vacuum, the outer scope,

54:53  
the names of the outer scope are visible to you again. So here in this interaction for it, it was not possible to

55:00  
Because we just go deeper and deeper or inward and inward. But if you write proper lead expressions that we will see or blocks that you will see further on today, then this will be possible for sure.

55:14  
Okay, let's try to do something else that much about names will come back to this.

55:21  
There are also other numerical types, of course. So the basic alternative one is called float.

55:27  
So I can, for example, calculate stuff like square root

55:33  
of two,

55:35  
the system will complain about it, because square root is.

55:41  
square root is only defined on floats. And if I write 2.0, since square root is a function that takes floats to float, it's happy. 2.0 is a float. This is signified by me not writing just two, but 2.0.

55:56  
And I get an answer. Yep.

56:02  
Now I cannot apply square root two in this is a very important, very important thing.

56:09  
Here.

56:11  
So what's my possibility, then 442 is okay, because I just manually write 2.0. But suppose I had done something like let x equal to

56:25  
somewhere before in my code, and then I may be interested in calculating the square root of x, Surely it's wrong. because x is of type integer, we need the float.

56:36  
Now, I cannot write x point zero, that doesn't make any sense. What I need is, is an explicit cursor or a cost.

56:46  
Here, it's called float. Float takes integers, two floats. And other numeric types, two floats, actually.

56:53  
And, sorry.

56:55  
And that's gonna be okay. So I can apply to say, float x or float to,

57:01  
yeah, what happens is, x was to its first

57:05  
transformed into 2.0. That's what float does. And then further square root is taking is this clear.

57:12  
So that's part of strong typing, you could try to reconcile strong typing with subtyping. So saying that every integer is also at the same time a float, that's possible.

57:24  
But that's not

57:27  
although it poses problems for for type inference on various levels. But this is not the kind of design choice that was done in in F sharp, it's really kind of super strongly typed in that respect, that you're not allowed to silently coerce a value from one type to another, even if they look like compatible types.

57:47  
This said,

57:49  
there is some function overloading,

57:53  
which doesn't work by coercion, it just works by overloading. So plus, for example, is defined for both integers

58:00  
and floats.

58:06  
But I cannot use it in a mixed way.

58:10  
I have one question. Sure.

58:13  
What defines a scope in F sharp

58:18  
so it is lead blocks, which I will get

58:23  
here. So far, you've only seen a subtle with because I'm saying let x equal two.

58:30  
And then then I put the double semicolon, which basically means everything further below is in the block structure that I just started, where I introduced the local variable x.

58:41  
But But proper block structure is introduced by construction called lead in where to write the lead, then you define some variables, then there is the body. But then also the lead construct finishes and there can be other things outside of it, following it. And then you get the proper nesting, which is not only like you know, you are in a block and you enter a deeper block, and then you eat the yet deeper block, but you can also exit those blocks usefully.

59:12  
Does this answer your question for now, you will see actually see these LEDs very soon. Yes, thank you.

59:22  
Right, so we've got here.

59:24  
I should also tell you that since F sharp is part of this dotnet

59:30  
framework of

59:32  
of Microsoft on top of it, on top of which they have their other languages like Visual Basic or whatever, then you can

59:43  
you can actually use the dotnet libraries, the class library, and it becomes available to you via a module called system.

59:54  
And that is an occasion for me to also demonstrate to you some other features. So I could for example,

1:00:00  
choose not to use the square root of F sharp, but I could use the square root from dotnet, which is called square root with capitalists. One way to do that would be to write something like system dot math dot square root 2.0.

1:00:17  
And what happens here is that there is this hierarchical structure of modules. So there is a module system, which contains the module mathematics. And in there there is this functions square root, so I can use this, these dots

1:00:34  
as kind of qualified full names in this, you know, to,

1:00:40  
to navigate in this namespace. Does this make sense?

1:00:44  
So, square root with little S is something that is available for me on the top level anyway, I don't need to prefix it with anything, but this other square root is somewhere deep in the module.

1:00:55  
But I can bring names from a module into my scope by just opening the module.

1:01:01  
So, in particular, I could say something like, okay, so if I just wrote square root 2.0, here, it's not well defined.

1:01:09  
Because the name is unknown, but I could write something like open system.

1:01:16  
And now at this point, I can already write math square root.

1:01:21  
Because anything that is in system has been brought to the top level.

1:01:29  
Yeah, and if I further open square root, sorry, if I further open math,

1:01:42  
system,

1:01:47  
namespace is not defined.

1:01:50  
Okay, so maybe the system thing is structured differently. But but that is basically the idea of the of the hierarchical modules within the language that that you can use this dot notation to go deeper.

1:02:04  
Anyway.

1:02:08  
There are other types. An important one is Boolean. So I can do usual things. I can compare stuff like I can ask, is 10 smaller than eight?

1:02:19  
The result is a Boolean, which is false. Yeah, that makes sense. Well, false, itself is a is a perfectly good value.

1:02:28  
True is a value. These are the, the I mean, the type to bool is made of these two values, every other expression of type bool must simplify to one of them.

1:02:42  
And there are the usual comparison things here. Like I can ask,

1:02:50  
if it's the case that three is smaller than four, and maybe five is smaller than six.

1:03:01  
That is great. Yeah.

1:03:04  
And there is a place where

1:03:10  
smaller, why can't you? Or is it some back home.

1:03:15  
There is a place now where F sharp is strict. Strict should mean that before you calculate the conjunction here, you'll figure out both whether three is smaller than four, which happens to be the case name is true. And you also figure out whether five is smaller than six which is true when only then you say okay, two and two is true, therefore, two,

1:03:35  
but

1:03:37  
conjunct conjunction is actually lazy in the second argument.

1:03:43  
Which means that if the first argument is already false, so, three, for example, three greater than four is false.

1:03:53  
In this situation, the,

1:03:57  
the second argument is not evaluated. I can, for example, demonstrate it by writing something like zero times zero divided by zero, or maybe one divided by zero

1:04:11  
is greater than five here. Now, one divided by zero should give you an error, right? Because you can't divide by zero. But now hopefully, since you know the conjunction is false already by the first conjunct being false, you don't even get this far.

1:04:28  
And that is the answer. Right.

1:04:31  
Of course, if I if I was to do the conjunction the other way around.

1:04:36  
Then, sorry.

1:04:39  
We cannot see your last lunch.

1:04:42  
Oh, since when never, you could never see them or

1:04:46  
just the last lunch.

1:04:50  
I get there now.

1:04:53  
Before

1:04:56  
it's more, a little bit more

1:05:01  
Is this true?

1:05:03  
No, it's good. Now I can see all the lights.

1:05:07  
Just something about his screen. Yeah, I could see them too.

1:05:11  
Yeah, it's okay. But I can leave some safe at the

1:05:15  
other day something about your screen to 50%.

1:05:24  
Okay.

1:05:27  
But now I'm worried. So can you confirm, confirm that the majority of you could could see everything I wrote all the time? Or? or none of you could see anything any of the time. I saw

1:05:39  
all of it all the time. All the time. Okay. No problem here, see the bottom line?

1:05:46  
Okay, I can leave some safety room here. But

1:05:51  
you hear that couldn't see it, you can maybe then later checking the video, but because I hope it was really recorded all of it. Anyway, so So here you can see I just rewrote the same conjunction. But But conjunction really is evaluated like this first, the first argument.

1:06:09  
And here, of course, since you cannot divide one by zero, it's well typed, but, but during the runtime, it gives you an error. The whole thing gives you an error, and you get some long complaint. But basically it says error.

1:06:22  
Yep.

1:06:25  
Now one important thing here to realise is

1:06:30  
equality test is written with the same sign that definitions of names. So when I write something like

1:06:36  
five equals 17, this is a comparison. Which by the way is false. Yeah,

1:06:42  
you see this,

1:06:44  
that can be a bit confusing when you have names. So for example, I can say let x be eight.

1:06:53  
This one makes defines x to be a, right. And now I can ask x equals eight.

1:07:02  
This doesn't do any definition anymore. It's just that check whether x equals eight. Yeah, which I can also use in further comparisons, like

1:07:15  
combined with for example,

1:07:19  
whether x is greater than five.

1:07:23  
Anyway, so this is important. In many languages assignment, there is a single equal sign or maybe colon equals or something and comparison is double equals here everything is equals in that respect.

1:07:39  
equals is also overloaded, I should say. So equals you don't only use with integers, you can use it with other types. Now let's do something more interesting. Very quickly.

1:07:52  
Just look here, there is also strings. So when you do something like prof

1:08:01  
that's a string.

1:08:03  
And then I can of course, say

1:08:06  
I can write some spam email by saying let title be prof let name be.

1:08:13  
Laursen, I suppose not very good at Danish

1:08:19  
then I can say, you know, this guy prefers the lowest than one one, so many dollars from somewhere in Nigeria.

1:08:28  
And that's possible. So I've just built the stream.

1:08:32  
So I did very little here, I just defined this this string junk, I mean the this junk email as a concatenation of a bunch of strings. And here you see another instance of plus being overloaded. I can use plus not only to take two integers into an integer or two floats into a float, but also two strings into a string.

1:08:55  
Good, then an important idea is functions.

1:09:00  
They can be defined in many ways. And we'll know quickly look at this. The main one looks like this you write let f which is a name, and x, which is a name equals E, which is an expression. It's almost like an order a definition of a name, except that there is this x here, which you just think of as an argument to a function.

1:09:23  
Yeah.

1:09:25  
Let me do the first example of this in the night explain a little more. So, suppose I want to write the function for calculating the area of a circle, which for mathematics, you know is pi times r squared.

1:09:39  
So circular area, you define it like this and then I combined comment on the rest we say, we we introduce a function name, R is a parameter.

1:09:52  
Sometimes you also say formal parameter to to stress that it doesn't have any any real definite value is

1:10:00  
There's like a placeholder for any value that might come in.

1:10:04  
And here's the right hand side, which is just an expression, which says pi for mathematics times r times r, pi times r squared.

1:10:14  
So this pi is a constant three, point, 14, etc. So is there no type checking in the parameters? state again? So is there no type checking in the parameters of any functions? They're

1:10:29  
very good. So

1:10:32  
F sharp will try to make sense out of it.

1:10:37  
Which is called inference.

1:10:42  
And that's what it will tell you, it will tell the circled area is a function. This is signified by this arrow here.

1:10:50  
That takes float to float. So to the left of the arrow, you'll put the argument type to the right of the arrow, you put the return type, this little r here, what is this? This is just some additional information. It says,

1:11:05  
No, no, I've called the parameter R. But it doesn't have any any meaning beyond that, because of course, I could have also written the very same function by for example, writing smallest instead of smaller everywhere here, it would have also worked, it's the usual thing, right? Local names don't matter parameter is a local to a function. You can call them whatever you want. Of course, it's reasonable to stay in a mnemonic. I mean, our sounds like radio. So therefore, art is a good name. But in principle, could have been anything else.

1:11:35  
Now you ask, Do I need to give types here? I don't.

1:11:40  
But I might want to.

1:11:43  
So

1:11:46  
I might, for example, want to say that art is a float?

1:11:50  
Yeah, I can do this.

1:11:53  
Can you see what I'm writing.

1:11:55  
So now I put the I put the parameter now in parentheses, in general, you don't have to do it in F sharp. So I have to tell you, this is what so this is a sports among functional programmers. never write the parentheses if you can avoid it, like the one that writes the least amount of parentheses is the toughest, toughest girl or guy.

1:12:17  
Huh? But here, you really have to otherwise it's not well parsed. I mean,

1:12:24  
so I can say, I insist that the parameter is float.

1:12:28  
And

1:12:30  
this thing is still happy. Yeah.

1:12:35  
I can also say I want that the result is a float, which I will have to put here.

1:12:40  
Now this is what comes back, when I apply circle area two are the result is float. In some other languages, you would perhaps write this float here at this point, before the function name here. No.

1:12:51  
And that is also fine.

1:12:55  
I may have my own ideas about pipes, which are not correct.

1:13:01  
Like something like this.

1:13:05  
And the thing will complain.

1:13:09  
Why did they complain here? And why at this point? Well, because I'm trying to multiply together three things by and r&r.

1:13:18  
And it just goes from the left to the right here. I think it knows pi is a float, that times is overloaded, you can use it to either multiply together to insert two floats. But the first guy was a float. And the next guy has also to be float to be a float. But I've said it's an int. And that's an inconsistency.

1:13:35  
Yeah.

1:13:38  
Does this make sense? Now I can fix it by putting some courses somewhere if I want.

1:13:49  
I should emphasise some other points. So I've taught functional programming before and I know that the major hurdle

1:13:56  
you guys may have at the very beginning is where's the return keyword right the function should return something you know, I should do a number of steps maybe execute some some commands. And then finally, I figured out some interesting value to return then there should be the command return that thing not the case here. So the idea is that the whole right hand side here, which I think of as the function body is the expression whose value is the value of the function

1:14:27  
for the given, you know for the value of this parameter, so if r is three, then math pi times three times three, well it has to be 3.0. Of course, is that is the right thing.

1:14:42  
Is that okay?

1:14:45  
Because he mistakes here in the test.

1:14:56  
Okay, so how do I use my function now?

1:15:00  
What is the main function Anyway, let's go back to the original one, this one, I just applied to a number.

1:15:07  
And again, I don't need parentheses, like maybe in some other languages, right circle area parentheses, 10.0, just write 10.0, I can also put the parentheses.

1:15:16  
This is always Okay, you can use parentheses to make sure to indicate your preference. In a complicated expression, that's the same thing. But then why write one parentheses you can write three.

1:15:28  
And that's also the same thing.

1:15:35  
Yes,

1:15:37  
a function can also have several parameters, and then you just put them in a row like this here, you know, make a junk email out of someone's title and someone's surname.

1:15:47  
So this is a Danish joke. They actually at the it university, I think they had Vice Chancellor Mustapha. So I can make a function like this.

1:16:01  
And then I can apply it

1:16:04  
to myself.

1:16:11  
And I have a string.

1:16:19  
This is a

1:16:23  
few more things

1:16:26  
you can do.

1:16:29  
You can you can define a function also, without giving it the name. Now, this is very unusual in many languages.

1:16:41  
Because you would think, huh,

1:16:45  
what's the point of making a function and not giving it the name? Because then how do I call this function?

1:16:52  
Normally, a function call looks something like the function name and then the arguments which may be complicated expressions. But the function should be a name, not the case here.

1:17:07  
function

1:17:09  
does not need to be given a name, especially if you need it only once.

1:17:17  
Now this parentheses thing, especially if you only needed once may also sound strange, because I mean, why would you ever make anything a function if you only needed once?

1:17:29  
With your programming experience this far,

1:17:33  
if you need to think once, then you just write it. And you don't abstract any parameters out of it. Because, you know, if you only need a circle area for 5.0, why write the function circle area and then apply to 5.0, of course, you just write pi times five times five.

1:17:51  
Once and for all, you don't need the name circle area for that. But But this is also different in a functional language, because you have this thing called the height or the functions, namely functions that take other functions as arguments.

1:18:08  
And then

1:18:11  
there it makes perfect sense to,

1:18:15  
for these function arguments to other functions. It makes perfect sense not to give to them, Ernie.

1:18:22  
Anyway, here is, here's the discussion of this thing. So I could define a function, call it model three, for multiplying a given number two by three, or maybe 3.0.

1:18:38  
Sorry, let's first week, according to the recipe I first gave you,

1:18:43  
I told you, you define functions with a given name, by just writing let you know your chosen function name, some name for the parameter, and then the body which just uses this parameter, like for example, this. That's the perfect function. And I can use it by for example, multiplying four by three.

1:19:02  
Everything here is float. So it will be 4.01. The result is 4.0. That works. But I can also define it differently.

1:19:13  
Module Three

1:19:16  
is the function name, but the function name is just an ordinary name. So I should also be able to write this definition by just putting down three to the left of an equal sign, because this is how you define things. I mean, name equals whatever is the meaning of the name. Right, this is the general page up here for less. And what we just saw before here, this looks more like a kind of an exception of syntax, which doesn't agree with a main setup.

1:19:44  
You can write model three in this form, then you have to do the following thing.

1:19:49  
Then I write

1:19:52  
Moultrie is a function that takes in whatever

1:19:56  
which I call x, and then the result is t times zero times

1:20:00  
specs.

1:20:04  
And that achieves exactly the same thing. So now if I apply Mazda mod three to 4.0, remember, it's another mod three, my morphine, my inner scope.

1:20:15  
This is still 12.

1:20:18  
And then you see well, but why did I even need to introduce the name all free in the first place, I could have written from x arrows 3.0 times x, and have applied to 4.0 directly.

1:20:31  
And that's possible.

1:20:34  
So these kinds of things are called abstractions, because what I've done is I've taken an expression,

1:20:41  
I've chosen a name from that expression. And I said, Look, I want to see this expression as a function in that name, as a function, you know, in that name as a parameter.

1:20:53  
And you can do it, and then this is the thing. And then I may give this thing a name, C mon three and apply to 4.0. But I can also just use it directly, or any such thing directly.

1:21:08  
Okay, some more things.

1:21:12  
Interesting functions use

1:21:17  
themselves. So here is them.

1:21:22  
Here is a typical one for calculating the factorial of a number, you know what this is like? Five times four times three times 2.1 is the number that is called the factorial of five. And this is what you need, when you want to calculate how many ways you can reorder

1:21:45  
five different things.

1:21:47  
Yeah.

1:21:50  
You know, for the first thing you've got,

1:21:54  
you just make your order of five things. For the first element, you've got five choices. For the next one, since you've already used the first thing, you only get four items left. For the third, you only have three items left for the fourth year, we have two items that for the fifth, you're determined it's going to be the only last remaining item that you have.

1:22:13  
So how do you calculate this function? Well, of course, you can just calculate it in this particular case. But in general, you define this function

1:22:25  
like this, what it says is, if n is zero, then one, otherwise the value of factorial at n is n times the factorial of n minus one.

1:22:40  
So the effect is that, when I do like factorial of three,

1:22:46  
this reduces to three times factorial four simplifies to three times factorial of two, which in its own

1:22:55  
different

1:23:02  
This in turn reduces to

1:23:08  
three times two times factorial of one, which will reduce to three times two times one times factorial of zero.

1:23:25  
And finally, I get one,

1:23:35  
one times one,

1:23:38  
then you can calculate

1:23:41  
in several steps. This is six, right?

1:23:46  
That's the programme. But on the syntactic level, you should notice that I wrote rec here.

1:23:53  
This is to indicate that I'm in the unusual situation where I'm defining a name. But I'm also kind of using that the name is already defined. So I'm, I'm like a cat chasing its own tail. Yeah, that's called recursion.

1:24:12  
There is a joke about this. So So don't have noticed this famous book about algorithms.

1:24:18  
multivolume tome, and there is this index for different terms used in the book and one of them is recursion.

1:24:28  
So there it actually says recursion. See recursion. So to find the definition of the word recursion, you have to look back at recursion and that's maybe the only way to explain.

1:24:39  
Anyway, whenever you have a recursive definition, you can't just write let function name function argument.

1:24:46  
But you have to write rec, if you don't,

1:24:50  
that will also be valid syntax, but it will do something else. So I can for example, do this thing. I could say let factorial of any number

1:25:00  
Is 17.

1:25:04  
And then following that, I could say, let factorial of n be this thing.

1:25:12  
Without wreck,

1:25:16  
then guess what happens now.

1:25:21  
Here there is an older factorial, which, which is a function that is constantly 17. Here, there is an inner factorial, which in its body uses factorial, which is defined somewhere else somewhere, well has to be either in the local scope, or if not there, then somewhere outside in the local scope, I have not yet defined it, I'm just about to define it. So it must come from somewhere outside. So this pack will actually use

1:25:48  
that other fact, here. So, now, when I apply factorial to,

1:25:54  
say five, I'm ever afraid the result will be five times 17, not five times four times three times blah, blah.

1:26:04  
And that's what it is five times 17 is 85. Whereas if I had properly used lead track,

1:26:10  
it means

1:26:12  
I'm defining fak. But then at the same time, I pretend that I already know what the definition of factories. And then when I simplify, I just go in in the circle with the same definition.

1:26:26  
And now everything is good if I try to calculate factorial five, because it's going to be one point like it should be.

1:26:34  
Okay?

1:26:39  
Um, there is not, oh, there is quite a bit to say,

1:26:44  
yes.

1:26:46  
Let me do a few more things.

1:26:50  
So, you see that whatever you use has to be defined before either in the same scope or in an outer scope. Of course, sometimes it doesn't work. Sometimes you want to, for example, define two functions, mutually recursively. So that's one function uses another, and the other uses the first,

1:27:13  
then in this case, you have to insist that two definitions are simultaneous. So here I'm saying that's a recursive definition. And not just a one thing, but of two things which is signified by this. And here. So what's this thing here doing is defining a function that takes a number.

1:27:33  
A function even that takes a number. If the number is even, it is true. And if it's odd, then it's false. And odd is a similar function, except that it's true.

1:27:45  
When the number is odd, and even when it's false, I mean, you can define these function in multiple ways. But here they are defined, mutually recursively.

1:27:55  
So a number is even when is it even? Well,

1:28:01  
it goes by basically counting down, right. So for number zero, you just stay the state right away that zero is even for any other number you say it is even if the number one smaller is

1:28:16  
the fraud you say the opposite thing, you know, zero is not odd.

1:28:21  
But a nonzero number is odd. If the number one less is he is even. Yeah, and then say if you want to check that five is even which will be false. It goes like is five even is for all is three even is two odd is one even is 00. No, it's not. Yeah, and therefore the result is false. You see, so this is an

1:28:47  
and you can actually use and not even only with recursive functions, you can also just use it when you want to define two simple names. I mean, two names of of some simple types.

1:29:00  
Simultaneously, that's also possible.

1:29:05  
I already told you that you can indicate your own types if you want. So here is an example.

1:29:11  
So F sharp tries to infer types. But if you suggest sometimes it checks that your suggestions agree with what it can infer. They tries to find a consistent typing, right? And if you can't, then it complains.

1:29:30  
Now this is about local scopes. That's really interesting. And important, and that's what one of you asked about.

1:29:43  
Let's do something.

1:29:45  
So let's say x is 42. Now we have an x in scope that is 42.

1:29:53  
Now

1:30:07  
I wonder what is going on?

1:30:10  
Mr. Why are you doing here? Now? Okay. Anyway, this is more complicated than necessary. I think I modified this last time when I gave a lecture that I forgot to rework. So here is here is an example of the lead instance.

1:30:25  
I'm saying, Let me define a local x

1:30:29  
here as nine plus 16, which by the way is 23.

1:30:35  
This definition of x will only be good actually in this part.

1:30:43  
So this is a lead in expression, where I first have some definitions, and then I have the body of the lead, which happens to be a further lead, where there is a further local thing introduced, namely y, and then I do x times y.

1:30:59  
Is this good?

1:31:01  
Now, this is maybe a bit silly.

1:31:07  
X is 2525. Inner x is 25. So the result should be

1:31:13  
What is it? 625? Note?

1:31:20  
Yes. So we use this local x. But now let's check what x is.

1:31:27  
x is still 42. Do you see this?

1:31:33  
So the alter X has prevailed or hasn't sold value,

1:31:39  
let me make a different modification of the same. So we could, for example, say.

1:32:00  
So we've got this outer x that is 42.

1:32:15  
I wanted to

1:32:16  
skip over this all together, this plays no role. But I can, for example, do this thing.

1:32:29  
My alter x is 42, isn't it?

1:32:33  
So

1:32:35  
at this place, I'm introducing local x, and I'm not doing it recursively. So the x used in the definition of the local x is the altar x, which is 42. So 42 plus nine is 51.

1:32:50  
The value of the whole expression is 51 squared, which is

1:32:55  
2060 601. But when I asked what X is,

1:33:01  
it's not that

1:33:03  
it's neither 51, which was the interacts, this is no longer visible, I've left the scope, it's still 42.

1:33:11  
So it's really important to understand that the names in F sharp are what is called immutable. You can't assign new values to names variables don't really vary at all. You can do mutable data structures, but that's done with references, otherwise, also known as pointers.

1:33:28  
And maybe that should, then maybe I should just show this during the last minute, and then I dropped them

1:33:34  
the rest for the or keep the rest of the next time. So pattern matching is one last aspect I wrote factorial

1:33:43  
with,

1:33:49  
with anything else here,

1:33:52  
whenever it was here,

1:33:56  
but there is also another possible syntax that functional programmers like a lot, which is, which is case distinction by patterns. So I'm in particular allowed to write this thing, which is a substitute. I say, I'm defining fac M for modified, I suppose or fact with pattern matching match.

1:34:17  
I say it's still recursive. I'm saying the argument is sorry, the parameter is n.

1:34:22  
But what's the body, the body says, I'm supposed to match n.

1:34:28  
And now there are two cases. Either n is zero, in which case I want to return one,

1:34:35  
or

1:34:36  
it's just any n. And maybe for clarity, I should put n prime here, because it's really,

1:34:44  
in some sense, a different thing.

1:34:48  
And I say whatever it is just take it and multiply it with a factorial on one smaller number.

1:34:56  
And that is a perfect definition. So here, we're talking

1:35:00  
He sees

1:35:01  
the first case is kind of a serious filter because not every number is zero. But the second case is here, like a default case, every number matches with some variable, right? There's no problem.

1:35:13  
How about scopes? So here I introduced the parameter n.

1:35:18  
This is of course that and that was introduced here. So that's, that's, that's that n.

1:35:24  
When you do a pattern match against

1:35:31  
when you do better match of a value.

1:35:34  
This goes with a pattern here, zero is a pattern, the variable can also be a pattern. If a variable is a pattern, it's a local variable. So here, in principle, it's okay to use the same letter N here.

1:35:47  
And actually, it will have the same value because I'm matching n with n. But in general, this needn't be the case, right. So if we do something more complicated, you're allowed to reuse values in patents, you'll see more examples of this.

1:35:59  
But that's a possible definition.

1:36:04  
Then, of course,

1:36:06  
I don't necessarily need me to give a parameter to a function, as I already told you, because we can do this thing that we just say we define fac m, and the right hand side is then an abstraction where we say it's a function taking any end and doing something.

1:36:21  
And now there is a further shortcut, which says,

1:36:24  
If you abstract the variable, and then direct you match on it, there is no not even a need to introduce this name. And at all, I could just directly say a function that has two cases. And the parameter is in both cases, just replaced with a with a patent directly. So function applied on a pattern zero is one. And the function applied on a generic pattern n which matches against anything, is he's done this, assuming the patent was

1:36:54  
right.

1:36:56  
I think here Bye.

1:36:59  
Bye. ran out of my time, there was a little more stuff I wanted to cover today. But we can just as well leave it

1:37:07  
for Thursday. So what did you get to know there are types everything has to have a type you saw four basic types, integers, floats, Boolean strings, you saw that we can make function types, which are something of the form t arrows t prime, where t is the argument type and t prime is the return value pipe. And you saw a few ways of defining functions, you'll learn a bit about scope into which we have to go deeper, we'll revisit it again and you'll get used to it but the main principle is

1:37:40  
each time you write left

1:37:43  
and a bunch of simultaneous definitions then they are local to that to the body of that lead. Once you've left the lead, they are gone.

1:37:53  
And if you're at the top level of the interpreter, these letters that you write there these are kind of letters that you never leave and you don't write the in the simplest

1:38:06  
questions

1:38:10  
about this?

1:38:15  
Are there any

1:38:17  
sheep let's check the chat.

1:38:20  
But

1:38:22  
just feel free to speak up Really?

1:38:32  
I cannot see so many

1:38:36  
so many questions in the chat but if there is something that you'd like to ask right now online, I'd be very happy

1:38:45  
could you move your camera better? Sure.

1:38:50  
just happened while I was sharing

1:38:53  
the screen

1:39:05  
Why don't we use functional programming languages like what's the main purpose and gain

1:39:11  
functional programming languages they tend to go in the direction of maximum like modularity and

1:39:19  
and abstraction which is all sort of turned

1:39:23  
gear towards reuse. So, the idea is

1:39:27  
whenever there is a repeated pattern is something that you programme, then this becomes a kind of programming concept on its own, when functions are the kind of simplest thing that you know from every programming language or or methods or procedures, right. So, if you see that, the same kind of thing is often applied to to some sort of values, then you then you write the function or or or a

1:39:53  
or a procedure or method,

1:39:55  
but then functional programming does this thing to so many other things. So there is

1:40:00  
There is usually a very, very strong module system

1:40:04  
in functional programming there is this thing called polymorphism that has now entered also many other languages like in Java and C plus plus it would go on to the name of generics, like the idea that you try to define functions that operate on many types at once and this kind of facility is made available to the programmer not only you know, for predefined functions

1:40:30  
by the system, then there is this facility of higher order functions, which allows you to, which is a different way of encapsulating a common pattern.

1:40:41  
Nobody asked where it is mostly used,

1:40:45  
I think out there in the industry, strangely enough, the the one place where it is clearly used most is actually banks,

1:40:55  
specifically like in in,

1:40:59  
in, in trading systems and also in insurance. So, somehow it has, it has happened so that, that across the world, they tend to employ,

1:41:10  
you know, overqualified physicists that don't have a don't find a job in their specialisation. But then they can learn a functional language and they really good at mathematical modelling on one hand, and they also pick up these abstractions and they they can write sort of high assurance code,

1:41:29  
which on one hand requires mathematical wickedness on on the other hand, you know, has to be

1:41:36  
reasonably safely correct in the sense that the house will always win.

1:41:44  
As always, with the banks or stock exchange or whatever.

1:41:49  
So that's one of the places sort of in more classical areas whenever you

1:41:56  
you do something where you need data types all over the place, what one very typical one is language processing itself within computer science, it's very easy to cook up data types in a functional language, whereas in an imperative language, it often boils down to how do i do my memory layout? And how do I keep track of offsets in my heap in functional programming provided that you can write your algorithms efficiently enough without worrying too much about memory layout, this is this is a way to to do things very prototype things very, very quickly.

1:42:38  
It also goes in the direction of like,

1:42:43  
scripting verb, there are domain specific languages like

1:42:49  
Ericsson sorry,

1:42:51  
the Swedish Ericsson, now, Sony Ericsson started the Erlang language,

1:42:57  
where concurrency was

1:43:00  
was was one of the main things they had to address. So, there are a few places but but I will say you know, if you just need to compute something or if you need to do like, high precision scientific computing, this is not needed. If you want to do

1:43:18  
if your concentration is on on communication in some distributed system, this is also maybe not the place

1:43:27  
but if it's interesting algorithmics if it's complicated code like conceptually complicated code, then the kind of safety mechanisms that you have in functional languages make it

1:43:41  
make it attractive.

1:43:44  
Yes, someone says Python is also a functional language, I mean, many are to some degree. And

1:43:52  
so, there are many sort of idioms of functional programming that have been taken over in so many other languages like the very same concept of anonymous functions that I showed in some other language contexts, they say these are your lambdas, you programme with lambdas and pipes are so

1:44:10  
these these ideas are in many places, why not? necessarily so many languages are completely purely functional.

1:44:22  
functional languages are especially good for language processing. As I said, in particular, if you want to implement another language, quickly, you will always do it in a functional language. Because

1:44:33  
in an imperative language, you just get stuck at setting up your infrastructure and you never get to the meat of the thing. Whereas in a functional language, you can cook up a first interpreter or compiler, like a piece of cake and then you start adding bells and whistles.

1:44:49  
show two, I have like, a private question for you, is it should I use email or teams

1:45:00  
I said it before I really prefer email

1:45:06  
in this case, but I hope we can set up pizza soon. And then you can, then that's my preferred option, either pizza private or to the whole class.

1:45:16  
Okay, thank you.

1:45:22  
So for tomorrow, as I said, there will not be an organised class, but try to set up the system, I also give you the problems that you can start tinkering with. But then next Wednesday, the gas' will help you and we'll, we'll set up a system so that each of these slots during each of these slots, there is some channel where you can interact or possibly combined with zoom, we'll see how to break this.

1:45:48  
Okay.

1:45:52  
Anything

1:45:54  
else?

1:45:58  
I have one question regarding the recursive functions you showed us earlier.

1:46:03  
Why?

1:46:05  
Why was the the return value at five instead of

1:46:11  
the

1:46:14  
the 120 or something that was supposed to be here?

1:46:19  
Sorry, what was it here? Yes, exactly.

1:46:23  
Yeah, yeah, we I can't.

1:46:26  
I'm not showing the screen. Let me fix it.

1:46:31  
Sorry, too bad. The button. Just quickly, tomorrow, the practical session is on for set up and something like that, or the practical session tomorrow is not on. Because the the TA is are not really prepared and organised. But but but try to set up things for yourself. Okay. And if it fails, then we can we can start helping you so to say, especially if I managed to get the pizza to run by tomorrow, then you can start asking questions. Now let me share the screen quickly.

1:47:05  
Do you see now?

1:47:07  
Yes, yes. Yes. So the relevant part was let me colour it white for the time being. So this is the part that you're asking about? Exactly. So here, what happens is

1:47:21  
that, the main thing is that you can see three prompts here, right, the first one says lead back end is 17, then there is another one longer than the respective five, right? So the middle one is not the lead track, it's a lead.

1:47:37  
So in the case of lead, you assume that everything that is on the right hand side must have been defined before.

1:47:45  
Now.

1:47:47  
So in particular, the fact that you see on the right hand side and then to the right hand side, I don't want to touch any anything here because then the colour highlighting goes away, but I'll hover with my mouse, right? Anything to the right of this equals must have been defined before.

1:48:02  
Variable but this fact comes from outside. Yeah, I see.

1:48:07  
a factor of five reduces to the other factor applied to four. But the other factor absolutely doesn't care about for anything. It's just there's 17 constantly. And then you multiply five by 17.

1:48:18  
Yes, thank you.

1:48:31  
Okay. So, if, if this is all for now, then let me finish here. Let me stop the recording.

1:48:42  
Don't bombard me with 100 emails. If you do not get the F sharp two installed on your computer, we'll try to help you in some organised way. But but try to follow the instructions. I'll also put some problems there and we'll try to set up Piazza and you'll get the proper lab class on Wednesday. But I will continue the day after tomorrow. Thursday, right.

1:49:07  
Okay,

Transcribed by https://otter.ai
0:24  
Right, so today, I'll continue talking about the first word of functional language we had, will do two things. First, and this is kind of tangential, this is just so that you can plug different files together and experiment. I'll comment on how to modify the lexer and parser. For the expressions language we had, so as to also be able to Lex and parse then function declarations and function calls. So that's a minor thing. But then we go on to type inference.

1:07  
So the

1:08  
idea is then to statically check if an expression I've written in my functional language actually makes sense type wise. So work there with integers, Boolean, and first order functions. And we'd like to be sure, before we actually apply the evaluator with our programme makes sense. So I'm not trying to, for example, add together an integer and the Boolean, or maybe I'm not trying to apply a function that is supposed to work on Booleans to actually an integer, this kind of thing. Okay, let me share my screen. And then we get going. Right. So there's two files to play with today. The first one is called first time lexer parser. And then what it does is this lexing and parser functions, for the little extended language, we now have. Just to recall, it is the old language. So we have expressions like we used to have, except that there are these two constructs that are new. so we can write function calls, things of the form f, apply to E, where E is an expression, and f is just a name. Well, it's a name for a function. But on the level of lexing and parsing, we don't know about it, we just look for a name. And then we should be able to to also have these function declared sorry, let constructs where we locally define a function. So they look like this. So, as always, in elite construction, the main thing is, is the body. But then there is this local definition here, we say a function named F is introduced, it has a formal parameter x. And this is then the definition of the function or you also call it the body of the function, not the body of the length, the body of the function here called erhs. Or just for the right hand side. So in abstract syntax, we represent it with a data constructor lectron, that takes four arguments, the function name, the parameter, the right hand side of this local function definition, and the body overlap. So everything else we had before in the abstract syntax, these are the two new ingredients. And our task is to get from concrete syntax for these things like strings of these shapes through Abstract Syntax trees, like these. Yeah, and the game is we deal with this before. So the the actual parser sort of is written in two phases. There is a kind of a preparatory step that is called lexing or tokenizing, where you take a string and you cut it into segments, which are basically are the key words or numerals.

4:25  
Or

4:27  
are there special symbols like parentheses or plus or minus or so? So this face is called lexing, or tokenizing. And then comes parsing proper. So we take a list of tokens and out of that, we need to produce an abstract syntax tree, which is a value in this data type expert expressions as abstract syntax rules. Okay. So all I'm gonna say here is just a little modification on what we did. We could go on Tuesday and Thursday. So I will really just run over it because it's minor modifications. Nothing much else. So the tokens look pretty much the same as before. So these are the kinds of things that we find in in strings, like every now and then we stumble upon a keyword perhaps or, or inequality sign, or we maybe find the numeral. And that is it. So what was the idea of, of the lexer, the idea of the lexer was given a string, walk over it, and you basically work in three different possible modes. Let me see if I can fit all on one slide yours are on one. Exactly. So concentrate now on this bit here. So this is all varies in the lexer, or tokenizer. The idea is to take a string which has already been broken down into a list of characters for simplicity, and turn into a list of tokens. The idea here is these like a little state machine, or automaton, as you might also call, it was basically three different modes, we can either be in the default mode, where we just look at the next character. And, yeah, we try to recognise in it one of a few possible things. And I can comment a bit more on it as we as we go over it. Then the other mode was, we are already in the middle of a numeral. So we've seen maybe a digit, like three or four. So we want to see if there are possibly more digits coming up, that will all together make a numeral. And the third mode tokenized word corresponds to a situation where I'm already in the middle of a word, which can either be a keyword or a name. So I've seen, I think, a lowercase letter that was a sign of the start of a word. And now that it can be more things coming up that are either letters or digits. And as long as these come sort of uninterrupted by spaces, or tabs, or new lines or special symbols, we just carry on and try to collect together the word. So what was the idea? So in the general mode, you see a list of characters about we want to turn it into a list of tokens. If there are no characters left, then we also at the end our token lists, we just finish. Otherwise, if we see one of these sort of operations in moves, then we see say we've seen it. And then we just process the rest of the characters by recursive code, it's very easy. When there is a whitespace, or tab or a new line, then we can in this face, just ignore it, it's just mean some extra space was left. And we carry on tokenizing the rest of the characters is so parentheses that operate in exactly the same way as these operations symbols, we just record the fact that we've seen a left or right parenthesis, like an opening or closing parentheses, we tokenize the rest. But now, if we see a digit, or if we see a lowercase letter, these are signals that we now have to go to a special node. If I see a digit in the general mode, this means I'm at the start of a numeral.

9:04  
So I convert the character to a numeral. And I just tokenize the rest of the characters in this mode tokenize int. And this argument here to the tokenizing, it actually works as an accumulator. So when tokenized int makes further recursive calls, it will be with the new values of the accumulator, where the accumulator has grown with more and more digits that we've seen. And each of those gives us the possibility to to see a bigger pseudo number. So really, this is an integer argument. First, it's just a single digit seen as an integer, but then we can also see multiple digits as an integer. A similar thing happens when we see a lowercase letter in this mode, then we say okay, now this is the first letter of something that's going to be a word and we go to this mode, though. Can I work we try to process the less the rest of characters. And then we say, okay, we can convert the first character to a string. So this single character string is kind of the seed value of the accumulator is the first is the accumulator, the first call to tokenize word. But then the recursive calls again, we will use new values of the accumulator, what have been thrown the, the string argument based on the extra characters we've collected. Right? So how would it tokenizing work I already showed this. So one of the two things can happen, either. The next thing that you see is the digit as well, in which case, you can put this digit together with everything you've seen before. So you take the current accumulator, which is already an integer, you multiplied by 10, which is a position shift, and you add the new digit. So for example, if you had already collected the number 79. And if now digit three comes up, what you do is multiply 79 by 10, get 790 and add three. So the new accumulator is seven 893. So this is the new integer you've seen so far, and more digits may come up. Whenever something else comes up. There is not a digit, so it's either a special symbol, or maybe simply a separator, like special, sorry, like whitespace. Or maybe no some characters come up, then we say the digit has finished here. And we, we just say, okay, the final result of this collection activity was that we've seen an integer whose value is this accumulator. And then we just go back to the default node, and, and, and tokenize, the rest of the characters or all of these characters in that mode. So if the first character is not the digit, we don't throw it away, we just actually go further with all of all of the list of characters that we have here. And word is done completely similarly, except that we don't accumulate a number we accumulate a string. So some string has already been accumulated. And at the moment when I see another character that qualifies for a character appearing in a word, namely, in words, we allow letters and digits, then we just concatenate the newly found character converted to a string to the string already have and we have a longest string, the string act is grown by one letter, or digit. How does lexing or tokenizing then work? Well, given a string, I first have to turn into a list of characters, which is kind of a helper thing. But then we apply tokenized to it. And this is pretty much as before. So now I can, for example, process actually something that has a function call in it. So maybe Lex led x equal x plus three in

13:28  
in what I don't like the five for example. And that should be fine. NVDA indeed it is five, it is fine. So what the lexer says it has seen the keyword let it has seen two names F and X, were considered the separate names not the single name FX because there was a separator here. So when we were looking for this word f then we first looked at the character f then we checked the next character, which was a whitespace. And at that moment, we went from the mode tokenized word back to the regime or mode tokenize the default mode. So when we said okay, since f was not followed by any further characters, f alone already makes a name. Similarly for we found the name x, then the equal sign and another time name x plus integer three, keyword in name, f integer. Okay, there's one thing that I perhaps jumped over too quickly. So there was this thing that when we've collected the word, then we have to decide whether it's a keyword or a name, well, or possibly keywords are here. Any other word that is not the keyword is treated as a name. And we've added a few keywords that weren't there originally like one false or now keywords. I can't remember if we had if then else before, but now we have them in any case. So nothing here. Check Whether the syntax is proper, I mean, I can write any sort of nonsense, for example, I can change the order of these things. Which is obviously, not something that makes sense. But on the level of tokenisation, I can, I can extract some tokens from here, of course, then parsing later will fail, because this left is in a completely wrong place.

15:24  
But on this level, it's fine. Now, how the parsing go, let's remember, where previously, parsing was based on a kind of a description that we call concrete syntax specification, of what kind of strings are meaningful at all, or what kind of already actually tokenized strings are good at all. And this goes by saying wells, these strings could be expressions, or they could be summons or list of summons, or factors or lists or factors. And there was a little grammar for this, since we've added function calls and these function definitions. And the picture will be a bit more complicated compared to what we had before. And also since we added Boolean constants, and also Boolean operations, but it's kind of a new level. So previously, we worked with, with essentially sums of products. So an expression on the top of it was a big sum, made of, you know, summons. And then pluses and minuses. Each summoned was a product made of factors put together with times. And that's because times bind tighter than plus. But here, we also have these comparisons. So really, an expression or the top level can either be like a comparison of two components, or just the simple comprehend. And then these components, each of them can be a sum. So now it's a bit more complicated the overall structure. So an expression on the top level can be a comparison, or maybe a simple, simple compound. Those are actually sums, the summons itself, our products. And then the factors in the products, they are something and then we have to think what and here's a little complication that actually enters. Why? Because, well, this is a functional programming language, and etc. So one of the new things that we want to have in our Abstract Syntax trees, as we already discussed, are function calls that know how are they written concretely, I'd like to be able to write something like this. But there are no parentheses here. And of course, there is sort of morally to play to two places where you might want to put them like one should be this. The other one should be this. So which one do we prefer? Well, we mean, always this, the idea is that function application should bind tighter than plus. But then how to achieve it how to how to organise the parser. So that it tries to also understand factors. Or Yeah. Yeah, so that they will try to understand factors as function calls. And then you get all sorts of interesting questions like, you know, should this be legal syntax? Well, in some sense, we could say it should be because we might say it should mean this thing, because there is no other reasonable way of reading it anyway. To save you've got the function name followed by if, then you should really look, try to parse this if until the end. So to collect an if then else expression, and the whole thing could be an argument. That's the possibility. But then, how about this. So this could mean f apply. This could mean simply, you know, subtraction, which would be to say that f is not the function at all. It's just a name for an integer And we're doing some subtraction that could be possible. But it could also possibly mean f of minus two, where minus is negation, right?

20:15  
And we have to make a decision here. And I will say here, that should always be the preferential reading. So when you apply the function to a negation of something, you'd expect that, that this negation is put in parentheses. That's the only reason, right? So let's see how to achieve this. Well, previously, we had these factors, which were simply a mixture of different things that are here in very different syntactic categories. So we had factors. And if the nails could have been a factor, a normal lead could have been a factor. An integer could have been a factor a Boolean could have been a factor, an expression put in parentheses, which sort of throws us to the top level in this grammar could could be a factor. And that's all well. But now since we do not have a special symbol for function application, there is really two ways or two things that the factor can be the factor can either be a function applied to an argument. Sorry, yeah, a function applied to an argument. And functions here are just names is the first order language. So it should be a name applied to something that is an argument. But it could just be not an application. And one thing we could do is we could say, grammatically, what are all these possible things that are not applications.

22:05  
And also here, the arguments can sort of be general expressions with a difference, that certain sort of general expressions cannot function as arguments, unless they put in parentheses. So let's see. If there is no application situation. So we just have a thing, rather a function applied to a thing, then it could be any of these forms a left or an if, or a negation, or it could be an A, where A is also all the other possibilities, just the name, just an integer, just the boolean value, or an expression in parentheses. But for an application to make sense, we may expect sort of reasonable pronunciation. So we don't want like this guy here to be legal syntax. So therefore, we single out if a something that we can use only zone without parentheses. But if we want to use if, as an argument, then it has to be in the syntactic Category A for an argument. And then you see there is no option for if it can only be achieved by seeing if there's an expression, which is then put in parentheses. So certain things always have to go in parentheses when there are arguments, the negation has to go in parentheses, if it's an argument, a lead has to go there. And if an else has to go there, when it is an argument, so that's one possible way to organise this understanding of what is what is good, concrete syntax. Now, let me remind you how a parser worked at all right. So they're here, the idea was that you define mutually recursively a whole bunch of functions, each one with a particular syntactic category, like the top level one will be for the syntactic category, ie for expressions, but then there will be other ones like parse calm for comparative comparisons, parse some lists for for these ssese, parse summon for summons, etc. And we saw all of that. So there'll be a whole bunch of those many functions. But they all work like this. So let's let's take the main one, for example. So the parse expert has its main purpose to take list of tokens. Turn it into an expression. But it's possible that some tokens are left over. So don't only return an expression, but you return a pair of an expression. And then a list of tokens that you could use, still to parse sort of the rest of the expression that your current expression is embedded in. Now, what was an expression according to the grammar, it can be one of the three forms. So we simply have to try to match the given list of tokens. against these things, to see, each one of these starts with a C. So an expression always starts with a comprehend. And my possibilities are either it is a component followed by equals, or less than and the further comprehend, or it's a component that is not followed by equals, or less than in which case, the component is the whole expression, and the rest of the tokens must be left unfinished. So let's just programme it. Given a list of tokens, I want to parse it as a component for which I have a separate function defined by mutual recursion. I just hope that the call to this function gives me back an expression and the following list of tokens, which are like the residual tokens, then I take those. And I've got three possibilities, either the rest of the tokens begin with equal or less, which means I hope I'm in one of these two cases, and nothing will fail, or I don't see a comparison sign, in which case, I say, Okay, what I return is actually orderly order already came back from this parse conference, together with the rest of the tokens, otherwise, we say, we have to also parse the rest of the tokens as a component. And we hope that then what comes back is a second expression, which is actually a comprehend and more tokens. And we form these expressions, which are the ones that we then collected on this level. And there are some some tokens. And all the other functions are similar. I talked about it at length last Thursday, so I won't repeat it. But let's just go to the important case of factors now, where we have to distinguish between a function application or a factor that is not a function application, which then must be one of these forums that qualify us as heads. So heads are something more specific. Sorry, or something more general than arguments arguments are more limited than heads. heads have arguments is a special case, but not not the other way around. Okay, so this critical place is here.

28:12  
parse,

28:15  
parse vector. So I'm given a list of tokens from which I actually want to get back and expression and some residual tokens. And I'm sort of following this grammar rule. Which says that every factor actually has to be in one of these two forms. So I'll try to figure out which for my having question now. And then I go on.

28:56  
And here there is maybe something special that we didn't see before. So what can I possibly do? Right?

29:24  
Take the list of tokens. And I look at different cases. If the first token is a name, then there is a chance that I'm here.

29:37  
And basically, let's for the moment, ignore this match. Basically, what I should do then is I should take the rest of the tokens these TSS and parse them according to the syntactic category a four arguments. I should then hope that what comes back is an expression for an argument and some remaining tokens and what I then should return is, is the recognition that I've now found the function call where the function name is actually the this first name here. And the argument is the expression I found here. And these are the residual tokens, which would then be good. But there are a bit more options, right? So Another possibility is that, okay, so I don't. So I'm, for the moment ignoring this bit here. I'll come back to this in a second. Actually, I'm also for the moment ignoring this bit here. So this looks like a reasonable thing to do. So if you find the name, then you hope that maybe the next thing that follows is like this. And then everything is great. And if it's not the case, that you find the name, then perhaps you would want to say that, then we just parse everything under the whole thing as a head, and whatever comes back there is also returned as the as the pair of an expression and token list that we do get. So that is the reasonable strategy. But wait, is it really the case? That couldn't, that we couldn't have, that the head also starts with a name, I mean, here, we say that in every case, when the first guy is a name, we go here. And then maybe when we don't find an argument, then we just fail. And we say, this is not the function call. But maybe it's possible. That also for for a head, the first guy that we find is a name, and then perhaps we should do something else. So let's go back to our grandma.

32:09  
So can it be that h also begins with a name. So maybe there is some overlap between these two cases, because here directly we see a name. And here we see h. So h can be all of these forms. But you see, h can also be an A, and an A can be a name, Aha. So there is an overlap here. When we don't find the function called maybe it's just, you know, a single name. So then how do we organise the parsing so that if we went for this option, then we don't have to regret when we fail. And we'd need to backtrack and come back to this option? Well, we should maybe do a bit of analysis then. So because let's just let's just see, which are the possibilities when the A can be a legal argument. If it is a legal argument, it has to be a name. Okay, in which case, we can recognise that we have a function call. Once we've seen two names in a row,

33:27  
or

33:28  
it can be integer, but integers are, are very easily recognised, because they have to be something of the form into whatever but it can if it's Boolean, then it we know it has to be true or false. Like if it's a Boolean constant. And if an argument begins, is an expression in parenthesis, then there is also a clear sign of it. I mean, it really has to begin with, with parentheses. So these are the only cases when we should say, Okay, yeah, we think we are here. Because you see, a head cannot be a four B of a form a name followed by one of these things. So let's incorporate that knowledge in our code. And then we avoid backtracking which would need to be processed otherwise. So what was our perspective?

34:26  
Yeah, we have to be here.

34:29  
So I said, At first, I didn't want to look at these these guys. But now I want to. So so this is simply to say. There is hope that this is a function call. If actually,

34:53  
the argument begins with a name which then me The argument is a name, or it is a numeral, or it is one of the Boolean constants, or it is parentheses. So this is just to check if there is any hope that, you know, we are in this case, really. So we want to be sure that that we are going down this route, if there is hope for this, and at the same same time, this is cluded, in this situation that we're here, because whenever we got the name followed by another neighbour name, followed by an integer name followed by through, it's clear that we shouldn't go in this case. So it's really saying either this one will succeed. Or we are completely doomed. So the whole parsing of the fingers as if faith, because we know already that we can't be in this cake. But then there is also the possibility that we already decided that the first guy is a name. And the second thing isn't an argument, then we should sort of take the special case that age is actually a single name, it's just the variable. And sort of move it over to this case, because we don't want to do any backtracking. So we say if it is a name, and it's not followed by any one of those, then let's say straightforwardly at this stage, that this is just the case that we didn't find a call, but we found just the use of, of, of like a normal variable, like first order variable, so a variable for for a number or a string. Okay. Then we're done. This is parsing, and then I can I can show this in action. So if we take something like this here, and we combine it with parsing for this, the function is Lex parse, it just calls the lexer and parser in a row.

37:01  
That should be reasonable codes, we should get the proper answer back. But we don't why did this happen? Because I took the wrong one.

37:12  
Yeah, this one is the one where we want to listen to experts. So we see that the guy properly understands that this is a function definition, let, so we're left with a local function definition, the function name is F, the parameter is x. The function definition itself is this guy, the function body, so to say, and that's the body of, of the whole let fun, which is just a function call. And then the one that we saw failing, there was the one where things were in the wrong order. So when we see something like this, because of its shape, I mean, the whole thing, where if you if you go through the parser, has to be effector. So here we see a name, then we see a following name. And that could be like a function application. And that would be perfect. But after that, there is some trash, I mean, there is some part of part that we cannot consume. And then we when we call the function, it says unconsumed tokens. Okay. So we could sort of go in finer detail. I've got some more functions here. So So what actually happened was Lex parse calls the lexer and the parser. And the parser wants that there are no leftover tokens. But if we go in smaller steps, I could use the function pars on just Lex and then we see a bit more information. So let me just call Lex of this thing. When I apply parse to the result, and this one will actually just return a pair

39:04  
of something that it found, hopefully, plus all of the leftover tokens, and let us see if we now have more luck. And I would say we should have more luck, because what will come back should be something that we can extract from here when we just start from the left like a function call. And then there should be that complaint that you know this part is left over.

39:32  
This is not called parse. I'm sorry, this one will also check that it's not its parse expert.

39:41  
Is it called parse expert.

39:44  
Yes, the top level is called parse expert. And now what comes back is an expression but there are also some unconsumed tokens. And you can see when you start parsing this from the left, you can reasonably extract an expression That's no problem. We say this is f call that x. But then the rest is left over. And this is what the function parse, doesn't tolerate, to parse, calls parse expert and then checks that the leftover list of tokens is empty and throws it away. So this one fails, but this one just gives us gives us what is left over at this stage. Okay. So this is lexing and parsing. Now let me go to something else, which was typing.

40:43  
So

40:44  
let's work with this language. Again, it's still the same language, sort of. But I'd like to know that following play the following game, I'd like to make sure that an expression makes sense, not only syntactically. But sort of semantically, in the sense that if I were to evaluate, I shouldn't get sort of runtime errors for for the type mismatch reasons. Like, it shouldn't happen during the runtime that I'm trying to add it together, say, a Boolean or an integer, or it shouldn't happen during the runtime that I'm trying to call a function that once the Boolean has an argument on an expression that actually evaluates to an integer. So we'd like to avoid these things. Yeah, avoiding these things ahead of time avoiding this ahead of actually executing or running programmes or evaluation, as we say here. It's called static piping. Yeah. So in languages with static typing, you refuse to run dangerous programmes. And programmes are called dangerous when they can give you these type errors during runtime. These are errors that differently from some other type of errors could be foreseen before you even run. And then this is like a reasonable precaution to take, yeah, avoid running dangerous or unsafe

42:19  
programmes.

42:22  
So what I'll do now, today, is not real type inference, which would work like f sharps own, so you don't write any type annotation. And the system just figures out the types for you. I'd like to do kind of a combination of type inference, which is the system figures out types versus checking, which is you also give your hints about types. And then to see if you agree with the system. So we do this kind of combination of inference and checking. A nice combination of inference and checking is is, is obtained when you're slightly modify the syntax for for function length. So remember, we had these function LEDs that took a function name, the parameter, the right hand side, defining then the function and the body of the whole length. And I'm just putting rec in parentheses to, to indicate that we actually understood this length as kind of lead rec in the sense of F sharp, so recursion is allowed. And let's just do a similar thing that is also allowed in F sharp we, we we can annotate our parameter with the type that we intend is reasonable for this function. So the function is supposed to work well with input of that type. And we also give an output type or the return type for the function as an annotation or as a hint. And we put these hints everywhere. So this means in concrete syntax, really, it looks like this. So you can actually write expressions, Allah, Allah this. So here is the here is a little app that is properly annotated, we're saying the input is of type int, the output is of type int, it has a definition, and then maybe there is a function call. So we work like this. And on the level of abstract syntax, then these type annotations are also captured. So let's run takes more arguments. Previously, it only took the function name, the parameter, the right hand side of the function defining the function and the body of the LED. Now it also takes the input type and the output type. The literal will come in the same order as they are given here. Okay. So what does it mean? It means that my type of abstract syntax trees for expressions is modified in one place. So let's find doesn't only take two names, and two expressions, but it also takes two types as arguments. Now, what can types be Well, hearing this language types can be either integer or Boolean. And these are the only ones that we can manipulate those values. But what we also have around our function names and function names actually represent well functions. And so therefore, we also put function types here. So we allow these kind of function types.

45:32  
Okay, and what's the game now? We would like, for example, to write a programme called infer, which takes an expression. And it's supposed to return its type or fail when it cannot properly be typed. And, for example, on this expression, in parse form, so given the abstract syntax tree for this guy, it should just tell us, this is a perfectly good programme. And when you run it, you get back an integer, well, which is a good prediction, because when you run it, you actually get back 14, which is an integer. And type inference should should figure it out by not trying to actually calculate, but only do little checks. Like here, we should try to understand if this thing is well timed. Well, how do we figure it out? Well, we put the hint that we are only ever gonna call it on integers. So we can assume that x here is an integer 11, we know is an integer, we know that adding together two integers is correct and gives a as a result, an integer. And this knowledge agrees with what we've said about the function. So at this place, we infer the type of the right hand side and we check that the degree is actually what the user has said. So that's one particular place of sort of inference and checking combined. And then we go to the body. For the body, we do, what is the body is a function application. So by the time we reach here, we know that f is of type integer int, then we infer the type of the argument here, it's very easy to see the three is an integer, and then we have to check that the declared input type of the function and the actual inferred type of the argument agree.

47:29  
It is the case here. So the argument is int, the input type of f is int. And then we say the whole thing has this type,

47:35  
the owl type, the output type of F here, because it's a function call, so therefore, the the type of the whole thing is an integer. Yep, that should be the mechanism. But if you were to discover some nonsense, like you're trying to add together to 111, then you say, okay, Boolean Plus, it doesn't make sense, then you fail, or maybe signal an error. Now, this type inference is easy, easily implemented by basically mocking, ordinary evaluation. But when in evaluation in an environment, you keep values of the variables currently in scope, and you find the value of the expression you're processing in inference in the environment, you just keep abstractions of these values. So for every variable, you just remember what its type is. And for the expression that you're currently processing, you also just remember or infer, the type it obtains. So raw is like evaluation, but the evaluation not on the level of, of actual values, but just on the level of pipes. Yeah, it just propagate pipes around in your programming or expression. And you try to see if everything works, or do you actually get stuck at some point, because you're trying to do something to apples and oranges. Which doesn't fit. Uh huh. So, in the case of so now what I do is I generalise The, the type of environments, previously, environments were just lists of pairs of strings and values. But now it's good to work with a sort of general notion of environment. So an environment can be a dictionary or whatever. So I can pair together strings and values to get the dictionary or to get an environment for values but I can also pair together strings and type names. And then I get the dictionary that I can use in my type inference. And I'm more or less give you the idea of type inference, there is one one further nuance, which is that if you do something like type inference say for if the nails then else Then, since before you execute the programme, you don't know which brand service will be taken. But you need to figure out the type for the whole, if you just do something that is different from what you're doing evaluation evaluation, you always go down one branch, namely the correct branch for the given Boolean statically. The Boolean doesn't have a known value, therefore, you have to try both branches. To realise like non deterministic choice, if you wish between two branches, as we say that we get a good time for if then else, only if whichever branch is taken, so only if in both cases, we do get back exactly the same time. Otherwise, we say there is some sort of contradiction in the if then else in the sense that, for example, here, if x is smaller than y, we know that this whole thing that then we go to the two brands, this one has type int. So therefore, the whole thing as typing. If x less than equals false, we go to this branch, we say false, this one has type bool. Therefore the whole thing has type bool. So statically, we don't know whether the whole thing now has type integer, a bool. Therefore we say this is Ill type. And that's reasonable thing to do. Because suppose this, if we're part of a bigger thing, maybe I wanted to add 17 to it. We really don't know whether this is safe. This programme is safe. If I am sure that I always go to the left branch because then the value is just 20. But if there is a slightest chance that I may need to go to the right branch, then I do get false plus 17, which is which is ill formed. Yeah. And since statically, statically means ahead of execution, I can't know which branches are taken, I should prepare myself for the worst, namely that both branches are possible in unfortunate cases. And I only say I'm safe, if in every case, things work out nice. Yeah. Right. So let's, let's get to the inference. As I said, inference, really is like evaluation, it's very important to realise this, at least in this case, when we have these type annotations around varies a bit of difference from evaluation in how you work with function calls and let fun. But we'll get there, essentially, you'll see that there will be no need for closures.

52:38  
And there is a reason for this. But otherwise, there is nothing very mysterious going on. Right? So what does inference do inference takes in an expression, and if it successfully evaluates, then what should come back is a type so knowledge that this expression is an integer or a Boolean? Well, if the language were higher or equal, theoretically, also be a function. But here, no, this kind of actually occurred because we can't use functions as values. And then there is this help of xillia argument environment. So this is where we recall the types of the global variables but also the types of all local variables, which can then be ordinary variables and functions. Okay. How does type inference go? If I see an expression that is actually a variable, then I just look it up in the environment. And if the environment says the variable has this type, then that's what we return. If the environment for some reason says that the thing is a function, then we say we're trying to use a function as a value, and that should be forbidden. And we say, well, in a harder language, you will be fine in this case, but here we just explicitly forbid it. Okay, then, what do we do for some simpler cases, let me jump over, let them call

54:08  
them let fun. So when you see a numeral, then you can straight away say this is a numeral. When you see a plus, then what you need to do. And that's now very similar to evaluation. In the case of plus and evaluate, you have to evaluate both summons, these had to be numbers. If they were numbers, you could add them together. Now we don't do the actual addition we just infer the type for the first summon for the second summon. If type inferences, they're both integers, I say fine, the result is then also an integer. Otherwise, for every other possible combination, like one argument is an integer The other is bool. Or one is bool. The other is integer or both a bool. We just fail and we say these arguments are not good. Similar for miners and payment negation. How about some Boolean stuff

55:05  
Well, the Boolean constants are of type bool. When I, for example, want to check equally the E one equals e two, five, check that. How does that work? Well, I have to infer the time both for you one and the two. These must be integers, because we only allow a comparison of integers. But the result we say then is an interesting case if then else. How do you do that? Well, first of all, it is mandatory that he comes out as Boolean, we infer the type three, and we hope it's Boolean. If it's Boolean, then we carry on and do something. If it's not Boolean, then we say the guard is not the Boolean. So that's already very bad. Otherwise, if this guy is Boolean, then there is hope that they the whole if then else has a good time, what time we just discussed this, for if they if then else to be well timed. Both branches have to have the same time. So whichever is taken, the venue should come out the same time and then that time is the time for the whole if then else. So what do we do is we infer the types of both e one and E two, let them be, say T one and T two. If they're equal, then we say, well, T one is the type of the whole thing. I could also say T two here the equal otherwise we say, if then else Bronte's are of two different types. So that's an error. We're basically done now. Now there are only the interesting cases left. Now the simple let differently from lead fun is also very, very similar. How would the devaluation for lead? So what was the point there? When we did the evaluation, the value of the lead is basically the value of the body. So here, the type of the lead is basically the type of the body. But the body can operate with one more variable than the lead itself, because there is a local variable. Yeah. So then in which environment, should I infer the type of a body? Not exactly the same environment and in which I evaluate the length? No, because it has to be an extended environment, where I already know that the new variable x, that kind of a key occur in the body has some certain type. So what should I do? It's again, very similar to evaluation in the evaluation, you need to actually, even before you get to the body, you have to evaluate the right hand side, there, you find the value of the right hand side, and then you record it in an extended dictionary or environment, that this value is now the value of x here, we do exactly the same thing, but not on the level of values, but types. So in with infer the type on the right hand side here. And then we say, Okay, this is gonna be the type of x and we put it in the environment, the new environment, and that's where we evaluate the body pump done. Now, at that stage, I can already do a few things. So I can show you a bit of this. Here it goes. Let's do some simple type inference. So for example, when I want to infer the type of say numeral three, what is it? That can be done in the empty environment? This is an integer. What if I just want to know what the type of true is? That is a Boolean. Great. What is the type of plus num? Three? Five. That's also an integer. How did it work? Well, no three had type int, num five had type int. Then when we looked at plus we use these inferred pipes and we said okay, since they're both in the result is good. How about that now, we want to add together num, three and false. We get to know arguments of plus or not integers. So in particular, the second argument is not an integer. And that's what we called it up here, right? It's the place

59:44  
to place this place. Yep. Okay, let's have some variables around. So if I just do in for var x in the empty environment, what can happen? Well Similar to evaluation, if you don't give the value to x in the global variable x in the environment, then the whole thing must simply give up because it has no idea what the value would be. Here, we have no idea what the type could be. We say x not found in the environment. Okay? If we say x is of type int in the environment,

1:00:26  
then it says, Okay, great, then var x is an integer. If I say x is a Boolean, that says great. X is a Boolean, so I determining because it's a global variable. No, suppose I said, This guy was an integer, then I can actually do the old thing. I can do plus var, say, No, whatever, no four. And it is an integer, because from the environment, we'll learn x is an integer, then we can add these things together. But as soon as I say x is Boolean, now, I get back to the old problem arguments of plus or not integers. Where did this come from? Well, four is an integer. But x isn't an integer according to what I've said. And of course, the same also works if I have a local definition. So if I have something like, let x be numeral three, in this whole thing,

1:01:28  
then I'm sort of locally fixed that x is an integer, the system can figure it out. And then we say, Okay, I'm adding together an integer and integer that should be fine, the result should be an integer. And that's what we see. But the moment I here say, Let X be false, in plus of x and four, then it will complain again, for the same reason, arguments of plus are not integers From where did it come now, in the original dictionary, there is no type given for x. But the point is, when we evaluate or sorry, when we type in for length, then we extend the environment here with this knowledge that x is of type bool. Because the inferred type for x is bool. And that's what happens. Yep. What remains are functions. So function calls and let fun. And now the interesting thing is when we did function definitions, local function definitions and function calls, then the what we had to store as a value function was a closure. So we had to remember the, the values of, of the non local of the non local variables or function definitions that must have come from somewhere else. So that was called the closure. So store the current environment. Here, it is actually not needed. Because we've got enough information in these type annotations, to recall everything. So the point is, in evaluation, we actually never evaluated the body before a function call, before an actual function call, which is syntactically stored in the expression for the function together with the environment, that's called the closure

1:03:27  
as the sort of meaning of the function here, we can check a function locally. At the at the moment when a function is defined,

1:03:39  
and add a call since the type information is there, we don't have to sort of revisit the function body anymore at all. And there is very little else to do. So let me see. Let, let's see. So what do I need to do when we have a function call? So F and E are? When we look up the function in the environment, the environment has to say that it's at f is a function type with say, input type T and occupy t prime. One all I need to do is I infer the type of the actual given argument. And I see if it agrees with what the functions declared input type is from the annotation. Yeah. If it is, then we say that the result of the function call is just the output type of the function. So we trust that the function does the right thing on the level of types is best that's not checked here the call let's check that the function definition side. So if the call argument is not of declare type, then we fail. And of course, we also fail when the thing that we call is not even a function. Like we tried to call a number on an argument or we tried to call To find out what happens at let fun, let fun now looks like this, which corresponds to this piece of concrete syntax. Well, similar to let the type of the whole length is the type of the body, so we just have to infer the type of the, of the body. That's the main thing to do. But now, again, not in the original environment, but in some extended environment, that would actually know what the type of f is. Oh, sorry, this is what I tried to simplify. Okay. So we have to infer, now that's correct, we have to infer the body in a kind of an extended environment where we also say what the what the type of the function is. And we get the type of the function simply from the declaration, we see that we've stated that the input has to be of this type, the output then will be of that type. So we add this to the environment, the new environment is called n prime. And this is where we derive the type of the body. So that's on the level of inference, but we should also check that the body is okay, I promise that I checked, check everything about the body at the function definition site. So let's do this. Here's the definition of the function what can the definition of the function referred to compared to end the function definition of course, can work with the parameter and it can also work with recursive calls to the same function. So, we should check we should type the sorry, we should infer the type of the right hand side. So this function definition in unextended environment, and this time, the extended environment should contain both the knowledge about the type of the function for recursive calls, but should also contain the knowledge about the argument of the function. So in refer when further type of the function definition, and this must then agree with a type of with a declared output type. So then we say, if this is not the case, then we don't return anything meaningful, then we actually instead say we we say the lead fund function body is not of the declare type. So there is a mismatch between the declared output or return type. And what we actually see here. Okay, that is actually completes the thing. Now we can check some more useful functions. So so this is the abstract syntax tree for a very little thing that I already talked about. And what should really happen is, as I as I described, so at the moment, when the function is defined, I should check that this thing here really is an integer as we purport that it is.

1:08:39  
And that's done by extending the environment. So adding to the environment, the knowledge that x is integer, also adding it to the environment, the knowledge that F itself is of type int to int, for recursive call, but here, we don't have any, but in general, we might have. So we do this check locally that everything is fine. And then we actually called site, we only check that the argument conforms to the declared input type of a function. So let's do that one. Um, so the the whole thing is called you one. There is a here, let's do type inference for it. We can do it in the empty environment, since there are no global variables. And we say it says integer. Now it's, yeah, here is perhaps difficult to see what what actually was done, but let's modify the tiny bit. So one of the modifications we could do is we call F on the wrong argument. So maybe I haven't. Okay. So let's call it on a modified thing. So I don't directly use this but I'll use something else.

1:10:11  
Maybe I want to call F on something wrong. So let me call F on Ponce tool. And then what does it say call argument not on declared tight. So we are now in this place where, where then error came from here. So I'm, I'm having this function call here, f apply to true if he's actually declared to be of type int to int, so the empty primary here are int. And then what we do is we check if the if the if the argument actually admits this type. So if we infer the type for the argument here, false, if it then agrees, the type for false is more, or is not equal to it. Therefore we say the call argument is bad. Let the call argument be good. Let's do a modification at a different place. So what was it here? It was, say num three. But let me edit the different place. Let me just say the wrong thing here, about the input type. Let me pretend that the function takes a Boolean to an integer. Now, what do you think will happen? Well, something should happen when the function body is checked, because now this will happen in an environment where we say, x is Boolean, and then type inference to this. So tell me that in the body here, I'm trying to add together a Boolean and the number and an integer and that should be not allowed. And indeed, this is what we say we say, arguments of plus not integers. So that's one way to say, Okay, let's do one final one. Let me have the correct input type. But let me purport I have a bad output type.

1:12:28  
Yeah. Now, from the point of view of the call, everything should be fine, right? Because I'm applying F, which is a function that takes an int and returns a bool to a number. So three is an integer, that should be fine. And the result should therefore be bool. From the point of view of the call, but there is a different problem. The problem is, the problem is that I'm declaring the wrong type, right? Because adding an integer with 11 gives back another integer. Not cool. So now we should have the complaint that something is wrong with a function definition. And let's see what it says it says, Let fun function body not have declared type. So we are in this situation where this ID card is false. Okay. So now we could try to fix this. So let's properly have a function that sends any future to Boolean. So I could do this by for example, using equals, or what is it called? For equal or equals, I could, for example, use less. So let's instead of plus useless, we're checking if x, which is an integer is less than 11, which is also an integer. How are things now? Now perhaps everything should be good, because this is properly here, a function from int to pool, as I'm saying. And then when I apply f two, three, it should return a Boolean, because I'm, after all, applying a function that takes an integer to a Boolean, num, sorry, three is an integer, so that should be good. We've actually evaluated it, we would check whether three is smaller than 11, which is true. But statically. We don't care if it's true or false, we just care whether a Boolean comes out. When we do this, we see a Boolean comes up. So that's what we did today. So I've shown you two things. One is how to modify the lexer and parser. And the only little challenge there was in the positive part, where we had to do a bit of a look ahead to avoid backtracking in the case where sort of on a on a shallow level, which was not immediately possible to determine which one of the two cases for a factor should apply for the given list of tokens. And here, in the second file, we talked about, sort of type inference for a modified version or functional language where we actually annotated Local function definitions with types. So these are something that the type inference can use as hints on the other hand, but it. So for example, figuring out the type of right hand side, we can already use the knowledge about what the type of the parameter is rather than having to guess it. But this also means inference is not just inference, but we also do some checking. So we should check that the annotations actually make sense that they're sort of consistent between each other. Okay, and that was it for now. I'll stop sharing. And I'll also actually say good bye

Transcribed by https://otter.ai
4:49  
Hello Can you

4:52  
hear me

4:54  
your hips very good.

4:57  
I saw the warning if there is no sound but I think it should

5:00  
Okay.

5:03  
So good afternoon.

5:08  
We're on the topic of functional programming for the second week. So what did we do before

5:16  
I showed

5:19  
what are local function definitions and function calls in an expressions language before. But now I'd like to discuss the the main, or one of the main salient features of functional programming, which is not so typical to other languages, namely higher order functions, we sort of did it in the F sharp Crash Course already.

5:43  
But this was maybe brief. But today, we will go into this topic in depth. So one of the leading ideas in functional programming is

5:55  
your compute with functions. But functions are as people say, first class. So whatever you can do to ordinary values, of simpler types, like maybe integers, or floating point numbers, or strings, or characters, or such,

6:13  
or even more complicated things, like pairs, or triples, or lists, the same thing, just you should be able to do also two functions. So functions are our values, like anything else in a higher order language, which means

6:28  
they have equal rights. And equal rights here means like, what can you typically do with values, you can name values, yeah, the value comes from somewhere, you'll give it the name.

6:41  
You can pass values around. So in particular, functions can return values.

6:48  
functions can take in values as arguments.

6:52  
And then the functions themselves are values, which is in this sort of first class approach, they have the same rights as everyone else, functions should be able to take other functions as as arguments. And they should also be able to return functions as values. This is somehow the idea. Also, you should be able to name functions arbitrarily. It's not like you define a function with a name. And it's, you know, this name is going to accompany this function. And this is the only name that the function can take. It's not like this in a higher order functional language.

7:27  
And you ask, why is this good?

7:30  
Well, there is two reasons. One is kind of aesthetic, if you wish. I mean,

7:37  
if we want to be systematic, we've got these values. So why should some values have less rights associated to them as others?

7:45  
In these times of sort of equal opportunities, that's one.

7:52  
But another is this really gives you modularity in the language for practical programming. So would you use higher order functions, above all, and over the place? Is his code reuse and ease of maintenance and sort of compacting code writing shorter when you can?

8:10  
And let's try to get going

8:14  
on exactly sort of research agenda,

8:18  
I'll share my screen to you.

8:22  
with you.

8:25  
And then I won't see much about user when you just interrupt when something is unclear when you want to ask a question, it's because I can't see raised hands.

8:37  
So take a coffee break in the middle. Yes, we can. Very good.

8:42  
And remind me if we go over time, but let's take a coffee break in about

8:52  
which would then be around 255. No.

8:57  
505305. Okay, um,

9:04  
share the screen.

9:10  
That's my screen for today. I'm talking about Python and functional

9:15  
languages, sort of in general, but we tried to fake it in F sharp as we did before with all these simpler languages. So before I even get to this,

9:25  
let me remind you of some examples of higher order functions we saw and what their utility was.

9:32  
And let me give you some more examples, just to sort of emphasise the point why you would be in this business at all.

9:45  
So I actually showed you two kinds of higher order functions in these first lectures.

9:52  
Some had to do with list manipulation, they were sort of important

9:58  
repeating

10:00  
Software patterns. So to say that you see with lists, actually with any kind of container data types, but lists are maybe the sort of most

10:10  
you know, they're the first example you would you would bring.

10:15  
And

10:17  
typical examples would actually be map and filter.

10:23  
I'll tell you what those are, or recap what those are. A version of filter is actually also called reduce.

10:31  
And you might, for example, know that,

10:34  
you know, these names are old names, but, but they've recently revived, for example, in connection to something called MapReduce.

10:43  
Which is, which is an idea of how you do high performance, parallel computing. The idea is, if you've got a huge data structure with lots of nodes, then often computations with such things happen, so that many, many moves can be done at individual nodes, where you're sort of little data payload is stored.

11:08  
And then every now and then you aggregate what all of these nodes store. And the interleaving of these two phases, is often called map and reduce because map is the idea that I do the same thing everywhere. And in the parallel world, it means every processor does the same thing to its own data. And that all happens in parallel synchronously. And then there is this other phase where maybe nodes in a in a in a parallel process, they talk to each other, and maybe you'll collect some data in this way. And that's typically called reduced and what there happens is nodes to talk to their neighbours, these to their own neighbours, etc, etc, maybe there is some some sort of centre root node that collects the overall aggregate. So these ideas have been around in for decades, and now and then sort of in your incarnations of them come up. In functional programming, they've always been present.

12:08  
But of course, the idea that

12:11  
you try to generalise things that you do on different types of data structures, is common in many places. Like for example, you talk about visitor patterns, say for for collection, data types, this is this is typical.

12:27  
And then what what can happen during visiting and, and higher order functions are the way to capture exactly these things.

12:35  
So, but back to sort of, let's,

12:38  
let's, let's go back to, to square one. So the simplest higher order function, or one of the most simple that people typically show you, which is not only higher order, but it's also polymorphic is the one called map.

12:53  
And besides being higher order, and polymorphic, it is also interesting in that it actually works with a user. Here not user defined by the principle user definable data pipe, through programming with pattern matching.

13:07  
The idea is, you should be able to do the same thing to any element of a list.

13:14  
So in F sharp, this thing is called list map. Or if I open the listening space, then it's just called map.

13:23  
And it's a handy way of processing lists. So maybe I want to do the same thing to all numbers in the range of one to 10. And then I can say what that thing is that I applied to all my numbers in that range, right? I could do the following thing, I take in three, I take in the number and they made me want to multiply by three.

13:52  
I should get back in your list which is based on the given one, but to every element, the same thing has been applied.

14:00  
So where is higher order ness here?

14:03  
The function map takes two arguments, one of them is

14:08  
not

14:10  
a source of high orderliness. It's an argument

14:15  
not such a simple type as integers or floating point numbers, but it's its list. General list of anything here it happens to be lists of integers.

14:25  
And

14:28  
the hard Holderness is actually the first argument is the first argument is not an ordinary thing. It's not like an integer or a floating point numbers string. Here, the first argument is a function.

14:43  
And then the trick is to write these functions. Yeah. So somehow abstract out from your programming problem at hand. If you notice that the same thing happens everywhere. When you abstract out the problem of finding out which is the thing

15:00  
VAT is the same and happens everywhere. And you have to write it down as a function.

15:06  
And I've done here, these things were called anonymous functions. So it's possible to write the function without giving it the name, I just say fun, I said with my parameters, I give the function definition or which is also called the function body. And they never named the function. And this is perfectly fine it legit, I can also give the function a name maybe like a lead local name, that is just as fine, I can say let phi the times three thing

15:33  
is

15:35  
not to turn. And that is the same thing.

15:40  
In effect,

15:43  
Now, of course, is evaluated differently and syntactically is different. But

15:49  
the utility for us

15:53  
is exactly the same unless I made a typo here, no, that is exactly fine. And there is this polymorphism. So I can apply these things

16:02  
to,

16:05  
to list of other types, or I can achieve lists of other types of for example, I think I can apply the function float, float to every integer, I hope this is correct.

16:17  
And then I get back a list of floats, which are my integers, each one individually converted to a float.

16:25  
Another very typical one was filter,

16:28  
where,

16:30  
which is also polymorphic, you send the list to a list. But now you cannot change the element type that's different. So if the first if the thing given is a list of A's, the result is necessarily a list of A's. So you can't send oranges to apples here.

16:47  
But what you do is you pick out good elements from a list and leave out the bad ones. And this was the definition.

16:57  
And then putting together a map and filter, you can do lots of things, right because many problems reduced to them. And what you typically do is you pipe a lot of these things together, right.

17:11  
And piping actually is another example of a higher order function. So here's a bunch of functions that don't specifically do anything with lists.

17:23  
But

17:28  
but work on any type, but they're very useful, for example,

17:33  
to put these map and filter things together in a good way. So what is pipe, so here is one possible piping

17:42  
highroad function also, you're often called higher order functions combinators.

17:48  
So I might use that word. And this is really like a pipe in in a Unix shell, if you know what that is. So really, this one doesn't achieve much it just is provides you kind of a different order of function application.

18:03  
So pipe applied to x and f does nothing else then applies F to x. But I've got the convenience that I can write x before F.

18:15  
Like before, not temporarily, but

18:19  
in the given line I'm writing x will proceed, F and then I can use this thing in an infix way. So actually, I can plug the symbol between x and f. So these parentheses indicate that. So when you define a function name in parentheses, it means you're going to use it as an infix.

18:38  
Okay,

18:40  
as this this thing looks like some sort of a syntactic manipulation, but it's actually a higher order function. What does it do? It takes in something of any type. So x is of type A, where A is a type variable can stand for any type

18:57  
F, then cannot be quite of any type f has to be a function and not just any old function, but the function whose input type is a, and then how to type can be anything B.

19:10  
But then what comes back cannot be anything anymore, that what comes back must also be of the same type B. And the way that you achieve it is you take the function here, f was of this type applied to the element x, which was of this type, and you do get the result of type B.

19:28  
And now I can write things with piping. Sometimes it makes sense. Sometimes it doesn't like a very bad way. For example, to write three plus four would be to say that I pipe three into

19:40  
maybe the function that takes a number I and then just adds forthwith.

19:47  
That's possible, but maybe, yeah, why would you do that?

19:53  
I mean, you would never write such a thing directly, of course. But sort of in some context.

20:00  
combinations like this makes perfect sense. So let's, for example, play the game that

20:12  
what can I do?

20:16  
I have some list of numbers, maybe a big list of numbers,

20:21  
I may very well have the idea that I want to chain to do something to my numbers. So I may 1 want to, for example,

20:32  
change it by mapping a function to it, which maybe just the following

20:39  
perhaps.

20:43  
Yeah, perhaps it multiplies everything by three, that could be good.

20:49  
But then maybe I don't like the result. So this will be the list of all numbers from three to 300.

20:57  
With Step three, but then maybe I say I only want even numbers from there. So then I could do the following thing.

21:10  
Sorry, list filter.

21:13  
And then I could give some predicate based on which I choose these numbers. And perhaps I would want to do this, I would want to check if

21:23  
the number is

21:25  
even. I hope it was written with the percent sign I can't quite remember.

21:33  
But we'll see. And that should be one example of a sort of more complex plumping of these pipes together. So I first send this list to my list map, as the second argument, the first is given here. And then the results to to list filter, and maybe then I want to map something to it again. Let's see if I managed to be right.

21:59  
And I did, yes. So these are the numbers between six and 300, but not at step three. But Step six, because I have to leave out all of the all of the bad ones, namely 915 21, etc.

22:14  
Yep.

22:17  
Okay, what other things could we do, we can do all sorts of things.

22:24  
One very typical one is, you may want to iterate the number a certain number of times. So this is a very generic part of the function now that we call twice.

22:37  
It takes two arguments F,

22:39  
which can be any function provided its input and output type are the same, some type variable a, signifying this here.

22:50  
And then it also takes another argument.

22:54  
You know, the result is a function in turn takes another argument, I may or may not write the parentheses here, I can just leave them out. Because I don't out is right associative, the arrow symbol.

23:06  
So the second argument is this x here.

23:10  
And once I've provided both

23:13  
the result lives in type A, and the way it's achieved is I don't just apply F to x, which is a nice thing to do.

23:21  
I applied

23:24  
I apply f to the result again.

23:27  
And this is a reasonable combinator. I think here, it's already in scope. Because

23:33  
I guess I brought it in.

23:37  
No, it's not. Okay, that's we can always define it. So let's do let's twice

23:44  
FX equals f of f of x.

23:50  
Yeah, here's the bit of magic that I will explain one of the next times possibly on Thursday, and which may have positive do quite a bit already. So F sharp has this thing called type inference. Even if I don't write down type annotations. F sharp tries to make sense out of what you manage to scribble to jot down.

24:12  
And theory thinks is this. You can ignore the F and X, they're just noise. But you could say, this is just kind of information for you could have mnemonic information that you had called the parameters F and x. But it's really irrelevant in the sense that no one else has access to these parameters. Their local scope is here. So you can't possibly refer to this F or x by name and hope to get anything but twice is now in scope.

24:42  
So let's try something.

24:48  
I can of course, twice, something simple, like maybe fun. I like these kind of things we already had. I want to add four to a number

25:01  
But not once, but twice.

25:05  
And here it comes. So I've applied it once, which was gave 21, and then another time, which is 25.

25:14  
But that's not the simplest. That's not the only possible application of the other thing, I can literally apply to anything. So I could very well do the following.

25:26  
I could take my list

25:30  
from one to 10. And now I could have the idea that they apply list map something

25:36  
to wait twice.

25:40  
And what can I do?

25:43  
Not quite anything that

25:53  
I can, for example, this is all boring.

26:00  
I can, for example, map the function multiply everything by three tweets twice.

26:08  
This is now a bit silly. So overall, this list is traversed twice. First everything is is multiplied by three. And then there is another traversal, in which course everything is multiplied by three again, as a result, everything is multiplied by nine. So that's maybe not the smartest programme programme that he was right. But this is just illustrated, this is how these things work.

26:35  
You may want to do all sorts of things, right? It's not very complicated to invent the function thrice. For example,

26:46  
by just saying that, you really want to apply your function three times.

26:54  
And actually, if you think about it a little, then you can write a generic higher order function that iterates a function any given integer number of times, you write this with ease by just recursing on the future.

27:10  
What often happens playing with higher order functions is you want to plug one function into another function is partially applied in the sense that it's like a two place function, but maybe only apply to one argument.

27:23  
And

27:25  
this way, by partial application is very easy to say.

27:34  
It's easy to fix the first argument of my function, like for example, for subtraction, I can apply partially

27:41  
minus three is a perfect function.

27:47  
It is a function that can apply to anything, what it does is it applies, the result is that the function minus three

27:57  
is applied to four.

28:00  
And the result, of course is minus minus one.

28:04  
So but the thing is, I can use this minus three as a separate function, right. And it makes perfect sense, like so far, I wrote my list maps in this form.

28:18  
Maybe something like this.

28:21  
But say if I wanted to

28:23  
subtract

28:26  
every number in my list from three, it is easy to write shorter, I can write it either by saying fun i, i minus three,

28:36  
no three minus i

28:39  
something

28:42  
maybe one more parentheses.

28:47  
And that's possible. But I can write it even more compact using the fact the fact that minus is actually a two place function. And I can choose to just apply to one argument, namely here three, and I've already achieved the the specialisation I want. So the following has exactly the same effect.

29:08  
I'm doing with my parentheses now.

29:17  
See, this has the same effect.

29:21  
But I can use this facility to write something so short, only because in subtraction, the convention is that the number from which you subtract comes first, and the number that you subtract comes second. And here I've chosen to fix the number from which I subtract.

29:42  
There is no way to directly play this game. If I wanted to fix the other argument.

29:48  
I can easily write something like this. I may want to

29:52  
subtract.

29:57  
It's too bad that it's twice and then consider anything

30:00  
Let me go back a bit. Of course, if you do three minus i twice, then it's three minus three minus i, and you get back the original list. That's not what I meant. I meant to show you something like this rather.

30:14  
So this thing here are subtracted I've, every I from three. And I wanted to say this is the same as

30:24  
minus three

30:27  
maps to everything. But the same way I can't do the other thing. I can't say,

30:34  
subtract three from every number in the list.

30:39  
For this, I need fun I arrows high, or I could do a different thing. So what is my problem? The problem is subtraction has minus has two arguments.

30:49  
I'd like to do partial application, but not to the first argument, but to the second.

30:55  
The second argument, the second is not the first. So I can't possibly give the second argument without giving the first in the syntax directly. So what's the trick? The trick is, if you want, and often you do is you could write

31:13  
a higher order function that takes any function

31:18  
which has at least two arguments

31:21  
in a certain order.

31:23  
And it just trans modifies

31:27  
the function. So it's the same function, but take the arguments in the in the converse order.

31:34  
So the second argument comes first and the first come second. Why would you do it ever? Well, if you want to give both arguments, then it's just you know, okay, maybe you didn't like how your colleague wrote the function and you, you're very stubborn, you have a certain preference, you want arguments in a certain order. That's one, of course. Or maybe you've got two different libraries from which you pull in functions into your code. And the designers have had different ideas about things and you just want to sort of fit everything a bit nicer than you might want to do this. But also one prime application is you want to apply or to place argue, function partially not to the first argument, but to the second argument. And the way to do it is make the second argument, the first make the first argument the second and then partially applied when you first.

32:27  
So let's see this in action.

32:31  
So if I apply minus

32:35  
42 and 17.

32:39  
This is 25. Yeah, remember this number is important number. Now we define this thing, which is not yet in scope.

32:48  
So now I have my swap arcs, change the order of arcs. And that let me now right swap arcs

32:57  
minus applied to 42 and 17.

33:02  
Guess what happens? What is subtracted from what now?

33:09  
Well, what happens is, minus is used, but with 17 as the first argument and 42 as the second. And the result is minus 25.

33:23  
Just to arrive at this result, minus 25. You would never go to these lengths, or doing any of this.

33:30  
But you might want to depending on your tastes to do this.

33:35  
In this example, no which example?

33:41  
Yes, in this example, so I'd like to sub have a function that subtracts three

33:49  
from something given

33:51  
the way to do it is to say, swap arcs

34:00  
minus

34:02  
three, the trick is minus minus is the ordinary minus, which takes you know the number from which you subtract first the number that you do subtract second,

34:15  
swap arcs. Trans modifies

34:22  
this function into another, which is also two plays, but it has the arguments the other way around.

34:28  
So therefore, you if you apply this partially to just one argument, this one argument is not about the number that you subtract from, it's the number that you do subtract.

34:39  
So therefore, now you should expect that every number in this list gets decreased

34:47  
by three and that's exactly what happened.

34:51  
And this is like an endless game. Yeah. So.

34:56  
So here's a very typical one. I call it parallel composition.

35:00  
It kind of is.

35:01  
So maybe someone gives you two functions.

35:07  
One sends A's to B's, the other ones and C's to these ABCD are completely arbitrary types having nothing to do with each other in general.

35:16  
Now, these two gadgets give you a way to transform any pair of an A and the C into a pair of A, B and the D, how that's like putting together little circuits.

35:32  
So I've got only one means to go from A to B, because a and b are arbitrary types. But I know the only thing I know about them is that I can convert from one to another using a function like this. And I also have a way to go from C to D.

35:48  
then surely, if any old pair comes in my way, comes my way, sorry, then I can just, you know, dismantle the pair, get the two components, apply F and G to them, and put the resulting things back into pair again. So here's the definition. Yeah.

36:10  
And now I could, I could work with it. So let's do park on

36:20  
let's go Park, the park.

36:29  
So here, again, what I think is the type here, actually, F sharp confirms my type, but it gives it in a slightly noisier way. It also tells me what all my formal parameter names were in this definition where it actually used pattern matching.

36:46  
So part comp.

36:48  
Now, there's so many ways that you could count the arguments, you could say it has two arguments,

36:54  
which are pairs, but you could in some sense, also say there are four,

36:58  
were two of them have to be given at once as a pair.

37:02  
And this is already a partial application. And then you can give another tool, but you also have to give them at once or one by one.

37:10  
Anyway,

37:12  
what you need to do is if a pair of functions and a pair of arguments comes in, you just apply them pairwise.

37:22  
put together the result into a pair. So what could we park on?

37:27  
I think I can't do anything super impressive, right? Now. Maybe we could do something like

37:35  
it's always very important to know what adding 17 to something gives. And then maybe

37:41  
multiplying by 42.

37:44  
And then I applied maybe to

37:49  
let's at least have integers and floats mixed.

37:53  
And then I applied to

37:59  
I have no idea

38:01  
1000

38:04  
maybe just 10 but have the right times to 1000 xinetd your attendees a float.

38:11  
And here's the result. So

38:14  
to 1000, I've added 17 to 10.

38:18  
I've applied, you know multiply by 44. Multiply 42 by 10. Rather, I should say

38:41  
How does that feel?

38:45  
Great to see you.

38:54  
anyone's been there? They're

39:01  
still here. Yes. How does this feel? So um, these are

39:08  
some important examples of how you go about pirate functional programming. I should really make sure that I've motivated is but but the trick is.

39:20  
Yeah, the trick is really to put together some circuitry of things. And you can be sort of vague, for example, what you want to put as gates in your circuits and you can only supply these things later. So for example, all of these functions here, efficient chair again,

39:42  
all of these functions here like those. They are just some plumping machinery that don't do a lot, right they just pass arguments around to functions etc.

39:56  
But

40:01  
But then then you have to meet at some point. So for example, in the case of Lisp programming, you're at the meet by actually providing some, some some interesting functions here

40:11  
that do something are actually similar here, right? So you can swap your arguments how many times you want, but in the end, you want to plug in some real function that that that is of interest to you.

40:22  
There is like no limit to this game at all. So one, one typical thing you might want to do is to say,

40:30  
let's do one more.

40:33  
Maybe I'll call it

40:35  
diag for diagonal.

40:42  
What it does is it takes a function that needs two arguments of exactly the same type,

40:50  
and provides something else maybe an element of B. And this function is modified into a different one.

40:59  
That actually just takes an a into b.

41:03  
And the definition is not hard.

41:06  
Suppose this function in here

41:09  
is F.

41:13  
Suppose this guy here is x.

41:17  
Now there is almost I mean, if you look at the generosity of this type, there is not so much I can even choose to write here, there is very little I can write here.

41:29  
If B were some fixed type, I could cheat, I could say, for example, if we were integers, I could say yeah, let's just say 17. Always. But now B is a type over which you have no control whatsoever.

41:42  
Yeah, the only thing you know,

41:45  
if you have to make a value of b is that you can use these two things.

41:51  
And now this is like a game of Legos. Yeah.

41:54  
Or Tetris or something. So these are some pieces, and you have to plug them together in ways they fit. And you just hope that you can make the you know the figure that you're required to make. In this case, I've got this a given. And I've got this function given that can consume A's and make a B for me.

42:16  
What can I possibly do, there's only one thing I can do, I can submit this a I bought only one a I'm required to have two A's. What I can do is I can I can I can use the same a twice because I don't have two different days given I put these A's here and ask the function to give me back a B, this bag, because there is no one else that can make a B for me.

42:38  
And therefore the definition I can write is this. I mean, what else can you write, you can't write anything else. Maybe you can write Of course, the same thing with different variable names. But beyond that, there is not so much else you can do to agree.

42:54  
And that is actually a pretty useful thing. So because often it is the case

43:00  
that you've written some function that is pretty general for some purposes. But then in some applications, you're only need a very specific form of it. You only need to know what the function does. So to say at the diagonal, which is when both arguments are the same.

43:17  
Let me just give you an example. What example could I give you?

43:21  
So

43:24  
let's just diagonalize

43:27  
times.

43:30  
And let's apply it to

43:33  
five.

43:36  
Let's not do this because the system doesn't know what back is. And here I forgot Diack and doesn't tell me anyway.

43:50  
So let's just diag

43:53  
times,

43:55  
Any guess what comes back?

44:04  
Yeah, times is a function,

44:07  
which is sort of ad hoc polymorphic, it can take either an intendant to an int, or a float and the float to float.

44:15  
By default, it's always inferred to take an int and then to an int, because it's not fully general, it doesn't take a and date way in full generality.

44:24  
But that's fine, because

44:27  
diag is happy whenever I've got the function that is of this type for some values of type variables a and b. And here I can choose both A and B to be int. So my argument is int to int to int, that's good. Then the second argument will also have to be int, but it is, so it's fine. And what comes back is 25.

44:47  
Now when I put three, I get nine when I was four, I've got

44:53  
16 when I when can I get 100. What function is it?

45:00  
Well, it's sort of generally, X times X or Y times Y as written. So it's called square. So that's one way to,

45:10  
to write it.

45:14  
Okay. I think maybe this is good as a last example for the moment.

45:21  
No, we're very questions about

45:27  
this part.

45:31  
I'm wondering about the F YY syntax. The F is the multiplication function. Yep. Why isn't it like Why FYYFY? Why? Okay. So,

45:48  
okay.

45:52  
Well, multiplication really is a function,

45:55  
buddy. It's a function of a, with a special syntax that you often call operations.

46:02  
Namely, these ones where you are allowed to write the function symbol between two arguments rather than in front of them, there is two ways to write multiplications.

46:13  
So one is sort of the official one, which says always the function name should come first. And then you know, you're making a function call and then you give the argument. So therefore, this should be like 10 times 10, or this should be 10 times seven. But of course, that's not how we generally want to write multiplication. So therefore, there is disagreement that I can of course, also write the ordinary thing, which is exactly the same. Okay, I understand. Thank you. So, so what is generally the convention in F sharp also typically, in functional programming languages that,

46:47  
you know, typically function application is infix, sorry, prefix, which means function and a bunch of arguments.

46:59  
And that is it. And these kinds of function. names for such functions are typically just ordinary names, which I think Here comes generally would begin them with a small letter, followed by letters and numbers, and maybe some special symbols are allowed, like, primes or dashes, whatever they call.

47:20  
Maybe it's also even possible to write them with capital letters. To be honest, I don't know. But that's not the typical convention.

47:29  
But then, there is a special agreement that whenever

47:35  
a normal function identifier cannot be something like this, it can't be like it can't start with a special symbol.

47:43  
But you allow them

47:46  
in infix. So a typical infix can be anything like this, it could be like arg one, like x, then maybe plus minus is a special symbol, or maybe plus slash or some such thing.

47:58  
And you can define these things, just by saying, maybe like, let's define a role. Plus slash x, y is

48:11  
maybe x plus y

48:16  
divided by three, for example, x plus y divided by three.

48:22  
And I think that should be accepted.

48:25  
If I remember the conventions correctly, yes. So I can make my own operator symbols. And now once I've done this, these ones will have to start with a special symbol cannot start with a letter. Then when you define it, you have to give it in this prefix form.

48:43  
But then later, you can use it

48:46  
the nice way, like four plus five,

48:50  
it will do something, I think it will be three because it's like nine divided by three.

48:56  
What did I do?

49:04  
For plus, slash five?

49:13  
Oh, yes, sorry, sorry, sorry, parentheses, I'm adding four together with five over three and five over three here is,

49:22  
is one, the integer division, of course, we get five.

49:28  
Actually, I meant to put the parentheses in a different place, but fair enough. That's correct. So this is this is the mechanics of it you. By default function applications are prefix. Your normal function name starts with letters. But then you can have these things that are often called operations, which, if you write them without parentheses, you can put them in the middle of two arguments.

49:52  
And then some further arguments can follow.

49:56  
I should also say one thing, and that's important. There can be more arguing

50:00  
So for example, this one can take more.

50:08  
No problem.

50:10  
Where did it go?

50:16  
Bad key combination.

50:20  
So that's fine. But no, it's interesting because

50:25  
I mean, this syntax is a nicety for,

50:29  
for two argument functions, right? But this one has three. What about it still has to, but it just returns a function, isn't it?

50:38  
So now it can get a bit confusing. So now I can do things like 100 plus dash 10.

50:47  
This is a partial application of that guy to x and y. So on its own, it's a it's a well, well defined thing. But it's just a function, which

50:58  
is waiting a further argument, namely that and I can give it but where this is an infix notation. And really, I should be able to give it just after so.

51:11  
But maybe it requires parentheses No, I'm not sure. Okay.

51:15  
And you see, there is a parsing problem when I write just like this.

51:20  
The silly guy thinks that application always binds tighter than an operator symbols with try therefore tries to apply 10 to 500. That's not possible.

51:30  
But I can indicate that this thing here should be read as a thing.

51:36  
which happens to be a function and that one is an argument. And now it's good that you get some value.

51:44  
Yeah, to see this.

51:46  
So it's literally about the two first arguments have, in general multiple argument function.

51:53  
Okay, but now I think other further questions are written here. Do you want to have your coffee?

52:05  
Anyone?

52:10  
Everyone is having their coffee,

52:12  
coffee, coffee, let's go Yeah, let's take five minutes until 15 past, and then I'll not do much today, I'll just show the evaluator from the last time wherever changed the few lines, so that we can now actually programme our own or make our own higher order functional programming language on the level of abstract syntax, which then is a bit clumsy to work with because we don't get or here we don't adjust the lexer and parser for that, but it's it wouldn't be a big job and then you will have your own, you know, done yourself.

52:46  
functional language where you can add more features or remove them or play around. Okay, coffee, break time.

1:00:40  
Hi,

1:00:48  
can you hear me? Let me check?

1:00:51  
Yes, yes, yes. Do you

1:00:54  
please a bit of mystery around these

1:01:00  
pseudo sound settings? Okay.

1:01:03  
Let me share this screening again.

1:01:14  
I'm here.

1:01:18  
Remember we discussed

1:01:21  
expressions first, what could we write in expressions we could write? Well, first of all, we couldn't write much, we were able to write numerals plus times minus maybe a negative Roman numeral, then you could add Booleans. if then else.

1:01:37  
The first fun part was to add names into expressions. So you can have variables, variables don't have values by themselves, if they're global variables, you better somehow fix from the outside of the expression what the values of the variables are. And you could say, there is an environment, which is like a little dictionary where you can look up by name, but the values of your variables are.

1:01:59  
But another game was, you could also have local names which have limited scope within your global expression or top level expression. And then these little local definitions which say, in their scope, these variables that I've introduced have these values. So a variable

1:02:18  
local definition is given by a lead construct, which has a body which is an expression here.

1:02:24  
And then there is a definition part that consists of a pair of a string, which is the name, new name and a right hand side expression, whose value

1:02:35  
in the enclosing environment determines

1:02:41  
its value. So in this language, it was perfectly possible to write stuff like let x

1:02:48  
be three, in someplace like class

1:02:56  
x.

1:02:58  
Four,

1:03:00  
we play this game many times, so that that should now be an expression of formal expression,

1:03:05  
unless I made some typo, or miscounted, the parentheses

1:03:09  
and, and that is the mean by itself, it doesn't do anything. So if I want to see what its value is, I have to write an evaluator. And if I use names that are global here in the sense that they are not locally defined,

1:03:24  
then I have to provide an outside environment. And then that was all it for some while ago, or some while ago, sorry. But then we introduced also the possibility of defining function names.

1:03:38  
And making function calls.

1:03:43  
Let me actually first talk about defining a function with a name. These were functions with one argument.

1:03:53  
And the syntax was a bit like this. So a name for the function and name for the parameter that you're using the body to talk about what is happening, then the function definition or the function right inside the function body. And finally, the body of the whole app. So this bit here is the function definition corresponds to this here.

1:04:17  
And this is the actual interesting part. I mean, the function definition is kind of a helper thing. Yeah. But that is the actual thing, in whose value you are interested that, in reasonable cases then calls the function because otherwise, we didn't have any other way of using a function other than calling that was the first order language.

1:04:38  
Now in a higher order language, I change this a bit.

1:04:43  
And namely in the calling aspect. So previously, a call could only be a function name,

1:04:52  
applied to some argument, which was an expression.

1:04:57  
Now here, we are going to be a bit more liberal.

1:05:02  
Namely, the function

1:05:05  
in this function position of a function application need not generally be a name, it can be something far more general, it can be, I don't know, maybe another application of

1:05:18  
all the functions. So you could do to place functions by sort of putting calls inside each other. And that works. And we could do other things. And the reason is,

1:05:30  
I have higher order functions. So not every function I use is necessarily, you know, given by just the local definition of function that I call may very well have arisen from myself having already called the higher order function. So imagine, for example, list map.

1:05:50  
Okay, here, we don't support lists. But, but but the idea is this anyway. So

1:05:55  
a function that you may want to apply to a list need not necessarily be a primitive function that I've written, or primitive, sort of a function that I've written directly as a function that operates on lists. Rather, that could be something that list map returned to me, and that that can now apply to my given list. Yeah. So it's perfectly possible if list were supporting here that this guy here, or maybe this argument to which I'm applying a function, could be some list.

1:06:27  
But the function on which I'm calling it is, is not just given by a name, but maybe it's of the form list map applied to something else, this might apply to some function a little.

1:06:38  
Okay? So on the level of syntax, not much changes here. But the overall ideology changes, because now we want to be able to pass functions around, like, you know, first class values.

1:06:54  
Yeah, no racism, all values are of the same class.

1:07:02  
In older days, one could joke at this place, but now I can't anymore.

1:07:08  
But anyway, so it's like, full equal opportunities thing? And,

1:07:16  
um,

1:07:19  
yes, and, and also, we can return functions as values. So it's perfectly possible that that the right hand side is sort of the body here, well, that expression actually evaluates not to a number, or to a Boolean, it may evaluate to a function.

1:07:37  
Let me first illustrated with little examples, what what do I have in mind? What should we be able to write? And what should we be able to evaluate, actually, so the first two examples, I think, are going to be easy, they are going to be like ordinary first order situations that we could already do before.

1:07:58  
So for example, the following one should it be possible,

1:08:02  
I should be able to say that I'm interested in the value of f1 apply to 12.

1:08:09  
In a local scope, where I actually have some definition for f1, which says f1 apply to any x is that x plus one.

1:08:20  
That should be possible, and it's easily possible. So we just code it up as this.

1:08:26  
And it's exactly the same that we had before. Except before. When a function was applied. It was always a name. So we didn't write var. But now here, the function that is applied can be any expression in principle. So strings are not expressions, but var string. So variables are actually they do count as expression. So I have to write var here.

1:08:52  
And that is perfect.

1:08:55  
I should stress which I did last time, but I forgot here, that when we talk about lead fun here, we sort of always implicitly mean that we don't want to make any difference between lead and lead track. So everything is kind of wreck by default. So I don't write it in the syntax, but you should think we do allow recursion.

1:09:14  
So here is a bit more interesting. That's a way to do

1:09:19  
factorial on your own. So we first make a language of our own. And then we make our own factorial. We make everything with our bare hands.

1:09:30  
So how would you do this?

1:09:36  
So this is the result here is factorial applied to a particular number. So called their var fac to n.

1:09:50  
I could actually choose to return just factorial itself as a function and that will also be fine.

1:09:58  
We'll see this later.

1:10:00  
This modification, but then the How is factorial defined. So this is

1:10:06  
a function introduced locally and we say factor of x is the usual sort of recursive definition that says, Well, if x is the number zero, then the factorial is one else, I have to take x and multiply it with with the factorial of its predecessor to this way, all together, multiplied together x x minus 1x, minus 2x minus three, all the way down to one, which is the base case. And that's exactly how you should find the factorial. And you can just straightforwardly code it up. And it would be exactly the old definition, again, except for this additional VA.

1:10:48  
But now, let me consider something we couldn't do before.

1:10:54  
something completely different in nature. So, so this is really higher, or the functions in action, at least in one way, and then we had more high on the list.

1:11:04  
So I may be, remember the, the thing that I called twice before,

1:11:11  
I think it's still in the context of my F sharp buffer. So it was a highlight of the function that takes any old function, any old, simple thing and applies the function to the simple thing twice.

1:11:29  
Provided that the types of IP so it's, it's about exactly this, it's actually I want the programme this little gadget,

1:11:38  
I want to programme twice,

1:11:42  
applied to multiple, multiply by three,

1:11:47  
and 11. And the idea is, in the end, this should be a convoluted way of writing down just by way of an example.

1:11:55  
A machinery for multiplying three times three times 11, which would be 99.

1:12:03  
But it's done with functions here. So model three, is a simple first order function. So in this scope, I have defined model three, it is there, why is just the parameter to it. And I'm saying multi is three times why

1:12:20  
what is not defined here, it's defined in a yet further out their scope, namely here, the top level,

1:12:28  
introduce these, you know, to this expression, a local function tour.

1:12:35  
And tour of G is what.

1:12:38  
And that's then interesting.

1:12:42  
The value of tr, G is because I can only programme one argument functions, and I can't write what we did right? In my F sharp but I did have the luxury of writing twice f x was f of f of x, I can't quite write this. Because

1:13:02  
I've chosen to do the language in such a way that the function only can take one argument, I mean, multiple argument extensions are possible was actually a homework exercise. But, but you can also do just with one argument, but then it's a bit more work. So and here, this is done. So we don't define twice f x, we define twice g

1:13:21  
or twice F, then

1:13:24  
f and g, of course didn't make any difference.

1:13:32  
How?

1:13:34  
Well, I can do a trick. I say twice g is just GG.

1:13:41  
And now, this is the first place where you see that something that is a function is a return because twice g is not a simple thing. It's not an integer is not a Boolean, it's really a function. So twice g has to be a function.

1:13:58  
But then what is this function that function itself I defined locally and here I take the further argument, which is called here x.

1:14:05  
So I say twice g of x is just g of g of x.

1:14:11  
To see this.

1:14:14  
I could do the same thing here. I mean, I don't need to define twice like this. I could also define twice by saying left twice, but it's just a bit convoluted. I could say twice g is

1:14:31  
left dg x equals g of g of x

1:14:38  
in GG.

1:14:47  
That should be fine.

1:14:52  
Yes, and that is the perfect twice. How do I prove it to you I can just maybe apply to

1:15:01  
My squaring, squaring was Tiger bIack star, and then I applied to five. So I'm squaring five points first, I get 25. And then I get something bigger.

1:15:11  
Namely 25 times.

1:15:18  
Yes, 25 times 25. Which six? Is it really?

1:15:25  
anyway.

1:15:27  
So that's, that's a piece of code. So these kinds of things should work.

1:15:32  
Now, I've defined actually this thing as these three.

1:15:36  
So let's see,

1:15:39  
what is E three,

1:15:43  
e three is this horrible thing, which is just the same thing that I've written, maybe printed out with a slightly different indentation, but it's literally that.

1:15:53  
And then I actually do have an evaluator. And here there are no local, sorry, there is nothing Global Indian that you need to know. So that one should evaluate in the empty environment. And we can try eval II, three in the empty environment.

1:16:09  
That's 99.

1:16:12  
Remember, when we did values, or values are tagged, so every value because it's kind of a mixed bag, a value can be an integer or a Boolean, or it can actually here even be a function. So I have to, I have to make a discriminated union or a data type out of those. So here, I'm saying this one that comes back is an integer and

1:16:34  
okay.

1:16:37  
So that's what we'd like to do. But let's also look at the variation. So of course, I mean, this looks very rigid. So why did I need to write the programme to apply to all three apply to 11? Because now is applied only to 11? And only 213? Can I go a bit more generic? more general?

1:16:55  
Maybe I would like to return just twice small three?

1:17:00  
because then I can apply not only to 11, but to every other possible thing that comes back?

1:17:06  
My Way, isn't it?

1:17:09  
So let's try that one as well. This is called e4. It's just literally this written up in my

1:17:15  
abstract syntax.

1:17:17  
Let's see what the four E's.

1:17:20  
Before is that. But now how do I use such a thing? Well, I can try to evaluate that something comes back, it will be a closure, because we said function values or closures. That's not by itself. super interesting.

1:17:35  
But let's see anyway,

1:17:38  
basically, four years 64.

1:17:42  
Yeah, what what comes back is a horrible thing. It's a closure.

1:17:48  
And we haven't discussed closures yet. Today, we discussed them before.

1:17:54  
f shows that it's a function values for its closure. And we get to know a few things here that somehow the functions name is for recursive causes GG, the parameters x, this is maybe the body

1:18:08  
and the local environment is somewhere This is pretty difficult to read. But I now have the possibility to actually

1:18:18  
be able to use it any way I want. So I may want to apply it to some, some

1:18:26  
some real argument.

1:18:29  
So why don't I just call it with something? So how about calling e4 is a perfectly good expression. So I can always apply it to something remember, call takes an expression.

1:18:44  
So the whole thing is an expression and that can just apply to something. And then I can apply to something like maybe 11.

1:18:58  
And that should work and that should be 99 but not necessarily 11. So why not seven, and I get 63 because three times three times seven is 63. So this I can do I can do other things. I can for example, abstract out this nonsense and I can say I call this var n

1:19:17  
and then I provide the end from the outside I say n nice by the way fight.

1:19:25  
So my expression now says e4 apply to var n

1:19:29  
n is a variable name that is not introduced inside the expression is a global variable. But if I provide the value from the outside, I'm able to evaluate it provided the Detroit no five but integer five.

1:19:43  
What comes back is I 45.

1:19:53  
And of course I can do further things I can maybe abstract out this thing. I can call this thing n

1:20:00  
By can say,

1:20:04  
you know, my gadget does this my gadget

1:20:09  
applied to N is this thing,

1:20:12  
which takes my expression and evaluate it in an environment that I set up here by just saying what I want the value of my variable NB.

1:20:25  
This is getting pretty cool already. So there are multiple ends around. This n is a variable name in the object language, which is my little, you know, highroller expressions language that I'm programming, this n is a different thing. He this n is a variable in F sharp. And these are two different things, right? For F sharp, this guy is not a variable, it's just, it's just a completely dumped string.

1:20:50  
Whereas this one is a real variable. But of course, for my object language, this one is a variable.

1:20:56  
I can take my gajic. And now again, I can apply to all my old things, if I want, like I can apply to 11. To see all these gains are possible.

1:21:09  
Doesn't make sense.

1:21:12  
Questions about this font, I just show you the code, the code is literally changes maybe in all together, three or four places in the code.

1:21:24  
Because we changed very little

1:21:27  
in the setup of the language.

1:21:34  
Okay, let's do.

1:21:36  
So this is just a reminder of what dictionaries are. So in general, in a dictionary, I can keep for strings, any sort of

1:21:45  
meanings, I may want to assign them, like I can associate the value to a variable name, I can also associate the type of variable name depending on what I'm doing. So here is actually used for assigning values later. So this is the type variable is instantiated to value, but it works with everything. This was my little function for looking up a key or like a name in a dictionary.

1:22:10  
And let's not repeat it anymore.

1:22:13  
Now, the first place to change is is the notion of closure. So just leave space here. So what kind of values do we work with, we work with integers start with a Boolean tag with B. So these are the values of integer and Boolean expressions. But we can also have expressions that return function values. So now, it's not only that we can throw in, you know functions to the environment, because we made a function definition, which we can only use with a call.

1:22:44  
Now calling is just one way to use a function. In other ways you don't use call a function at all, you just pass it on to someone else that may be calls it

1:22:55  
at the end of the day.

1:22:58  
So functions are first class.

1:23:01  
Function functions, meaning is what? So I don't the same approach that we had before, where we basically say,

1:23:10  
we have sort of a very intentional understanding of what the function is a function is basically, its definition. Remember, it's syntactically recorded syntactically. So the most important things to remember about the function are the parameter name, and the function body or right hand side.

1:23:28  
But then there is two more things that we need to record.

1:23:32  
So these correspond to like, you know, x and d.

1:23:37  
Like a function parameter, and some some function body that uses this x is the expression whose value is returned, it contains x, which is the parameter.

1:23:47  
So as we argued

1:23:50  
last Tuesday.

1:23:53  
In reasonable functional languages, you use the static scope rule, which means that any names that you see in the function definition that aren't local but come from the outside should be taken not from the function use site, but from the function definition side. So therefore, in the closure, you have this additional facility, that you remember what the environment is at the point when the function definition is made. So when you make the function definition, you remember this, and you only ever use it when you actually finally, at the end of the day, call the function.

1:24:29  
Now, an important thing that happens is previously

1:24:34  
we didn't have to remember what the name of the function was because, so that the name was intimately tied to a function.

1:24:41  
If you introduce function, introduce the function under the name of F.

1:24:46  
This is the only name that it ever gets. So I could have previously written something like let f of x equals

1:24:56  
something in terms of F index, so it can use recursion right

1:25:00  
to death can be used to the right hand side, and then maybe there is some body. That's how function definitions were before.

1:25:09  
They're still like this. But you see, now I can do much crazier things. I mean, I can I can, I can make this a function definition. But then maybe the next thing I do, I say,

1:25:22  
let g be this F.

1:25:25  
And then maybe I find that in somewhere, and then maybe I finally say, bla bla bla bla g

1:25:32  
17.

1:25:37  
And at the moment, when I form the closure, which is when the function is formed,

1:25:43  
I sort of know that its name is F for the recursive call.

1:25:50  
But later, maybe I create this alias for this function, I mean, I say G is also a function, and by the way, it's the same function as F. And when I then look at the meaning of G, it is a closure, which in its right hand side refers not to G, but still to F, because we just literally recorded the syntax of this right hand side.

1:26:15  
So we have a problem. So a function can change its name, or can it?

1:26:21  
Yeah, in his lifetime, so to say or in its usages.

1:26:26  
But, but but the meaning of a function depends on what his name was, because the function definition can contain a recursive call. The way to sort of overcome this is just we record the given function name in the closure.

1:26:41  
So if the function definition is made of the form, let f x, blah, blah, blah, then we remember that blah, blah, blah, will remember F and x, and also will remember all of the current environment. This means wherever the function ends up under whichever name or maybe unnamed, we still know what the name of the recursive call was.

1:27:04  
Once this is done, we are fully set up for the evaluator. The evaluator is this humongous piece of code that you see here. It's like one screen full and the bit more.

1:27:17  
But it's not changed a whole lot compared to what we had. So

1:27:23  
an evaluator its mission is given an expression, find out a value for it.

1:27:31  
If the expression is closed, so if all the names it uses are introduced within the same expression locally, then that is enough to determine the value. But surely, an expression may be non closed, especially if a top level expression is closed, its sub expressions are never closed anymore. Like, you know, the bodies of lead constructors are not closed because they contain further names. To work with these, we have this auxiliary argument that we call end, that records what we already know, are the names of the of the sorry, are the values of the names that have been introduced in outside

1:28:11  
structure.

1:28:15  
Everything is pretty much as usual, I just only maybe very quickly remind you of the main cases, like when you see a numeral, then there is not much to evaluate. You just say, okay, it's a numeral, therefore it is an integer, and that is the value. If you see a plus of two expressions, then you have to evaluate both, there is no way that you can ever figure out the sun without knowing the summons.

1:28:39  
You're only lucky if both come back as integers to you, in which case, you can add them up and say the result is an integer. In all other cases, like one of them is a is a Boolean or a function. You say, you know, I'm a, I'm a complete failure, because my arguments are not integers.

1:28:59  
Okay, similar for Boolean expressions and Boolean constant that there is nothing much interesting happening

1:29:07  
when I look up a variable, so if a thing is used as a variable, previously, he had to be an integer, a Boolean, because

1:29:17  
a function could not be used just so a function could only be used for calling. Now it's no longer the case, you can just also return a function.

1:29:26  
So this case actually becomes simpler. Previously, we looked at the thing in an environment, if it was a function, then we said something bad is going on. Now, we always just return what comes back from the environment.

1:29:39  
So if you're at the name use place, just consult your dictionary, like google it up.

1:29:45  
And that's your value. Yeah, Google says 1770.

1:29:52  
Let is the old one.

1:29:55  
You evaluate your body in an extended environment. What are the extended

1:30:00  
environment is achieved by evaluating the right hand side of the local name definition, and pairing up the local name with the value that you've got and adding it to the dictionary. The reason is,

1:30:13  
this expression here, can can refer to one name for one name more than the whole length expression, namely, to the local, the new variable x that was introduced here.

1:30:31  
When I make a function definition, this is pretty much as before, the only difference is

1:30:37  
the normal now, I only consider the statics Cobra, forget about dynamic, we will do this.

1:30:43  
The only difference is that in the closure now, because as I told you, you know, a function can have a new names or completely loser name, we remember the functions name from the time that it was defined in the closure. So when I make a function definition,

1:31:01  
then

1:31:03  
the value of the whole let fun construct is the value of the body, but not in the original environment that, you know is passed as down from the main call. But in the in an extended environment where we've inserted the new knowledge that the name F is now bound to the closure, which is the following about the function, we remember what its name for recursive calls in the body. The parameter, the function body, or the right hand side of the definition, always make a difference between the function body and the left body, these are different things. And then the environment from the time that the function definition was made. This is super

1:31:49  
important.

1:31:51  
Okay.

1:31:54  
And now the only place to explain is this guy, how does calling work?

1:32:09  
Calling works

1:32:11  
quite a bit the same as before, but there's some differences. So

1:32:20  
I have to do what previously the function was given by a name, and they just looked up the name in the dictionary.

1:32:28  
And it had to be a closure here is not the case that the function can given can be given by a complicated expression. But when you evaluate it in the given environment, it should give you back a closure,

1:32:41  
like an honest closure, which is this thing here.

1:32:48  
If what I call closure is not f something when I just fail, I say the expression called is not a function. Now this as closure was actually quite unnecessary, because I've already given the whole thing, exactly the same name flow. So that's kind of remnant from the old code. It doesn't do any harm, but it's also quite useless here.

1:33:07  
Okay, so then what happens if, if the function I'm calling really is a function? So everything is good in this respect? So what what do we do we do the only thing

1:33:17  
you have to evaluate the argument in the environment you're given?

1:33:26  
And then we have to evaluate?

1:33:47  
Correct? Yes, you must be, then we must evaluate the function body in an environment, which knows both the value of the argument which was figured out here, we just say, okay,

1:34:01  
the body can now use the parameter x, and we just agree that the parameters value is whatever is passed down to us as the argument.

1:34:08  
And then just for recursive calls, we say, you know, this body can contain F, we say the F value is the very same closure. And that ensures for us that recursion works.

1:34:22  
Well, that's pretty much it. So

1:34:26  
in the old code, this f was not present.

1:34:31  
But, but f actually was the name that we made the call with here the name may have changed. So I just or maybe the whole thing originally.

1:34:43  
Yeah, the name may have changed. But, but but we have some expression that evaluates to a function, but the closure knows it.

1:34:53  
And in which we can just use it.

1:34:57  
Okay.

1:34:59  
And that actually

1:35:00  
should be what I wanted to say here. So now we can see if we can evaluate something.

1:35:09  
What can we evaluate? We've already evaluated a few things.

1:35:14  
On the topic of this twice, let me maybe revisit this with this example of a factorial

1:35:21  
two factorial.

1:35:26  
Now nicely, this thing is written so that it contains the expression contains n as a global variable. So therefore, I can evaluate it to maybe in some environment that knows something about and

1:35:40  
so maybe I want the factorial of six.

1:35:48  
So there's just one string.

1:35:50  
And its value should not be six, but I six, then we get back the factorial of six, which is 720. That's nice. But I can also abstract this thing out into a function by just

1:36:03  
returning not verifique applied to n.

1:36:08  
But just var faac itself.

1:36:14  
Perfect, maybe I should say.

1:36:17  
So let's do that.

1:36:19  
I can say let back. Maybe I call it is this programme.

1:36:27  
Which part? Maybe this may fade now because of indentation reasons. But maybe I'm lucky.

1:36:37  
I think I just want to save more back. So we don't apply planned. That's the point.

1:36:48  
Just

1:36:52  
so that's my programme for four factorial, which doesn't return fact apply to some given n, it just returns back. So when I now evaluate it, I can evaluate it in the empty environment, no problem.

1:37:04  
But it's just a closure. So I don't see anything very interesting. However, it's a function. And now I can make calls of it.

1:37:13  
So I can call it on anything I want now. So I can do call

1:37:19  
this fact on

1:37:23  
norm,

1:37:25  
anything, maybe 12.

1:37:33  
That's the factorial of 12. And in case you didn't know, that's the factorial of 100.

1:37:41  
The reason is that some silly overflow with integers happens. So integers have a fixed size.

1:37:48  
Okay.

1:37:50  
This is pretty much what I wanted to say. So what are the messages? Holderness is important, if you are serious about

1:38:01  
whatever abstraction you've invented, it should basically acquire the same rights in your language as anything else. So if you can pass around stuff,

1:38:12  
and you've invented the thing like functions, then you should be able to pass them around.

1:38:17  
If generally, your things have values than functions should be values like any other.

1:38:25  
In particular, they should qualify as return values. The pragmatics of this is you can reuse code, you can write very general things.

1:38:36  
And then you can just plug little pieces of code together with kind of a blue as if

1:38:44  
and

1:38:48  
an implementation wise, if you're systematic about it, there is not too much additional overhead about any of this game. As you could, for example, see, my evaluator wasn't so much complex, more complicated than the evaluator had shown before. Actually, maybe in some sense, this is unfair, it was even kind of simpler or more streamlined. And that exactly came to the fact from the fact that I wanted to treat everything the same way. So functions received exactly the same treatment the same features and and Booleans.

1:39:23  
How we're doing with

1:39:27  
questions,

1:39:37  
Is this good? Is this clear, very unclear needs sinking in a sinking

1:39:53  
my peers previous experiences, it needs time to sink in.

1:39:59  
So that you can sort of

1:40:00  
To fully exploit the

1:40:04  
power and responsibility that comes with functions, I mean, they are a weapon and then you have to use it with care. But

1:40:14  
yeah, if it also for humanitarian purposes is only for the good of humanity, good needs sinking in. Yes, I did do a thing I published the solutions of the first assignments, if you go under assignments, and you just click on assignment one, then amongst all the fines, you see the solutions as well.

1:40:34  
And then we'll grade those.

1:40:38  
I do recommend that you talk to the DBAs. And then the classes on Wednesdays so you'll get some further insight and can play with it can play with things.

1:40:51  
I'm going to spend two more weeks on sort of explaining the central concepts of functional programming. So next time, we'll sort of dig deeper into polymorphic types, and then specifically into type inference that and then when we get over these things, we look into sort of what are the most crucial things about the imperative languages, which is always like programming with memory, like mutable memory is specifically references or pointers, however you call them. But then also the associated memory management like either languages with explicit allocation and deallocation

1:41:27  
or C, or languages where this sort of happens behind your back.

1:41:34  
Allah, Java or Python, if you wish.

1:41:39  
were usually there is something in the picture that you don't see that is called garbage collector, but it's very important for maintaining

1:41:49  
high hygiene and you having enough memory to do something useful with do something useful.

1:42:00  
Okay.

1:42:02  
Anything else for today?

1:42:07  
is very much like you to speak a little more.

1:42:12  
But it's okay. Also, if you just talk to the TA,

1:42:16  
ask questions on Piazza. We'll try to answer.

1:42:24  
Okay, I think I'll then stop the recording here. This will be it for

1:42:30  
today. And then talk to you again on Thursday.

Transcribed by https://otter.ai
4:35  
Hello

4:37  
sorry too

4:38  
late.

4:40  
There was a technical complication Can you hear me?

4:46  
Yes sir.

4:47  
Very good isn't good

4:57  
today

4:58  
we should do something different Front, a bit, I'll try to go slow and informal into a difficult topic or, but but also an interesting one here, which is type checking and type inference. And we'll continue with it next time in some more detail. But for today, I just tried to show sort of on examples, what are some ideas how you would go about finding a type for a programme that comes without any type annotations? Like we are able to write in F sharp and like, we are also able to write in our own little language that we are devising here.

5:40  
And we

5:42  
discussed what are the issues, why this is a fun thing to do, why this is a useful thing to do. And what's also the difference between type checking and type inference? So let me share my screen. And then we can discuss recording properly, yes.

6:12  
Okay.

6:15  
Whenever there is a question just show up, because in this mode, I can't, I can't see anything about the petition, participant list or check. So where do I start, maybe I start actually, by just showing you some examples. So we have this little expression language of our own that we're developing in a functional direction. And I'm trying to show different things there about it can only be see what we can also maybe just play in the in the F sharp buffer, because F sharp is a similar language by itself. So we've seen that we can write things, function definitions, in F sharp where we give the system the interpreter, no idea whatsoever about the types we have in mind. And then some some sort of guesswork goes on behind the scenes. So for example, if I write something like let's add 2x equals x plus two, this is a function definition, I'm saying here is name, your global name, the parameter for the function, and that's the function body or the we also call the definition, this is what we want to return, no pipes, not anywhere. And when I enter this, and then the system tells me that this is actually a function from integers to integers. And from somewhere this information comes why

7:53  
I don't know.

7:55  
I can also write maybe some functions that are tiny bit different, maybe I write x plus two point or 2.0. And then the system makes different throws a different conclusion somehow, based on what I wrote.

8:18  
I can sometimes do very indirect things. So for example, I can write my own function, say, x, which maybe that's something like, if What if, if, actually, let me give some more x, y. If y is smaller than five, then x pause. may sound like a very stupid programme, right? But I'm just giving you an example of a tricky inference. What do you think what kind of pipe? Will F sharp tell us at this point? Well, it looks like many things can be pretty free here. Especially it looks like I'm not saying a lot of things about x. about why we say something. So here is a comparison of y with five. So if you know a bit of how comparison works in F sharp, then it works between things of the same time. And also these cannot be any type but types that are orderable. So five is an integer. To compare five to anything that other thing also has to be an integer. So y will be found out to be an integer. But how about x? So 2x we don't apply any operation as if but let's see. We get to know Before has the type it's a function taking a Boolean x and an integer y, one by one not as a pair but one after another so that it can also be partially applied to say x only, and returns a Boolean From where does this one get come it comes in a very indirect fashion. Maybe before the return type, it's not even so complicated to figure out that what has to come out is a Boolean. That's because here in the elf browns, we say what we want to return is false and that is a Boolean. But we say nothing particular in the Venn branch. And also we really say nothing particular about x either. But then there is the convention that for such a thing to be well defined. So, the programme works similar type wise whichever branches are taken, this gives us a constraint that the then branch and the and the else branch of if the nails always have to have the same time. Now x is unconstrained. But, but false obviously is constrained false is of type bool. So therefore, this system figures out that makes better be of the same type. Or actually, then brands better be of the same type, but then it's just the variable x. So therefore, x has to be of the type bool. So we know bool comes out, but then this x was also one of the input parameters. So also here we say. So, sometimes things can be very indirect. I can also write functions where f have F sharp has too few clues to decide about concrete types. And then it will say something in terms of type variables. So let me give you an example of this. Maybe I just call it make pair. It takes an X and the Y and the produce is the pair of x and y.

12:16  
What do you think it is? It's time well the type could be many things. For example it if x is Boolean y is integer what comes back is a pair of x&y, which were Boolean integer, but of course, x&y could be other things, pairs out a polymorphic type. So we know nothing really about pairs. Other than that there is a fixed number of components, while in the case of pairs is two. In any type, it's some fixed number of components. Each can have their own type. But we say nothing beyond that. So let's see what happens. F sharp says make pair takes two arguments, one by 1x

13:05  
and Y. Give us back a pair of two things. And what are the types the type of x is a that is a type variable.

13:16  
Here it is an unconstraint type variable, which means that in a real application of look, Bear, I can use any x i want. So any type A qualifies any type A is good. Y is also have an unconstraint type. Here we say Y is of type B, B is another type variable type variables are signified by the little apostrophes Here are quotes. And they are so unconstrained that they don't even have to be the same type X and Y their types can be chosen independently A and B. But then once they are set, it's not arbitrary what the return type of the function is, it has to be a times b times is the type constructor for pairs, but also any other tuples or tuples, of any other length. So this is already fixed in terms of these type variables to see this, right. And if this is not what I mean, if I actually meant MK bear to be far more specific, then now I don't have a choice, I have to actually start giving type annotations, maybe I'm fixated on the idea that y always has to be an integer in this case, then it's okay. From my part, to give a hint. This is what I want. Why has to be constrained in this way. And then the system tries to do its job figuring out the rest of the types for everything here around let's see what comes out. comes out is x remains unconstrained. But But Then of course, something else gets also more precise. So if y is an integer, this pair is not a pair of two arbitrary types, but it's a pair of something of type A and underneath.

15:10  
Of course,

15:13  
I can go further I can, I can give the system more information. I can say, okay, no, no, no, x, by the way, is a character. And then F sharp copes with it, it says, Okay, yeah, you want to tie your hands you've done. So this is the type I will then figure out and this is still a well type programme. I can go over the top, I can I can have inconsistent ideas. So for example, I may want this function now to return a Boolean. What happens? Yeah, this is clearly unreasonable. So the system should complain. What does it complain? So it says, I've really been in mixed minds here, or a sort of I've been confused here. So I'm trying to do too many things at once. And it says something interesting, which maybe doesn't quite agree with what we think we wrote. So it complains about this particular point. So the whole of the top level of the right hand side expression, and it says this one was expected to have pipe From where does this one come? Well, it comes from us having said this, right, so the right hand side here determines the return type of the function. With this notation, we've just said, This is what comes back in some other languages, you would put like in C, you would with this rule, at the very beginning here, you would say, we've got the Boolean function make pair, which takes arguments of this type, but here, these things are written in this order. So we can give types two parameters. But the type, the return type of the function is given us the last thing and always sort of, you know, you have to parenthesize correctly here, so you shouldn't, these colons wouldn't better pertain to any parameter, but to the whole thing. The idea is, is bool applies to this. Hmm. So it says we've insisted This is a bool. But then, according to F sharp by some other considerations, it also has type A times B. Now, this might sound funny, because I'm not talking about a and b here. Everything seems pretty rigidly fixed. From where does this come? Well, it comes from the fact that F sharp takes one step at a time. And it had just figured out that this top level expression, which on the one hand, has type Boolean, is defined here as a pair of pairs, generally, not pairs of characters and integers, but pairs purely generally have a type of this form. And at this point, when this complaint was made, the system didn't go even deeper, to check what the types of these two guys are. Because had it done this, it would have told us that bool is not equal to char times int, but you know, for the inconsistency to arise, we don't even have to look so deep. The reason is bool is a primitive type and no primitive type is equal to any tuple type in particular, not to any pair type. And that is it, because inconsistency is here. So we've seen a few features or sort of phenomena happening here. So what are they? So, one is this is a strongly typed language, F sharp and in general, most FP languages, you try to have them this way, because this has important software engineering benefits. The Prime one of the system detects early when you're confused. So the idea is to catch the sort of development errors as early as possible, and forced a certain discipline on you. So that your, you know your freedom is constrained. But this is a sort of usual useful type of, of restriction in that. It's like I don't know, the parents taming their children. You're not allowed to harm yourself, yearn for this, there is a certain discipline.

19:50  
But then it is a statically typed language, everything has to be well typed. But this is separated from the idea But you have to do the typing No, most of the checking is done for you. And this happens often so seamlessly for you that you don't even have to say anything about pipes yourself. And that's one typical usage of this facility, that type inference happens. But then sometimes you want to take control or you know, you don't want your parents to decide everything about you. You also want to say what you intended. And that's okay. So and that isn't the idea that you can give type annotations, you can fully Say what you want your programme to be like, for this month, bear. If I'm disciplined, I may want to write properly, what I intend and then it is just a job for the system to agree with me nothing else. That's possible. And this is what you will typically have to do in, in languages like, like C, for example, or, or Java, everything is, is, is typed. And by that they they're mean, or not everything is typed, but most things are typed. But, but what is meant by typing in these systems is you have to write the types here is not like this, the language is statically typed. And type errors are not tolerated. But there is support for type inference. So some discipline is imposed on you. But on the other hand, you sort of get compensated for this. You don't have to, to get all the sweat and toil for it yourself. But But you're helped in this matter. Yeah. Does it make sense? So what I want to emphasise, there is the idea of strong typing every subject, so every expression you write, each sub expression of it has to be well typed, two types have to agree. The idea is during the runtime, you shouldn't discover that your computation now we'll get stuck or basically breaks down because some types don't fit. All of this should be avoided at at, let's say, compile time or, or load time to the interpreter. We are piped In this sense, but we are sort of untyped in the sense that we don't have to give the types of ourselves. And that feature is called type inference. Machine infers the types for your the language infers the types for you. People also say type checking by checking typically means that you've already given some hints. And they should agree with the rest of the inference process. So and in particular, if you insist that something is of more of a more special type than the system would otherwise allow you then then the type is specialised for you. And we saw an example here. So if you just don't give any types, then we get the very liberal type inferred by the system. But I can be more specific. And now this sort of software engineering considerations about whether you want to be very general, very specific, or different, you might be very general, because this just means that your, your programme is very user, very reusable, I can use muck bear with any pipes. So I've written something very powerful in some way. Maybe my pair is not the most interesting, powerful functions, right? But anyway, but then you lose the control of sort of unintended uses by not giving more specific types if you actually only had more specific types in your mind, and maybe the particular trickery you wanted to implement was, was supposed to,

23:54  
was supposed to. Yeah, at some particular purpose, and you really intended your functions to be used in a certain way. Is this clear, static typing, I want to get it across doesn't mean that you have to give your types yourself but they are inferred for you. Or if you've given your own your own annotations, this inference as a component of checking. And then inference is the idea that the system tries to make sense of what you've written in terms of types. But without annotations, it tries to give you the most liberal type possible very often, it's called the principal type. This is the most generic possible type and every other valid typing is an instance substitution instance. So how should this thing work? Some time ago, when I introduced this first order language actually showed you a simple type inference algorithm. But this one was helped by user annotations and broke down without them. So what did we do there? We said, we now want to work in a syntax like this, that whenever you make a function definition, you actually give types to both the parameters and the return value and type inference, then basically, we reduces to checking that all of the little sub expressions that you have lying around everywhere here, they sort of make sense with respect to this discipline. And if something breaks or breaks down, then yeah, then then the system complains. And of course, the main expression itself, the system will tell you what its type is. So here, this is an expression with a local let its value is is is the value of the body expression. And the system will here actually, in this case, tell you that this is an integer. So it is an inference, but with a lot of with a lot of hints given. When these hints are given, and they are in terms of closed types, no type variables, then the types derived also are in terms of clothes types, no type variables, no generousity, or no polymorphism, whatever you call it. But how then does the system figure out the types when you don't give such

26:47  
information?

26:53  
I'd like to propose that we sort of go by small examples, I first show them here in the buffer, and then I try to scribble on a on a pad. Let's let's try to invent an algorithm or let's try to see what needs to be done. So let's do something. So let me define for example, for again, if I just say foo x is x, what should the type be? For? How should the system even start thinking about it? I can tell you what happens. First, it is found out that food is a function. Why? Well, because in this let definition, we see that who is given a parameter. So depending on the number of parameters that the system will figure it out, it is a function with this number of arguments here, one. So most Generally, we could then say that this is perhaps a function of type, you know, a to b, where a and b are type variables. But this is perhaps too general. Why? Because the return value has something to do with a parameter, actually, it's equal three, Aha. But then when the return value and the parameter are equal, then they have to be of the same time. And in this particular case, there is nothing else we can learn from what we've written, this is the only constraint the return type, and the input type of this one place, or unary function that we have here have to be the same. And that is what the system computes. It will tell you this is a function from a way, it could have just as well, I've told you that it's a function from b2b there is no difference, you can always rename these type variables that are unconstrained.

28:56  
If you rename system. That's good. But suppose I did something else. Maybe I say let x y is x. How about now? Well, it's a similar thing. So,

29:22  
for

29:27  
buying the number of parameters here is a binary or a two plays function. So somehow, the type of the function should be something of the form a, an OB at OC where a and b and c are type variables, based on just what the left hand side of this definition looks like. But surely, A and B and C. So A is the type of x y is the type of sorry B is the type of y and sees the return type. They cannot be completely arbitrary. Actually, it looks like the type of ad can be completely arbitrary because why? Because y doesn't occur anywhere else. So perhaps B is completely unconstrained. But our A and C, the type of x and the return type independent? No, they aren't, because what we're returning is actually the first parameter. So the type of the first parameter and the return type, they must be the same thing. And that's what the system says. So here we have a function from A to B to A. Because that's what we did. How about if it returned? Why? Well, that's not so much more complicated. Now the type is a to b to b. But then how about something get more complicated? How about this? So this is a famous example. It has a name, it's not usually called foo. But anyway. So here is a complicated definition, as that is missing on the left. So here's a complicated definition for is clearly a three place function. So it's of the Type A to B, two c, two D, for some possibly unconstrained type variables, ABCD. But maybe, maybe they cannot be independent type variables, maybe we need to say something more specific.

31:24  
And this is figured out by looking at what is happening here. Can you already see some things that are happening here?

31:33  
Well, this is not just using some some variables, but it's also some function applications. So one of the things we can quickly learn is that since y is applied to Zed, the type of y cannot be any time. So the type of y has to be some function type actually, some some function type with one input. Sorry, some some type of a one place function. X is also applied to arguments, x is applied to Zed, and then the result is applied to Y to Zed. So x is really a two plays function. So it also has to have as type of a pretty specific form. And then it looks like it's probably some complicated calculation of dependencies, what is it like? So let's first not do the computation, let's just see what the system says. And the system says something pretty complicated. It indeed says x is not just anything, x has to be a two plus function. So here, the input types are called A and B, and the return type is called C for this x, which is a function. Y, the second argument to foo also has to be a function, but the one place one, but you see already something very specific is happening, like the input type of y has to agree according to F sharp with an input with the first input type of x, the return or output type of y has to agree with the second input type of B of X. What am I saying the the output type of y, which is B had wanted to say, has to agree with the second input type of x. And then there is more happening, that is a third argument to foo. And its type cannot be any old time. But it has to be the same a that we've already seen if you've been a few places here. And then finally, the return type of the function foo has to be C, which by the way, was also the return type of x, which is yet another kind of knowledge, found somewhere here, that last bit is actually easy to see, because who applied to all of its arguments has to be of type C. But surely, then x apply to all of its arguments has to be of the same type, because you know, the left hand side here equals the right hand side. So that's maybe not surprising that you've seen the same C here in both places. But the message of this, this one here is it can be a non straightforward, non straightforward matter for the system to figure out these types. And sometimes you can write nonsense and things do not have good pipes. So for example, if I write for x equals x applied to x, this is maybe a bit questionable already. And we get some sort of a complaint, which I'll have to explain you what it is. But some of the problem is that you're not a proper part of something cannot be as big as the whole. So, so here, x is applied to x. So therefore x is a function type. Say of Type A to B. But if x is a function type, so if x is of a function type A to B, then it wants an argument of Type A. But of course, it's here also given an argument of Type A to B. So this is exactly actually what the complaint here says. So as soon as you assume x is a function type x cannot be its own argument anymore.

35:33  
How does this See? Let me unshare for a moment, then I can see you.

35:42  
Have you written something in the chat? Are you all there? Yes, I have one question to ask. Could you explain a little bit further? The three plays function that you the the complicated one,

36:00  
let me

36:02  
Yes, I actually live the royally and I didn't explain right now, at all. You mean, this one? What happens here? Yes. Yeah, this is, this is not straightforward at all. And this really requires some calculation to arrive there. But I mean, maybe for now, and I will show you this, maybe we should do this after the coffee break, actually, but, but do agree that some things are sort of easier to see. And some are harder, like, the fact that food takes three arguments is an indication that well, the whole thing has to have an arrow here, an arrow here and the yet another arrow here, because it's three arguments, taken one by one, right. And then something is written. So on this level, it's kind of clear what is happening. But these types here, of course, and the fact that you know, the same a occurs in certain places, or maybe the same B occurs in certain places, and the C occurs in certain places. This is a bit mysterious. So I think so far, I only come commented that, you know, x has to be a function as well, because it's applied, why it has to be a function as well, because it's applied. And maybe it's not so illogical that the return type of x and the return type of foo itself agree because, well, on the left, here, we have an application of food, three arguments. And here we have an application of x two arguments, and both should do the same thing. But the rest I haven't explained at all, and it's really, really a bit mysterious. Maybe I'll switch to scribbling. I do some one final example. Let me do yet. Let me do a yet different food, shall we say, full of x and y, you've actually seen this one that a different thing before is x applied to y and y. That also feels a bit crazy, perhaps. So what do we learn here, we learned that foo takes two arguments, not as a pair, but one after another so that the partial application who acts also makes sense, and I can pass it around or just use alone. So there's much we can see who takes two arguments. The right hand side

38:28  
somehow, perhaps indicates to us that x is not the simple argument that the whole thing is a higher order function. So foo is the function taking in functions why? because x is not used in any sort of simple way here, or in harmless way, x is used as a function x is applied x is called. So clearly, then x has to be a function. Moreover, since x is applied to two arguments, one by one, it has to be a two place curried function. But the picture is a bit simpler than here. I mean, this one is really difficult to analyse by heart here is not so hard. So there are certain things we can notice immediately. So x is not applied to any to all things. But but to why twice. This perhaps is an indication that both arguments of x have to be of the same type. Yeah, because y has, well, we're doing type inference while you're playing some fixed time. It's the same type here and here. So x then perhaps has to be a function of the form a arrows a arrows B, where b is the return type, and a is the type of y. And actually, we don't have more constraints. So the type of y is unconstrained. So if we agree the type of y is B, and if we then say, the type of x is a arrows, a arrows B, then we can type the thing, and this is what the system tells us x here, the first argument for the parameter to foo has to be a function of this type. Y has to be what is used twice here. And what comes back is what x delivers. After application. That's also the return type of food. That's perhaps sort of understandable without, you know, making heavy calculations on the back of an envelope, we'll just think. But I suppose many of you must already in this, say, practical exercises or home assignments, stumbled that this point maybe type inference doesn't disturb you so much when everything works well. But then now and then you ask a question, I wanted to do this. But now the system complains, the types don't fit. And maybe sometime it was about mixing, mixing up the say, list element type and list type, or maybe mixing up and option type and, and the type that the option type is over, I mean, there is a difference between int option and just int. And then, then the type insurer of the system complains loudly. But on the other hand, it points to an error that is there in your code anyway. So if if you wouldn't get this early error, while you try to load your code, you would get an error each time you run the code. So that's a good thing. Even if it can be annoying. First, what is maybe not good is that the diagnostics about type inference can be more useful and less useful. And that depends a bit on the type inference strategy. Because type inference can, you know, you can start type inference from different directions. And some directions maybe argue with agree with how you would reason as a human, there can be other strategies that make perfect sense from the algorithmic point of view, but make it more difficult to understand where exactly is the root cause of your error, as opposed to some surface manifestation of sip or symptom of your air.

42:30  
So this is very important that these kind of messages are useful. And actually, I must say, in the standard

42:40  
implementations of F sharp, not too much attention has to has been paid to this, they could be far more informative, and better, better for me. But anyway, is there more questions at this point? Because if not, then I would rather like to take a break now. And then we should do some real type calculations. And I'll show you from from where these kinds of things come.

43:07  
After.

43:14  
You think

43:24  
there are no questions right now I propose we take like a seven minute break seven, until 1240. And then we do a number of type inference exercises. This one is a prominent example. I'll do some more with you. And we don't state the algorithm formally yet. I'll show you next time. But what I want to get across is what is actually happening or what is the principle and why does it have to be this way? And why this is actually only natural when you think about

44:07  
this, okay? Yes. Okay. Then let's let's, let's take a short break. Six minutes, and then then I'll continue after this. Then we don't maybe we spend 2030 minutes on this. Okay. Let us know

50:28  
Okay, so we tried to continue, then I'll take these examples, and we'll see how we go about them. Let me now try to share a different screen.

50:49  
Which one?

51:00  
Can you see an empty screen?

51:04  
Yes,

51:05  
yes. I'm not afraid to write something. So we have these examples of functions, whose type, maybe it was not so obvious. There was a very complicated one, there were the simpler ones. Let me start somewhere in the middle. So for example, we had this

51:32  
for

51:34  
x and y, the X. How did I reason about this? Well, we said the Foo function takes two arguments. And then there is some return type. So we could play this game that we say this one has type A, y then has type B. And the return type of the function should be C. And so this agreement about letters is sort of to actually conclude, at one point that food would be of the Type A to

52:34  
B to

52:38  
C, isn't it? But that's not everything we can learn from here. It's just, it's just, we have sort of recorded for ourselves that foo is a function type. Therefore, its type has to be something of the form a arrow B, arrow, C. Where do we get the rest of the information from? Well, that should somehow be come from the right hand side here.

53:14  
We should somehow exploit the right hand side. Here, there right hand side is very simple and very particular. We've already agreed that the right hand side has type C. But actually, let's look at what the right hand side consists in. It consists of just one use of variable the variable here is the parameter. But look, we had already made an agreement, what the what the value, sorry, what the type of the parameter is. So we had already fixed it ours for ourselves that this was a, but now at the same time, we have to we are seeing that this is C. So we get this equation type equation that says A and C have to be the same type. Is there anything else for us to sort of guarantee that the right hand side here,

54:11  
this guy

54:12  
is a is this well typed? Well, not really, because the right hand side is so simple. It's just one variable. On one hand, for this variable, we have agreed with ourselves what its type is. And on the other hand, for the whole right hand side, we have said it's time to see and there is really nothing else going on at all. Hence, the type of food the most general possible type for for food is actually this one. These actually a Adobe out Oh, a, because C is constrained to be the same thing as a Does this make sense? Maybe this is too simple. And then of course, you can, you can think of little variations here. So for example, if I were, say more constraint, maybe I had said something like, let for x, y, int equals x, then the reasoning is exactly the same, except that I have to take also into account the fact that the second argument of food doesn't just have an arbitrary type B, which is the most general thing that the system would assume otherwise, but it is in so we will have to also take into account that we

55:49  
is in. And if you then write out what comes you know what follows from these two equations, this one here?

56:03  
And

56:06  
sorry, direction, and this one here. Then, we just conclude that who in that case would be of the type? a? arrows in? Sorry?

56:30  
arrows? Yep.

56:41  
Okay, now, let's do something more interesting. But the principle sort of remains the same. So you can see a few things. So we make some basic agreements, about, you know, the whole setting, which is we say, well, to start with, we don't know any better than that there are some argument types and some return type. And then we start collecting equations. And essentially, we sort of solve equations, and we, we try to go to a closed form solution. So in this first case, sorry, this one here.

57:17  
We've,

57:19  
we've taken into account that A is the same as C. But since a and b are unconstrained, we leave them there type variables, right, of course. A equals C is a symmetric equation. So I could have just as well solved it in a different way, and said, the solution now is that for is of type C, arrows, B arrow C, it would just mean that I prefer it somehow C as an Unknown, Unknown name to a But otherwise, it's just the same solution.

57:45  
Okay,

57:48  
let's do a different one. Maybe still, you're still not yet the most complicated one.

57:55  
So we had one that looked like this. It said, Let fool x y, b, x applied to y, applied to y. Just to get started, let's say x has type A,

58:23  
y has type D. and the return type corresponding to the type on the right hand side is C. Who said this, then it's clear that at the end of the day, the type of food will be this, but maybe not for the original type variables, A, B, C, but we have to make these things a bit more precise. So this is kind of the first approximation, but the equations that we collect, when they when we solve them may force us to something more specific. Right. Let's see what else has to be there, we see this x here is actually applied to two arguments y and y to agree this, I agree with this. So therefore, this type A that we gave for x cannot quite be arbitrary. The state type A actually has to be something far more specific. It has to be perhaps of the form the arrows, he arose, f because Why? Well, because x is a two place function. So it takes at least one argument we can agree that this one we call D and it takes another

59:58  
comeback.

1:00:05  
Yes, it takes another argument, which is we can say as type E, and then the return type is F, actually is the return type f four, can we say something better from the very beginning? Well, x is applied to two arguments. But here we say the return type of this application is C. at the same point here we say, the return type of applying axes F. So really, we have already sort of introduced a bit too few too many names here. So one thing is for sure C is actually the same as F.

1:00:54  
Okay,

1:00:57  
maybe I should make a few more here. So yeah, okay. And then D and D cannot quite be arbitrary, either, because x here actually is applied to two very specific arguments, why and why. And we already agreed that the time for y was B, wasn't it. So really, D and D cannot be quite arbitrary.

1:01:25  
But actually, D is B. And he also has to be B. Maybe I could have written this one in a different order, it's the same thing that maybe it looks nicer,

1:01:43  
if has to be the same.

1:01:46  
So I'm sort of reducing newer introduced type variable names to the older ones that they already had. Is this good? So are we constrained in some further ways at all? Or maybe this is it?

1:02:05  
What do we think?

1:02:13  
Well, there doesn't seem to be a lot more happening because the right hand side is one single argument or two plays function to two arguments, or we could say it's your first x is a one place argument, which we applied to y. And then the result is a further on one place function, which we applied to y. But that's, that's just a different way of saying the same thing. So there is not more happening on the right hand side or on the right hand side. We've already taken all of this into account. So maybe we just find, let me just now sort of solve the equation system. So to say, well, these equations are very easy to solve this is just to say, don't use FDA e at all, just everywhere. Instead of f, write C instead of D, right? D is the V right? D.

1:02:58  
This one is a bit more specific here, we have to say, well, a, we can't just use like this, instead of a we have to write the more specific thing isn't.

1:03:10  
That is any. So instead of this age here, of course, I will have to write what it is. So it is D, but these just the arrows, he but he's also just be arrows f but f is just C. So actually, it's just this bit. And that is all. So there is really nothing else to say the type of food is B to B to C, to B to C. Yeah, I find with this. So I mean, I can also most properly write it out. But we already there.

1:03:48  
To B

1:03:49  
to C.

1:03:57  
To see.

1:04:03  
Okay.

1:04:07  
Is this reasonable? Oh? So happy enough?

1:04:17  
Oh, yes.

1:04:18  
When you write these equations, I mean, I like to do it formally and write an algorithm. But for now, I think it's important to get the idea. We just collect. I mean, the only things that really determine anything are whenever you apply a function, say of pipe A to B, then the argument has to be of type A and the result has to be of type B and we just write down these kind of agreement requirements as equations. And these state what are the sort of minimal requirements that I need to put on my types. And since we are after the most general type, we don't try to go more Question than just exactly those things. Okay, now then let's do the really complicated one, which I refuse to explain before. What was it like it was something like let

1:05:14  
fu

1:05:15  
x, y, Zed equals x applied to Zed, and the whole thing applied to y apply to that. It's much more difficult. But the principles aren't so different. Let's fix a few things. So let's say this one is x is of type A, y is of type B. Zed is of type C. And we also say we want the result, we insist that the result is of type D.

1:06:04  
Okay,

1:06:06  
and then the aim of the game, or the name of the game, which everyone in the end of the day should be a to b, to C to. Okay, what do we know? Let me go in small steps, we could actually go in bigger steps, you need to noticing that certain things are variable. But let me sort of go go in little steps. What is the right hand side like here? So let's concentrate on that one. Right hand side is this bit here? Well, it is a play an application of the function x to two arguments, Zed, and y apply to Zed. And the further inside, we also see an application of y to Zed. So there is two functions. At least going on here. Let's, let's state this somehow. So the type of x is a, so therefore, we learn that A is something more than just the primitive type. So it can't just be a type variable. We have to specialise it to some sort of a function space. And then let's give it names, or I can call it it takes two arguments, I can say it's E to F to G.

1:07:41  
And this is just to be methodical, because it is very easy to see that he for example, has to be the same thing as a, because he here sorry, he has to be the same thing as C, because he is really the type of the first argument of x, which is it, and we already agreed that the type of Zed is C, etc. But for the moment, let's say it is like this. And let's write down also,

1:08:10  
something about the other function y is a function here, isn't it? The type of y we said was B and y is the one place function. So I can say it is one from what are the next letters h

1:08:37  
to

1:08:40  
shall we say k.

1:08:44  
And now let's write down what else we know. Ah, is applied very x. The type of x we say is this. X is actually applied to Zed. We already know the type of Zed is C, therefore, he has to be the same as

1:09:18  
C really, isn't it? x is also applied to y apply to Zed. So here we say that this is what we call F. But at the same time we know we've assigned the type h to K to y. So therefore when we apply y to set the return type is k. So therefore, f has to be the same as K.

1:10:05  
And finally, this thing here, which is the type of x, right? When we've applied it to both arguments, the output type should be G. But at the same time, of course, it should be D from here. Yeah. So g should really be the same as D. So I introduced a lot of names. Actually, I could have not introduced them had I sort of looked ahead a bit. But I just wanted to do it very, very systematically. And so we collected lots of information from this one top level application of x two Zed, and why is that, which was this one here? All of this information is in

1:10:56  
here.

1:10:58  
Now let's work in the other application on the other application, which is why apply to set. So we are already saying here that the type of why is this guy.

1:11:21  
Okay, but then what we know why is actually applied to set here.

1:11:34  
The type of Zed is C. But here we talk about h as the first argument to y. So therefore, h is the same as C.

1:11:48  
And then also, what can we say about k? m, maybe you've already said what we needed to say about K. So K is what comes back when I've applied y to something. When I apply white to Zed, I get the second argument to x,

1:12:09  
which I've called F. So F equals k, I've already written down this one. So it looks like we're pretty much done here. We've collected everything

1:12:18  
we could possibly know, let's see if we can then spell out this thing in a bit more detail based on what we just learned. Okay, what is e? A is E to F to G, but he is actually c. and g is actually D. So maybe I just call it C to F to D. What is B, B is h 2k. But he actually has to be the same thing as C. So I always prefer these variable names that I introduced earlier. So I prefer C to H. So I will replace h with C, and k is the same as F. So the whole thing is C.

1:13:30  
And then the next argument is C, and then there is D. So if I write it out in full, I get full is of type C, to F to D, to C, two, f two, C, two. And when you go back to what happened in the F sharp window, F sharp concluded exactly the same type, except that the names were different. It used instead of C ZF. d, it used ABC. But otherwise, it was exactly this. And this was here a complicated inference, as you must agree. But in the end, there was very little information I used, I just only use that the right hand side has two applications, one to two arguments, one to one argument. And I just recorded that, well, the things that I apply, you have to be functions. And then I just made sure that the argument types and return types

1:14:33  
agree.

1:14:37  
And going in the direction of arguments, in the end, they have to agree with the variables that for which I've already declared types and the return types, yeah, this just has to do with with how the functions have been plugged into each other. So and that was it. Does this make sense? It's a, it's difficult to keep track of, obviously, but then it's something that you want to give to the machine. So the, the idea is more, you have to understand the principle, then, if you understand the principle, and if you think hard about it, you can write down an algorithm. And then you don't need to do any of these calculations by heart, obviously. And maybe a higher order function like who is a bit of the extreme of higher orders, typically, you don't combine high higher order stuff together. Yeah, in very intricate ways. Maybe I should, that's almost enough. But maybe I should just show you a few more things you can do. One thing I'd like to emphasise is a type inference avoids runtime errors of the sort that you get some sort of type misfit at one point, like you apply a function to an argument, the function has one expectation about the argument, but the argument has already been evaluated and is of a different type, and then you just can't apply. So these kinds of things are avoided by type inference, because you just refuse to run the programme that doesn't get a good, you know, that doesn't properly obtain a type in type inference. But there are things that type inference never can catch. So it's not the case that any type of runtime error

1:16:32  
would be,

1:16:35  
would be caught by by type inference. So some are kind of things that you don't want to do analyse too deeply, compile time and load time. So for example, if you happen to write division, x over y. And maybe you already found out that x and y are integers, and you're happy that the result is an integer, this is fine. But then perhaps it can turn out during the runtime that y can be zero, then everything is well timed. But you're trying to divide 17 by zero, and that will give you a runtime error anyway. Yeah, this is a type of thing that perhaps, would be nice to catch early. But type inference isn't really very suitable for this. Because that would mean that you have to track very precisely what kind of values everything can take when you do the actual evaluation. Yeah. And okay, if these are locally defined values, then you can sort of pre compute stuff. But maybe x and y are global. So Indian external environment tells you whether you know x is 17, or maybe it's 42 is dead. And it will tell you whether y is now zero or five. So there is no way that you can control the environment, the environment does what it does. Surely you don't want to reject a programme just doing harmless division, because someone might have the bad idea to give you zero as the value of y. So this type of error you won't catch. Another type of error are like meaningless recursions or recursions, that are clearly food type fuel type. So let me give you an example. I should say that this type inference thing that I showed to you perfectly well works in a kind of recursive setting. So if I've defined foo in terms of foo, then in the right hand side, I can already assume foo has the type that I've intended for it, and I can use it in my equations. Maybe I should show examples of this actually, let me do so here is the stupidest possible recursion that you can write. And it's accepted. Sorry, I'm just telling you let fu of x equal huvecs. This makes and then I could use it in somewhere like maybe I want to calculate who have a loan for example. That works, that makes perfect sense pipe wise. And it also has a clear operational behaviour but the operational behaviour is, is about so unfriendly, so when I call foo on Hello, this simplifies to what to calling foo on Hello. So I make a new recursive call. That in turn simplifies to Calling for one Hello again. And again, and again. And again, until I get a Stack Overflow. And of course, the fan of my computer will go at full speed before etc. So there is a clear operational behaviour. And in some sense everything is good with this programme I'll in a sec, I'll derive a type for you, it is perfect. But But you have to take this into account that these are types of errors. That

1:20:32  
type inference will not catch for you. From the point of view of types, everything is good. We can figure out the type. But maybe the programme is not the wisest. So let's do the type thing here. Because of course, we also have made more meaningful versions of the programme.

1:20:50  
So what can we say? Well, I can only assume that x is of type A. And then before x is of type B. So that would be a good reason to presume then that I can assign the pipe A to B to foo.

1:21:22  
And let's see if everything is well. So checking that everything is well means I need to see if I need to specialise my type variables further. Maybe because something is a function of space that I didn't see is that something is a function that I didn't initially think is a function. And we just also have to check that all the types fit. So the place where we need to do this is in the right hand side, which is this part here. So we have to make sure that this application of food to x is good. Let's see if it is good. So food is of type A to B, by what we just agreed what we will want.

1:22:10  
Here is an application of food to x. So then, the type of x has to agree with the input type of food, but the type of x

1:22:21  
is a and that is the input type of food great. And then I need to make sure that what comes back that the return type here, which is the type of the whole right hand side B agrees with the return type of food, but the return type of shoe is B so everything agrees, right, everything is perfect. You can type this thing in class shop, for example.

1:22:50  
And it will tell you who is of type A to B. It's nothing wrong about it. Here's a small variation of this, which is even crazier. But F sharp is still happy. So I could for example, say the following. Let full of x be the same as full applied to full of x.

1:23:25  
Let's check if this one is good. So I say okay, let's try x to be of type A. Let's try food to be of type B. So this is the old game as before, not not for Oh yeah, the food we have taught me, let's let's pretend that the the return type of whiskey. So the right hand side has to be of type B. That's what I wanted to say. Um, okay, if we do so, then the aim is we want to convince ourselves that we can type foo as a to be possibly specialising gay and be a bit. What does our naive algorithm tell us, we'll have to make sure everything is good here in the right hand side. That's now a bit more tricky than before. Because we don't have one function application. We have two function applications. We have the outer one, which is application of foo, foo of x, and we have the inner one, which is an application of foo to x. It doesn't really matter in which order we look at these things. Maybe let's look let's concentrate the outer fool first.

1:24:48  
The outer foo is a function from A to B by what we've said here, so therefore, when I apply it, the whole result Which is this thing here? That'll be of type B. But it is because who is of type A to B. So what comes back is B. Let's also check that the argument is of type A. So we have to insist that this part here is of type A,

1:25:28  
that is more difficult. Because what is this part here, it's actually applied to x listing. And who is a function which is which returns a, b, but now we say the result has to be a, this is only possible if A and B are equal. So from in this programme being this point, where on one hand, something comes out from foo, and the same thing goes into foo, I have to I will conclude that B and they have to be the same thing, because then it basically says the output type and the input type of foo have to agree, right? Let's check that everything else is fine. Still with the inner application of foo? Well, foo is a function from A to B the equals a, but anyway, the input has to be of type A, the input here is x, and about x, we have already agreed with ourselves that it is of type A, so everything is good, except that they have to make this one definition and are not sorry, definition, one equation. So we have to insist that B is a only then is for equals A to B. Okay? That just means this PSA. So really, the type of food is that way. And that is the final conclusion from the angle. And if you think about it, it makes sense. All it says is with a wave, you know, with plump this is this is some sort of plumping story with pipes. Yeah, we've put together some Yeah, we've done some clumping, we put some glue between things, everything agrees and fits. And we're not checking that operationally, we are basically going in an infinite recursion, if we actually ever tried to call foo on any anything particular.

1:27:35  
So, here, you saw lots of cases where the type inference with the equation collection related to

1:27:52  
making just sure that the argument types of functions, whether the input types of functions, agree with the actual arguments, and then also what returns for the function returns agrees with whatever the function call with a context where the function call is used. A bit more, of course, happens in connection to other language constructs. And the main one, and this is perhaps where I'd like to stop them is if the nails we used to announce is critical. So it's in general something of the form if I don't know he, then e prime l C double prime, everything is an expression when you type such a thing, what is happening

1:28:50  
double prime

1:28:52  
when the type checks such a thing, when you when you're when you infer types for such a thing, then there are certain requirements First of all, if only makes sense, if this expression here is bool. So, in general, when you do type inference, ie some complicated expression, but one of the equational constraints you get is that whatever way he is constructed, maybe some function call then the function call would have to agree with with with what he actually has to be namely Boolean and you get an extra equation from there. But then there are also the branches about the branches in general. We do not have any requirements, they can be of arbitrary type, but there is the requirement that they are of equal types. So these two will have to be of the same type. And then that is actually the type of the whole if then else isn't it and then that gives you Are there clues of further clues on how to type things? And maybe I should only do the simplest little example here as well to sort of convince you of this. So let's just make something up.

1:30:21  
Shall I say, let? What is the function called is usually called foo here. Let's have some arguments, maybe they are excellent. Why not?

1:30:35  
Let them the time the maybe even said that then the Type B, if something. I could say, x applied to y, then why else? Maybe this is not the most complicated one. But that's already quite interesting. Let's have this four of x y Zed is defined as if x applied to y

1:31:20  
poles. So if x applied to y is true, then what we return is y. Else, what we return is set of how to infer the most general possible type for it.

1:31:35  
That makes sure that nothing is that we never ever get any type, misfits. And also, whichever way I happen to go in the evaluation of if, depending on whether the condition turns out to be true or false, I still do get the value of the same definite type. It's as before, so x has to be of some type A, B has to be of some type B, that has to be of some type C. And then to start with, we don't really say anything else about or anything very specific about the return type, we just say this is some sort of D, and then we see if we can say anything more concrete. info is of this type A to B to

1:32:30  
C to

1:32:31  
D, isn't it?

1:32:38  
Okay, now the game is as before, so we have to analyse the right hand side and see what actually happens here. Let's see all the constraints that are imposed on us here. Well, we see one function application x is applied to y. This actually says that x is not of an arbitrary type A, but this type A has to be a function type, isn't it? So a actually has to be something of the form D to not be the role of us E to F. Because that's the type of Okay, let's see, what what kind of conditions do we have on this application of x to y. y, then is the argument, the argument type better agree with the input type of the function, the input type of the function is E, but the argument y itself has type B, so he has to be the same as B. And actually, f cannot be quite anything, either. F is what comes out when I apply X to something. So here apply x to y. And the result is F, but it can't be any f because look at what the context of x applied to y is. This is actually the guards of the if. So it has to be a Boolean. So F has to be born. very specifically. What else can we say? Now let's look at the rest of the if we've already looked at the application in here, and the application actually formed the guard, we looked at the guard, then then looks let's look at the rest of the, with the rest of these as we discussed before, what we have to make sure is that that two branches agreed by the type. So So here the branches are actually very simple. They're just variable used is y and Zed. So therefore y and Zed have to be the same type. But we had given them different types B and C. So that gives us actually that C must be B Or you may want to say the other way around, but that's the same thing that must hold. And finally, the type of the whole if then else also has to agree with the types of the branches, which we said were c alias B to D also has to be equal to both CMP.

1:35:32  
Okay? And then that is it, there is nothing, no no more information to collect, let's then write out what we have. So this age here is really eatwith is really bu is really b, f is bool. So this is beatable.

1:35:56  
What is b? Do we have any constraints about B? Well, yes, we have the C has to be B, and D has to be C. But these are sort of symmetric equational constraints just between two variables, let's say we prefer the variable name B, we keep B, then we only need to say C is the same as B. And similarly, we also have to say D is the same as B. And that is all we say. And the final summarise what I've learned all together is who has the type v to bool. to the to the to B, where B itself is unconstrained. It's just a type variable. Is this okay?

1:36:56  
I hope so.

1:37:00  
Let me see you. Do you think this is good? I can't hear you now anymore. No, I think it's okay. Um,

1:37:25  
yeah, I think it's just needs a little bit of time to think. And it's always thinking, as always, I tried to be sort of very slow and informal today, you might find that this was perhaps too slow. But the thing is, if you want if you want to put it down as an algorithm, this, there is lots of things to say. But I think the important thing is that you that you see what is going on, you should realise that the exact the same thing has happened when data types are around so so for example, pairs, or even things like lists or options. So, when you see for example, that the function list head is applied somewhere, you have to take into account that you know, the argument is a list or something, maybe list over code a and then the result must be of type code day. Yeah. Or maybe when you want to type cons, you have to take into account the actual type of cons that if you put together two things with cons, the first one has to be the element type, the second one has to be of the list type and the result is of the list type and you can't mix these two things. So for example, cons is different from a pen by type and the moment that you confuse you know, you just write cons where you should write the append, like you write double colon, where you should write the ampersand sign, the system will show that you that it actually has every right to do so, even if you feel this is a bit of an insult. This is just what what type checking and inference is for is I hope this is okay. If you have questions about this, you should ask now, you can also ask on Piazza these kinds of issues are everywhere. When you will play with your problems or assignments, practical session problems or assignments. But then on the other hand, the principle is general you have it in. In most functional languages. You have polymorphic or generic types in in many imperative languages like like Java or c++ but But often the mechanisms are slightly different than maybe you're required to put in more type annotations of your own. So languages of the ML family like F sharp, and Haskell, they go in this direction, which say, we'll give you the full freedom, but we'll check on you if you want to cooperate that. But that is some of the language design idea here. type inference is something that can be done by the system. So let it do it as a form of little AI, if you wish, I mean, there is some wisdom in the system. But you can also take control by giving fully your own limitations to show what your intent was.

1:40:53  
Okay?

1:40:56  
If there is no more questions than I may be leaving here, I'll try to copy these slides. Also to converse, five or six pages that we wrote here, and that will then be it for today. Next time, I'll continue with this, but then then we'll try to try to talk about the algorithm. Okay, so then, thank you today and I will stop here.

Transcribed by https://otter.ai
2:34  
Hello

2:36  
could they

2:38  
complain? Can you hear me?

2:41  
Oh, yes. Always very good. Okay, then we can get started here.

2:51  
My setup is today a bit different I hope that connection holds and we can work.

3:05  
So what did we talk about last time introduced the difficult topic which was explaining

3:14  
the mystery behind type inference in higher order languages, F sharp in particular. And actually their little functional language we are writing on our own as well. And I did this by going slowly and informally through through a few examples and try to explain why these like this that when you're right

3:43  
definitions like maybe let

3:49  
x equal x.

3:52  
Why is it then that we get polymorphic types? Now I realise I better share my screen to start talking about this.

4:07  
Yes, can you see my screen you must be able to. So we're playing with examples like this, I said when you're writing F sharp a function definition like full of x equals x, then some work happens. And F sharp figures out that this is a function of great generality, it actually works on any type a

4:30  
as an argument type and then the corresponding return type is also a and then we have more complicated ones where I said let phobia to place function takes two arguments,

4:42  
X and Y but just returns x just as a start.

4:47  
And then I explained look this also has a very general type.

4:52  
The function works for any type A and B for x and y.

4:59  
It doesn't need

5:00  
They'll be integers, Boolean floating point numbers, anything. Specifically,

5:06  
what happens is two arguments come in, we don't need to care about their types because nothing really is applied to the, to the arguments, the only thing we do is we throw away one of the arguments and return.

5:21  
The other actually here, the first. And this is the general type A to B to A.

5:29  
Here, A and B are type variables, they signify the fact that x and y can be arbitrary here.

5:36  
But then once I fixed that the type of x is a, what comes back cannot be an arbitrary type as to be of type the same type A.

5:45  
And then there were a few more examples, let me maybe show one of them that they have.

5:51  
And then we go on them. So I had one that looked like this

5:57  
is a far more complicated one. And it's a bit more difficult to understand what is happening when you give it to,

6:06  
to F sharp, for example, the same thing happens in our language, then mysteriously,

6:13  
but I explained part of the mystery, what happens is, of course, type inference, or we'll find out that this is a three place function, it takes three arguments, this, this Papa, this one by one, then return something. But then the first argument is no longer arbitrary, or like somewhat arbitrary, but at least it has to be a function just to be a two place function between arbitrary types. Once you've decided about these types,

6:44  
the second argument is also a function.

6:48  
And here are the types aren't arbitrary anymore, the the first argument type has to be the argument type has to agree with the type of the first argument of this guy, the return type has to agree with the second argument type of this guy. Finally, the type of the third argument also has to be one of those.

7:08  
And the return type of whole thing for has to be whatever x returns. And this was sort of clear, we're looking at it even on the surface, because we say full of these things. Because x of these things. So clearly, after I've applied for two, three arguments, I should get back the same thing as applying X to two different arguments. And this is exactly the same here. And here.

7:36  
Okay.

7:38  
And I said, this type inference goes by going through the programme, and collecting equational constraints saying, Well, my types can be maybe, you know, relatively arbitrary. But if I made a decision about this type here, it's this about that type versus that, then maybe these two have to agree and certain types have to be the same. So here, for example,

8:04  
this C has to be the same as as what I get here.

8:09  
And then you collect these equations, in the end of the day, you have a whole lot of equation, then you just solve them. Not everything will become fully determined. If it were, then your programme would be monomorphic. It just works on some rigid, fixed types. But here, there is a bit more generally, the many things can be different. But everything depends on my choice of a and b, and c, as soon as I fixed A and B, and C, everything is determined. So for example, if I apply for here, now to

8:42  
two arguments of specific type, maybe I want to apply it to the

8:49  
function of checking the quality of some things. Let me write on

9:00  
W,

9:01  
maybe I want to compare

9:04  
the

9:07  
W times three.

9:10  
This fixes things quite a bit, right. I've already given that my first argument to four is a two base function.

9:21  
I haven't explicitly given any type annotations, but I've said what I want to return is V less than w times three

9:29  
times three indicates w also has to be an integer, otherwise, I can't two times three. And then I can only compare integers to integers, so v also must be an integer. And the result of the comparison must be Boolean. So as soon as I've made this sort of commitment, my type is far more specific.

9:51  
So we can see that a was fixed to int B was fixed to bool. Sorry, int, C was fixed to bool. I've already applied the function

10:00  
For one argument, now, what what is returned is the function that takes in Y and Zed and gives me

10:08  
an element of C.

10:10  
But the type of y has already become more precise. Here, since a is inconvenient, of course, it has to be this is in. So here's my third argument needs to be. And what comes back to the end of the day is born. This is informally how it went. And then I promised, today I would show how to actually implement this. This involves a lot of detail. And it's not my plan to sort of get you through all of the tiniest bits of the detail. But maybe some of the most central concepts are interesting and important here.

10:52  
The the file I've got open here is called higher fund infer, to higher fund

11:00  
type inference for high fund. And it's a complete type inference programme, everything you need is here, other than the language itself, which is contained in this other final higher form that you need to load at the same time, and then open because we need to bring the names to scope.

11:21  
But it's really complete. And it's, it's a couple of 100 lines.

11:27  
So what is going on here, we work with our expressions language, right, which was this higher fun.

11:36  
Let me remember, or recall

11:42  
here what the syntax was. So it's a language where we can write these kinds of things. So we can write arithmetic and Boolean expressions over variables, which can be locally defined, we can also specifically locally defined functions to something of this form.

12:03  
And we can apply functions, but functions are first class, so we don't even have to apply them, we can simply pass them out. A function unapplied is already a valid expression, as well.

12:18  
That's the language.

12:21  
And now we want to infer types of this sort polymorphic types.

12:29  
So let's fix our language of types. What kind of types do we allow, that type will be

12:36  
sort of somewhat familiarly to us?

12:41  
One of these things, either an integer, yeah, of course, I think can be an integer. An expression can also be in the form of a Boolean of the Boolean type. And then we've got function types, they're written fun, parentheses, some type some other type, but they really stand for function types.

13:00  
So pairs t t prime, where t is

13:05  
the argument type t prime,

13:08  
excuse me,

13:11  
is the return type.

13:13  
But we need a bit more of course, we need these type variables because sometimes nothing determines anything too much. And we can

13:23  
in the final, sorry, inferred type say

13:28  
show something that involves type variables.

13:31  
Now a type variable you would think is a simple thing, it should be maybe just some sort of a string identifier maybe we want to prefix this prefix it with a quote sign, so it's more like F sharp,

13:43  
but actually, implementation wise

13:50  
it will play off the payoff to be a bit clever.

13:57  
So we could say that the type variable is basically just an identifier, which

14:04  
we just state as a string,

14:08  
but we have these equations that we collect and actually it makes sense to call to solve these equations as we go because

14:19  
if you remember from the last time a typical equation I will have will be something of the form

14:29  
say I learned at some point that

14:33  
the type variable a is nothing else then it has to be a function of time.

14:41  
And

14:43  
the these equations are

14:46  
most often of the form a type variable equals some type expression.

14:52  
And when you solve this equation, it just means you say, Okay, I don't want to see this type variable a anywhere anymore. I just did

15:00  
Place it with the arrow see throughout, this kind of substitution goes on all the time. So it actually makes sense as we collect equations, solve them in the same go. So we can do it. In a functional language, we do not normally have mutability, but if we use reference types, we could play the game. But initially, a type variable really is nothing but the name. But when you've learned more about it, in the same place where you're storing your type variable, you can actually say what's equal what is equal to, so you can put some real type there, which of course, in turn can depend on other type variables.

15:42  
Plus, for technical reasons, it makes sense for us to keep track of

15:50  
how deep in the expression a variable was

15:56  
defined. So we talk about levels of binding variables. And this just corresponds to nesting structure or to the depth of a variable in the nesting structure.

16:10  
So if you if you have three nested loops, and, you

16:17  
know, you define the variable in the inner most of those, so that corresponds to level three or two, depending on how you count.

16:27  
Okay, so actually, therefore, we will say, type variables are a thing, but they're far more complicated. The type to give a type variable means to give a type bar. And type var is a type synonym for a reference

16:44  
to a pair. The second guy here is the level, which is an integer. That's just a technical thing. And the first one is,

16:57  
is the kind that the type variable is of, there are two kinds of type variables, there are type variables that I yet completely uninstalled shape. So it's just a string, it's just a name, which we call no link.

17:12  
So no link applied to x, for example, would be a variable.

17:17  
But it could be, it could be something else, it could be that initially, I had a pointer to a no link. But then I learned, for example, that this a was B arrow C, and then I replace it to link to so we could imagine that, you know, initially,

17:37  
I represent my variable as a no link,

17:41  
maybe something like this.

17:44  
And it's not literally that it's a reference to that.

17:49  
And then I actually update the reference as I learn more and I say no, no, no, it's not that one, it's actually fun.

17:59  
And then fever

18:06  
No, Link

18:10  
B No, the link

18:14  
to see something like this.

18:19  
So initially, when you when you sort of establish the variable it is a reference to this thing.

18:25  
And as you as you get wiser you sort of you read point, you make your reference point to to this thing that I'm missing one was not perfect at all.

18:41  
So it's a fun between two different t bars, which both are so far on instantiate Is that okay?

18:51  
Otherwise, I mean apart

18:55  
from this trouble,

18:57  
the rest concerning

19:04  
type variable or three types is simple, we just have simple types like in born into board etc. But if the ball is represented as fun

19:17  
and I should say I was already

19:21  
I was already imprecise here because T var

19:25  
doesn't take such a thing directly as an argument, but p var in turn takes a pointer. So what we really have, what we have is like p here maybe

19:38  
p bar P P or Q, where p

19:45  
points to

19:48  
and Q points to

19:52  
this thing, that would be a better way of saying what is happening

20:00  
Okay, what else do we need,

20:04  
I can very soon go to the algorithm itself, and then work backwards in the file explaining every auxiliary function we need. But I need to introduce one more thing.

20:17  
So

20:21  
we will have typed variables around in two roles. One is like unknowns from the point of view of these equations that we're solving. Like, I could say there is this a for which I don't yet know a value, I want to learn about it. And it will become more precise. These are like unknowns for for from the point of view of equation solving.

20:43  
But then, at one point, I have solved the equation. And I found out that foo has a type of this generality. And here, I want to say I don't want to make a and b and see more precise anymore, at least for saying what the type of foo is, I want to record the fact that all of a and b and c I can choose freely. And this is done in this notion of a type scheme.

21:10  
The type scheme

21:13  
is morally just a pair of a type, maybe like this one here.

21:20  
And an explicit list of the variables, which I want to consider it

21:28  
generic in or polymorphic. In.

21:33  
So informally, he was writing it or maybe in concrete syntax, you would write something like this, you've got this type T.

21:40  
And

21:45  
we want to say, for example, that some function has this type T for all of these type variables, maybe I should save is of type variables

21:55  
that we use within our patient further down.

21:58  
So we just extract from a type and the list of variables that we say the type is, is already generic or polymorphic. In

22:14  
Is this good?

22:17  
No, I'm afraid I have to show you the real thing.

22:20  
There is a horrible, awful technical complication.

22:24  
But the big scheme of things is not so complicated. So let's look at it first. And then let's work backwards slowly.

22:35  
So our aim here is to basically infer the type.

22:42  
So one of these things integer Boolean function type, or a type variable

22:49  
for an expression.

22:55  
So infer takes this expression argument and it's supposed to return a type it takes two more arguments and they are kind of auxiliary they work like accumulators. The first one is

23:09  
is kind of a helper think level stands for level of course, and it just indicates

23:17  
our nesting depth

23:20  
in the top level expression, and this is to keep track of when we see letter letter definitions which level we are and to take it into account. generalisation specialisation business.

23:37  
The other

23:41  
important ingredient as often in these things is an environment, which here is a list

23:49  
of variable name, no programme variables, no type variables, variable name and type scheme pairs. So

24:00  
whatever I am,

24:02  
in the global expression with my type inference, I'm looking at the particular sub expression, I already know

24:10  
what are my sub I'm supposed to know the types to some precision, all

24:20  
of the variables in scope.

24:23  
And I'll try to make it clear they they will I mean by to some precision. So, so to to every variable that is supposed to define it to be defined.

24:36  
Where I am in my expression that is supposed to be in scope, I expect that this environment and knows its type, actually the type scheme because I could have polymorphic things in my context like I could have defined food locally, and it has this polymorphic type, which means that wherever I now want to apply my food, I can use all

25:00  
All sorts of possibilities that patients have for maybe with intent and bool, but maybe with completely different types. So these are in the environment, and I hope to be able to look up types there.

25:16  
Right.

25:18  
Okay. So this is important to keep in mind, we want to infer a type for an expression E, that is on level level, which is an integer. And in an environment where I already know, the type schemes for my variables in scope, and the type scheme, remember was a type plus the knowledge in which variables we should understand this type is generic, there may be other variables

25:49  
which just don't know yet and which may need to be

25:54  
about which I may need to acquire more knowledge.

25:59  
Okay, this of course, as you could expect goes by looking at all the different possible expression forms. And for more complicated expression forms, you would use recursion and you go deeper and deeper into the expression. I hope the problem simplifies. Let's look at the simple cases. First, as always, the simple cases are the ones that have to do with with arithmetic and audience.

26:30  
So, clearly, when I see a numeral I just say this is typing.

26:46  
When I see plus,

26:48  
and two things, now we're in a language where we don't have floating point numbers, we just have only integers and Boolean, when I say plus, what I need to do is I infer a one, I infer e two

27:01  
fives for both with their current.

27:05  
This is buggy with a current level

27:10  
and the current environment.

27:14  
Now you'd expect that these should come out this in. But that's not necessarily the case in a polymorphic language. Maybe.

27:24  
Maybe one, for example,

27:30  
is a variable whose type is entirely unconstrained.

27:35  
Or maybe it is a variable whose type is actually Boolean. So what I need to do is what is called unifying, we need to unify g one. And in so that's a bit like trying to solve

27:53  
the equation in equals T one.

27:57  
Yeah. So if T one is also in fingertip solved, fine, no problem.

28:06  
If it is cool, then you say console, so the whole thing will just raise an exception here. But if it's something of the form in equals

28:18  
maybe typed variable A, then you can say Ah, okay, so, a, a previous previously T one was a, which was just a type variable and an unconstrained one. So like a nollie.

28:32  
But now I learned it has to be equal to int. And that's the point when I say, you sort of solve the equation on the go, you say ah, from now on, I know that actually a has to be taken into account throughout everywhere.

28:51  
So that is what is happening here. Then also, of course, you infer the type for the second expression, and then

29:00  
let's call it T two, we must also be able to unify infant T two, and it could very well be that T two, maybe some other type variable b. And then we learn that D also equals a.

29:13  
So,

29:16  
as you work on this plus sub expression of the top level expression, you may get to know new knowledge about type variables that you have around.

29:28  
But you may also get inconsistent equations to solve like in equals some function space or in p equals all

29:35  
these ones just mean that the whole thing phase the expression is not well typed.

29:44  
Now any other medical operation is of course, similar. Negative on have a have a number is also similar.

29:54  
So you just infer the type of your expression your hope is an entity

30:00  
If it is, then you return the integer. So I should tell you, these guys here have returned type unit, as you'll see later, I'll show you the code for unify.

30:14  
So they have, that they don't return anything.

30:21  
But this doesn't mean that they don't do anything. So this is like, was in the final part of my Crash Course, crash course in F sharp

30:31  
commands are things or functions that return

30:36  
type unit.

30:39  
They don't return anything interesting, because in the unit, there is exactly one element named be empty parentheses empty tuple. But they have side effects. And here the side effect is that the pointers that have that I have lying around, these do get updated. Yeah, they they know point for something else.

31:02  
My equations have become more and more solved, or

31:07  
Yeah, more and more constraints have been imposed on my type variables. So the type variables get more and more specialised.

31:16  
Okay. And something very similar happens to say, the Boolean part comparisons and also if then else isn't as interesting. So let's consider that.

31:27  
So it is if then else, here's the guard, here's the two branches.

31:36  
What do we need to do?

31:39  
Well, you can do things in different order you it doesn't really matter. One very important thing is that must succeed is you, you have to infer the type of the guard, of course, and this must be unified with board.

31:56  
So if this comes out as a type variable, this type variable Henceforth, you know, is specialised to bool.

32:04  
Or you've learned that it has to be born.

32:08  
And if something else comes out here, this is just wrong.

32:13  
Then we also infer the types of the two branches can names for these, then we unify them.

32:22  
And now interesting things can happen, because of course, you can get various things. So for example, you can very well have that T one is maybe a times m and T two maybe is ball times v.

32:42  
Why not?

32:44  
I mean, it can very well be that the both branches of your if then else return a pair.

32:50  
About one pair, you do get to know

32:54  
that the second component is in the first can be anything, maybe about the second, you do get to know that

33:10  
the first component is bool. And the second is E. But it's important for SNL so that the two branches get exactly the same type. And once you do get such

33:23  
an unification problem, the only solution to it is really that a henceforth will be bool and B will be in because there is no other way to satisfy the whole equation, isn't it. And this is actually what this guy will do.

33:39  
And then once we are done, we just return T one, which by that stage

33:45  
is actually a type that is equal to T two, if we didn't raise an exception before.

33:53  
Okay.

33:59  
Now, let me also show you that the top level what happens in the end, we are really interested in inferring the type for the top level expression, we say the binding level on the top level is zero.

34:16  
And we see the environment on the top level is zero, then we need to do a few more things. So of course, I want to see that type nicely printed as a string. So for that type of this function show type here. But more importantly, before I even get going,

34:33  
it's wise to start the little counter. Because you see in this process, we need to generate type variable names like here we have ABC and if more were needed, I would generate the name D.

34:47  
Then all the way up until Zed then I run out of characters then I maybe start using to letter

34:55  
identify fires, etc.

34:58  
So what we're here to do

35:04  
We

35:06  
we set this counter to zero and this is also fine somewhere.

35:13  
Okay.

35:15  
Now

35:17  
let me tell you a few more things before we take the coffee break.

35:23  
Maybe even before we go forward, I haven't explained you var and let them call and let fun at all, which are the complicated things. Let me tell you about unification. What is this?

35:51  
here's the here's the function. Of course, he's not self contained, it depends on further functions that are further above here. But let me start the explanation from here.

36:03  
The purpose of unification is to solve these equations, saying one type equals another completely general not the variable equals a type, but two type expressions are equal like we saw in the cases of the branches of if

36:21  
How should then that go to types are given T one T two

36:26  
and nothing of interest should come back. But the point is, something happens while while we provide the computer's user information, how is this done?

36:42  
Well, we have to look at cases what a T one and T two like

36:47  
this goes as follows.

36:49  
For the moment, you can ignore this But later I have to explain this. We normalise T one and T two. So they may change a little bit. And that again has to do with variables which are the most complicated part.

37:02  
But for the moment, just think p one prime p two prime are exactly the given p one and P two,

37:09  
then we just need to look at cases, which are some good cases. Some good cases are if both are in then they are unified but they are the same type. The unification means make two pipes the same try to make them the same.

37:24  
All and all other teams. So in this case, we returned with success

37:33  
to things of the form fund something something and funds something else something else they are good.

37:41  
If

37:44  
So this here is the function type t 112 t One, two, this one here is the function type T 212, T two, two, when our two function types to say, Well, if both the argument types are the same. And the return types are the same, isn't it?

38:01  
So easy. So therefore I just need to unify the argument types, and the return types and there is nothing else to do.

38:10  
So here I wrote this out, it also appeared before so what is what a semicolon. semicolon is something that you use when you want to put things in a sequence.

38:21  
But it's

38:23  
and it's typical for commands, but it's really literally shorthand for

38:30  
evaluating F.

38:33  
This return is something which we can ignore, or we can pattern match it against the empty tuple. Because that's the only thing that can come back. And then Geez What we return afterwards, so that the whole point is just to do fng in a row. And we don't care about what f returns.

38:51  
So here, in most cases, g also doesn't return anything of interest.

38:57  
But anyway to sequence in construct.

39:00  
So these are some good cases.

39:07  
When we need to say that two variables are the same, then we should just remember that these two variables are the same. And here is some efficient way of doing it. And they have to be more precise about it and explain what it means. But basically, it's like, you know, you get to know that variables a and b need to be the same and you record the knowledge.

39:28  
Here it's done.

39:30  
Specifically like this. So remember a variable is given by a variable kind which is there's no link or link to and the level.

39:42  
Yeah, so we are first extracted

39:46  
interested in extracting the levels of the two things. So we dereference the two pointers we look at the levels

39:57  
when the two variables are literally

40:00  
The same by the,

40:02  
then we just say they were unified well, but otherwise, a good principle is to say that variables that come from higher up

40:13  
in the expression, so they have a smaller level number, they sort of have priority. So if the level of TV one type of level one is smaller than the level of TV two, then we should say that

40:29  
we

40:31  
link

40:35  
TV One,

40:40  
two, T two, but I have to explain what this means. But this is a way to make two variables equals and in the other case, sort of you prefer the other one. So if,

40:51  
if T two has a lower level, then then we basically remember it the other way around. So,

41:01  
you could imagine that, for example, if a had a smaller level than B,

41:07  
which just means that everywhere instead of B, I will in the future read a So, I've solved a to b, I've solved B to be equal to A.

41:18  
Okay,

41:21  
then what else is there?

41:23  
Uh huh.

41:25  
Then,

41:28  
if one side is the variable, but the other is something else, like Boolean or so, that also basically amounts to just remembering the solution. So, so.

41:39  
So, if, for example, I get to know that the variable a has to be unified with bool, then we link a to board and then later explain how this is precisely.

41:51  
If on the other hand, it's not the case that the first one is not the variable, but the second one is, then we link the second guy to whatever the first guy is. So here, we link t TV to the variable type variable to two t one.

42:07  
And this here corresponds to all the other cases, which are the bad cases like when I tried to,

42:14  
for which no pattern is given in this part. So for example, in and bowl doesn't occur anywhere here. So that should be a failure, or Buland in or funding something and ball or instant fund something. These are all on unify with cases, like an integer can never be the same as a function. So therefore, we say no, an integer is not a Boolean, etc.

42:42  
That's a unification.

42:48  
This here is just some simple gadget for us to generate the error messages, it's really not important.

43:00  
I should then explain link bar

43:07  
to type. So link bar to type is used

43:17  
in these places, it is important to know that when you've normalised

43:29  
Actually, it's not important for them to have Alright.

43:32  
Let's talk about link words.

43:35  
So link words the type with a mysterious thing that was that was used here. So what does it really do?

43:47  
Well, it has to do what the name says. So for example, I must be able to somehow record that from now on the variable a

44:00  
Boolean, for example.

44:04  
So, previously, I thought

44:07  
I could work with a completely unconstrained type a type variable a but now we've found out that no no, this type

44:16  
actually has to be Boolean. So wherever I previously said a I now have to think Boolean.

44:22  
Remember this was about

44:24  
you know first having recorded that we have a pointer to no link a

44:32  
and now this must get replaced to something that says link to

44:39  
some pointer where

44:43  
P points

44:51  
but it can be a more complicated thing.

44:54  
Okay, so how is this done?

44:59  
30

45:00  
Some technology here.

45:03  
So on the level of types, of course, nothing complicated happens. So one of the things I have to be given is a type variable.

45:12  
So like here, this TV one, which was an argument of T var.

45:18  
And remember, these type variables are these pointers to pairs of a type variable coins, which can be either no link or link to,

45:30  
and then a level. So this is one of the things we're given. The other one is, is, is any type, what will come back is really nothing of interest. It's the empty tuple. But the question is, do we even succeed? And what are the side effects of, of

45:52  
evaluating a function like this, and given an argument?

45:56  
So here, what happens is the following.

46:00  
Because of normalisation, we only ever

46:06  
actually have the situation where that when we did reference TV, then what comes back is no link something so it can't be a link to, to this is kind of a new variant in this programme. But first of all, what do we do we extract a level that's good to remember, then we find out which are all of the type variables in the type t,

46:32  
then we check

46:38  
if the given type variable is not perhaps among these free type variables, if it is, it is a big problem, I'll explain why in a sec. And in this case, we say so this occurs, check makes sense that the TV is not among PBS,

46:59  
then

47:01  
essentially, what we do is

47:04  
we adapt the level so t var currently has level LBL.

47:12  
But

47:15  
these levels in these variables in TPS can be different.

47:21  
And then we prune them accordingly.

47:24  
This is against some auxiliary function. And then finally, what we do is, we change the kind of this guy dTT tivos. tv was what TV was a reference to a pair

47:38  
of type variable kind and the level the level we don't change, but we we destructively update the coin to be linked to so the thing was previously unknown link.

47:50  
And now it's a link to some type.

47:55  
That is what is happening now I have to, unfortunately, explain to more things that curse check.

48:08  
A curse check is a simple programme, but the question is more likely, why do we do this thing? So we are given a type variable and the list of type variables.

48:22  
And we will return nothing of interest, but we may raise an exception. What do we do? We just check if TV is in the list tedious using the library function list contains.

48:35  
And if it's there, then we fail. To circularity, we say otherwise, we're happy. So why is this done? The problem is I may get unification problems like maybe a equals in arrow

48:53  
a

48:55  
it may be that

48:58  
I'm trying to make a equal to inter way.

49:03  
But of course, that shouldn't be possible because if a equals intero A then it also equals int arrow

49:14  
arrow a just by substituting what a has to be into this expression, then it also applies the same thing, but yet more unfolding, then you see that if you for real or to solve this thing,

49:33  
you get

49:35  
an infinite type expression right because this can grow forever, when when you keep unfolding. So this is the kind of situation that we try to capture. if if if this kind of thing occurs,

49:47  
then we say this is not good. Actually, maybe this is best illustrated here. I can create this expression like this.

49:56  
We can say

50:07  
Maybe simply something like let x equals x applied to zero.

50:15  
which must be nonsense.

50:18  
Like this lead track, I want to say,

50:21  
Okay, he's not allowed

50:29  
to be like this.

50:32  
And,

50:34  
and we get the situation where I need

50:40  
to unify A and B or Jose.

50:44  
And of course, it's impossible because if I were to substitute dr Jose into eighth year, and you'll get the similar kind of repetition, so that's not okay.

50:55  
Okay, explain the curse check and know there's the final thing to to explain for now,

51:02  
which is pruned level.

51:07  
This is harder to explain than occurs check on a conceptual level, cause this level business is tricky, it has to do with

51:16  
specialisation and generalisation of type variables and where it is allowed and where not.

51:22  
But let me try to do something informally.

51:32  
The idea then, is the following.

51:37  
I want

51:40  
to do this linking of of a variable to a type so maybe,

51:45  
maybe maybe, because I'm solving this equation saying A equals

51:51  
B arrow See,

51:55  
I had a completely unconstrained type variable before, but now I've learned from somewhere that this type actually has to be a function type. So, therefore, I have to say more specifically that it is

52:08  
something like this.

52:13  
Now, this a has a fixed level, yeah, it corresponds to a variable defined on some nesting level in my top level programme.

52:22  
The PS B and C can have different levels.

52:27  
And if it is the case, then I should manipulate the level of their types and this is done with this pro level. So, we take the level of a

52:38  
DVS are the free variables in this type expression here currently B and C. And then I apply this function of pro level pro level takes the given level called max level here and it takes a bunch of pipe variables

52:53  
and it basically goes through these type variables this list

53:00  
and it reduces the the level of each of those How does it do it takes a type variable, which is a pointer, it looks up with level by dereferencing and then projecting to the right and then just adjusted. So, this interactively changes the level to the minimum of what it was so far. And what is actually maximally allowed. So it may in general be lowered

53:29  
to bring it sort of in sync with the level of

53:35  
of the type variably. Okay, why this is important, is surely not clear at this stage. But it has to do with the cases that we didn't cover yet, but we still have to tell you a bit after the break, which are then the important cases of the type inference right. So, we already dealt with simple things like plus or minus

54:01  
comparisons if then else, but of course,

54:05  
the real fun stuff to say happens here and this is also where the mystery of type inference

54:12  
happens. So I have to postpone explaining this a bit.

54:24  
No, let me see if you're there.

54:28  
I suppose this must have been very, very tedious.

54:35  
I'm afraid this is the nature of

54:39  
what I try to get across was

54:43  
this idea that you infer types for different parts of the programme, often independently like here for Plus, you may have two huge programmes for which both you try to infer the types and then they may come out some way but

55:00  
You may need to be MC, you may need them to be something else. And there is this unification, you're trying to solve an equation to see if you can do it or not.

55:09  
And this is one type of equations that come from everywhere in these places, something has to be of a fixed type.

55:17  
And then there are other situations where nothing is fixed.

55:22  
But things have to be equal anyway. And the typical case of this is if the nails when we say that two branches, for which we infer types have to be equal.

55:34  
And therefore, we have to call this activity called unification. And unification. What it did was the kinds of things that I showed.

55:47  
Let me give you one more example. So when you have for example, something like this, that says,

55:56  
from from one branch of if then else, you get to know that well, I'm, it will return a pair like this, from the other brands, maybe that else brands, you get to know that a pair like this comes back, when you start sewing this thing, things will become more precise, right? Because the first components have to be equal, then you learn A and B have to be the same thing.

56:20  
The second component has to be sorry, are you for a topic? you're sharing your screen? Oh,

56:28  
yeah, exactly. So I forgot. So

56:33  
I didn't show much else. But now I started to say something again, yes. So I said there were these two cases, where, sorry, went this way. And where were you we saw so far that we needed unification. And this was the most important part so far. One is, for example, when you do something like plus, where you're independently

56:54  
infer some some types. And then these types have to actually agree with something that is predetermined like plus only works with integers.

57:05  
And then there was the more complicated case where you infer Some types independently like e one and B two.

57:12  
For the two branches,

57:15  
e one and E two are two branches of the if then else, we get two types back

57:20  
completely independently, so they may come back as whatever. And then we get an equation to solve, which says these have to be the same. And this thing I started distributed, which I forgot to share was this. So for example, this could be another example of what can happen, one branch of if then else can give you this thing and other can give you this.

57:43  
And when you start solving, here, it looks like there is a lot of freedom, both branches think there is a lot of freedom. But the moment when you say these two have to be the same,

57:52  
all of your freedom is taken away from you. Because you start learning things like the first components of the parents have to be on the same type. So therefore A and B have to be the same type. The second components of the parents have to be of the same type, therefore, a and n have to be the same type. In summary, you've learned that

58:13  
B already points to a

58:16  
maybe it was introduced later, but a further point swing so everything is the same type actually B is A and A is into therefore also B's in everything is the same type here

58:27  
and this is how these types become more precise as you do the type inference in unification. unification, then is the art given to type expressions try to make them the same by

58:42  
by learning more about the type variables involved.

58:46  
And of course, you may discover inconsistency if it says something like this, there is nothing you can do because the second components cannot be made of the same type. Therefore the two things cannot be made the same.

58:59  
Okay, but I really went too far.

59:05  
Yes,

59:07  
you're not expected to, to learn this code or not, or to write it, but you're expected to understand what unification is and what it does, how it works.

59:18  
So sort of on the level of what the fine tune trickery here is for variables is not so important. But it's important to understand that you know, you can only unify in the interpolant bowl, and four functions, types when the argument types and result types can be unified recursively.

59:40  
I have one of the types is a variable the other one isn't, then you can learn that you make the variable equal to the other thing if they're completely incompatible in your faith, that is the

59:51  
essence of this fake

59:57  
right.

59:59  
And I could

1:00:00  
Suggest perhaps like

1:00:03  
a five minute break and then my ambition is not more than go will be not more than go through these four clauses

1:00:14  
which don't involve so much else compared to what we had before. But I have to explain at least a little bit these two things here called specialise and generalise the rest who have already more or less seen, and then I try to show you some examples of this in action.

1:00:35  
Okay,

1:00:38  
yep, brakes off. But, yes, I can propose that we

1:00:43  
carry on like at 325 or so and then spent another hopefully 15 or 20 minutes.

1:00:50  
More.

1:00:51  
Yes, sounds good. Yeah. Perfect.

1:08:23  
Okay

1:08:27  
back there. So I discovered a question in the chat, which I didn't see before, which is an excellent question.

1:08:36  
How would this work for operator? overloads? Indeed, yes.

1:08:45  
That's Look,

1:08:53  
a very good case would already be addition. Suppose we

1:08:59  
had it overloaded for integers

1:09:04  
and floats, isn't it?

1:09:09  
What on earth would we do?

1:09:14  
Then we have to write a bit more complicated code. And in some sense, you need a bit of

1:09:21  
backtracking, I mean, different tries.

1:09:24  
But let's see, what are the possibilities

1:09:29  
good and bad.

1:09:32  
here Actually, it's not too complicated, because let's infer types. So

1:09:38  
I think the only reasonable cases are

1:09:42  
when

1:09:46  
both the type of one that is inferred and the type of Ito that are inferred are numerical types. I mean, of course, it's possible that one of them is numerical and the other one is just a type variable. Like one is float the other is a very

1:10:00  
Boom,

1:10:01  
then it's good.

1:10:03  
Because the the type of this operand for which we know the type determines the type of the other. Yeah, maybe I should write a small example here. So

1:10:18  
suppose I have something like

1:10:22  
5.0 plus x. And maybe I know that x currently, my inference has invented that it has type unconstrained. It's, it's just a,

1:10:36  
then my unification problem will be that I have to unify the two types float. And they and that's good.

1:10:45  
I do this by just saying, Okay, now I've learned that a for the future has to be float.

1:10:52  
Yeah. So we replace this.

1:10:56  
In our algorithm, we will look at is no link

1:11:01  
string a, which gets replaced with a link to a pointer to float. That's good. And similarly, when when one of these is is a

1:11:16  
is

1:11:24  
sorry, is the integer right? So maybe we could have something like like plus three,

1:11:30  
where we say is of type

1:11:34  
B, then we get this equation to solve that B has to be equal to 10. That's also good.

1:11:42  
We can get here other equations that we don't like, like,

1:11:51  
what can we get, we can get, maybe in this case, we can get them equation flow equals in and then we just simply unhappy and reject the programme that can happen.

1:12:06  
What else

1:12:07  
is interesting?

1:12:20  
If it both types are given for some reason. So maybe we have something like x plus a Zed, but we already know x, and Zed is in, then the equation is in equals int, and we're perfectly happy.

1:12:43  
Then the truly interesting question is, what do we do in the case when you have extra set? But so far, you know that x is of type A?

1:12:56  
And Zed is of maybe type B,

1:13:01  
shall we now say what

1:13:04  
floats are in?

1:13:07  
Or maybe we just say that the two types are equal for the time being? And then we see for later.

1:13:25  
Now, yeah,

1:13:28  
clearly, this algorithm needs to be modified because at this stage, we can reasonably say A and B have to be equal.

1:13:37  
But that's not enough information to record because we should also record for ourselves for later

1:13:45  
that a can only be interval, right? Sorry, can only be inter float.

1:13:54  
I'm currently we have no mechanism of saying

1:14:02  
because there can be something that determines the type later, like x plus f can be part of something bigger, like x plus that plus seven. And then why are you working on this bit? You have the problem that we had here now we don't know what to do.

1:14:19  
And then when we add seven, we know Okay, perhaps should be any feature.

1:14:29  
So there are these issues. And also, maybe you've noticed playing with F sharp that it makes sometimes some decisions that are a bit unexpected. The trouble with these overloaded operators is always that they are some way towards polymorphism, but not not universal polymorphism. In the sense that plus is not defined for every type is defined for certain numeric types int and float in particular.

1:14:58  
But

1:15:00  
But the general

1:15:02  
type inference algorithm here that we're looking at is well prepared for universal polymorphism. is prepared for functions that have specific types, but but not so well prepared for things in between. And then what?

1:15:21  
What F sharp tends to do when you when you, when you do type inference? It defaults to four plus, for example to be of type int when it doesn't know any better.

1:15:34  
Less you have perhaps noticed. So I think even when you just check what the type of plus is,

1:15:43  
say it says it's a Twin Twin From where did they get it?

1:15:49  
I may very well say that it's float to float the float and it will be happy then.

1:15:57  
But by itself, it has to default to something because there is like no reasonable generalisation. You can't say it's a great way.

1:16:10  
And there is there is no language mechanism to say that is some A, which is only integer float. So I can myself fixed the type to be float, but

1:16:20  
when it specialises in this sort of completely undetermined situation, it makes a biassed choice towards integers.

1:16:30  
Okay.

1:16:34  
So, yeah, that the question is how to propagate this information out, inside out. If for the moment you don't get now and currently this this, this sort of structure of the algorithm is not prepared for this. So we need to tweak it a bit to fit this in.

1:16:52  
Because you do want to get the type for such a thing, right.

1:17:00  
Let's try

1:17:10  
see the

1:17:12  
the type inference manages to deal with it. So it manages to decide that these are inputs in this particular case. And I think it will also manage when I say 5.0 so it can look a bit the head

1:17:26  
until this kind of propagation here.

1:17:30  
So at this stage, you only learn exons that have to be of the same type. And then the further outer context maybe gives you more information.

1:17:43  
Is this good?

1:17:48  
Okay, let's look at the remaining cases. Now very briefly.

1:17:54  
What do I want to start

1:17:56  
maybe here,

1:17:58  
when you have a variable

1:18:02  
you want to know what its type is the environment should know its type.

1:18:07  
You can look it up in the environment, but that gives a polymorphic type for it. So

1:18:14  
in general, if the type contains type variables, it says they can be anything so so for example, I can be in this context where I've said Let food

1:18:26  
x equals x and then I do something.

1:18:29  
If I here look at the type of food, it is very general it is

1:18:35  
a to a but in any use of foo, I actually need to specialise it depending on

1:18:43  
what kind of argument I want to apply for.

1:18:49  
So in general, you may need to specialise

1:18:54  
the types that you learn from the environment. So this is a type scheme it contains all these unconstrained variables. And this is what specialisation does. It replaces all these unconstrained variables with copies there off, which can then be made more special.

1:19:12  
If this var is embedded in some bigger context that enforces that these variables take some particular renders. So that specialisation it takes into account the level of choice Okay.

1:19:25  
How about let

1:19:28  
the idea about let is always some sort of extension of the environment right because the body can use one more variable compared to for example, this right hand side.

1:19:40  
So LBL prime will just be the increment of LPL. Then what do we do? We infer

1:19:50  
the type for the right hand side

1:19:54  
with level parameter LBL prime not LBL because this is on deeper

1:20:13  
I think it is we infer the type

1:20:18  
and then what we do

1:20:21  
when we build a new environment

1:20:25  
and

1:20:28  
this is just the extension of the old one with the knowledge about x type, but at this point we say

1:20:35  
we derive the type for for TX this may be a function maybe it like is like this full here maybe it is very general type and at this stage we say all type variables we see around now, depending on the level

1:20:50  
yeah all type variables have the correct level that we see around we are universal in some way we do this generalisation things, we turn a pipe into a type scheme, listing those variables as unconstrained

1:21:05  
and then finally, we infer the type of the body in this new environment.

1:21:19  
Yes.

1:21:22  
Okay.

1:21:25  
Then

1:21:29  
that was about four and left,

1:21:32  
when it comes to functions, we have to talk about function calls and defining new functions. With functions, always there has to be the agreement between the function type

1:21:45  
at the use place.

1:21:48  
So, when we apply a function to an argument,

1:21:52  
the argument type has to agree with the declared argument type of the function right.

1:21:59  
And then something comes back and that has to agree with

1:22:04  
the return type of that,

1:22:07  
of what has been the carrot and, and this has been this is made sure at the call. So a call consists of what so there is a function expression and an argument expression, one apply to the other, what we can do is we apply the type of the function, we apply the type of the argument

1:22:30  
and then we do a trick, then we we just invent the type variable for the result.

1:22:41  
Type.

1:22:43  
And then we do a following do the following unification we say the function type has to be the same as fun dx, where TX is what we infer for the argument.

1:22:57  
And here we put tr for the return type because we have no better idea. So here we invented the new variable name, and that gives us an equation.

1:23:08  
And if the unification succeeds, when we return the return type, let me give you an example here. So, suppose we do something like

1:23:22  
I don't know, we apply f Two, three. And maybe

1:23:28  
when we do the type inference for F, we have found the following type we have found that it's from it goes from int to bool.

1:23:36  
Then the trick that we do is we invent the type variable for the return type. And then we unify the following things we unify the functions type, which is to bool.

1:23:50  
With the first argument, which is in here, in this case,

1:23:57  
and some invented variable to speech.

1:24:01  
And when we do the unification of course, we learned that this B will have to be bold, in this particular case, but it could be more complicated.

1:24:10  
In any case,

1:24:12  
tr is returned. And by that stage, I mean it was it was it was defined as a T bar,

1:24:21  
where we've done a new type bar, so this creates a new reference to

1:24:28  
to the pair consisting of the given level. And then normally to refresh variable name.

1:24:36  
But by the time we get here, it may have gotten more precise because of this unification thing here.

1:24:43  
Okay, let's also look at let fun. Now that's the most complicated.

1:24:49  
So here's the function name, parameter name, right hand side, that's the body of the function e body which is the body of the left

1:24:57  
what needs to be done

1:24:59  
there

1:25:00  
prime is just the next level.

1:25:07  
Now, this is type inference without any type annotation. So here we have no idea about the type of effort, we just invent some types, TF will have will be of this type, t x will be of this type, these are new type of variables at level LBL prime,

1:25:26  
then we extend the given environment by adding their that x is of this type that we just invented for x and f of this type that we just invented for F.

1:25:38  
And we consider these type schemes where nothing is general, because these new type variables that we invented,

1:25:49  
we are not universal in them, they're just names for something that may need to be concretized when we solve equations,

1:25:56  
then tr is what then in this extended environment, so, we just give gave some hypothetical types to F and x,

1:26:06  
we try to infer a type for the right hand side.

1:26:13  
And then we hope that the type that we invented for TF or

1:26:22  
or some more precise version thereof,

1:26:25  
that we already have by this stage can be unified with fun of TX tr. So, first TF is a is a type variable, but then we want to unify it with something of this more specific form.

1:26:39  
Okay, if this succeeds at all, I mean, if the function definition is not nonsense,

1:26:46  
then we can build a different environment, which again uses TF, but this time generalised because

1:26:55  
if after all this activity, there are still type variables left in whatever TF has become equal to, then these are the type variables in which we are universal, and we can then accordingly generalise and then finally, we define a further type of the body in this given new environment, or sorry, in this in this newly formed environment.

1:27:20  
So it comes in several stages, you know, guess the type, I mean, not gets invented, type ref, just apply for event type for x, put these invented types in the environment, infer the type for the right hand side, then try to make sense of it. This is the unification stage, if everything made sense, then

1:27:43  
extended environment differently with a generalised function type. So we say all the type variables you now have your universal in, and then infer the type for the body.

1:27:57  
What is an example of this?

1:28:07  
So we have some examples of this. So for example,

1:28:13  
all of these are coded. So we can look at what happens. So for example, this add one, maybe it's a simple programme,

1:28:22  
I can apply,

1:28:25  
I can apply.

1:28:43  
And it tells me it's in tweak. And this is not f sharps

1:28:49  
type inference. It's our type inference. Because we've used

1:28:54  
we've used power coding for top and what comes back is really not not really not the type in the F sharp sense, it's just upstream we produced it look like this.

1:29:06  
And

1:29:08  
here are some other ones. So for example, this was the definition of pipe

1:29:13  
written in our little language.

1:29:17  
Pipe just

1:29:20  
is something that you can use for applying a function to an argument but in a different order.

1:29:27  
And this is defined here, and if you like to pipe

1:29:34  
you to get the right result here to see how the name generation has,

1:29:40  
has worked. So some names A, B, C, D, E, F, and maybe some more were invented.

1:29:46  
But then some of the lanes have to be the same.

1:29:50  
Or sorry, some of the names

1:29:53  
didn't have to be the same. Maybe they have to be the same but they had to be equal to some other types. So they we

1:30:00  
We got rid of them. But finally, we've got two names that are still unconstrained CNF for example,

1:30:09  
maybe I can just show you a little glimpse of specialising generalised.

1:30:15  
generalised is not so bad.

1:30:19  
It takes

1:30:27  
it takes a type and it turns it into a type scheme by saying, which are the exact

1:30:34  
variables type variables occurring in the type in which we are universal. And that's done by looking at levels.

1:30:43  
So, really, what comes back is a type scheme t vs T, where T is the given type of PVS is some list of variable names that we have found. How is it done, we collect all type variables that the current T

1:30:58  
and then we just

1:31:02  
filter out those that are not free in the current context. These are the ones that in which we are not universal. What is this non free in context, this is defined locally here. So for every type variable, you just actually check

1:31:21  
if it comes from a deeper nesting level than the current one. And in this case,

1:31:28  
we can't say that this is that we universal in that type variable.

1:31:35  
This is maybe a bit difficult to explain in words at all.

1:31:41  
But if you write down examples and think

1:31:46  
what, what what to type variables coming from deeper levels, meaning when you see realise that this is the case.

1:31:55  
This generalised and specialised

1:31:59  
is kind of a worst thing. So here, the idea was I'm I'm given a cosy the opposite direction, we're given a type scheme. And we just want to get a type,

1:32:12  
which is obtained by

1:32:15  
taking all these type variables in which we were universal, and replacing them with new type variables that we are happy to actually make more precise if the applications

1:32:29  
require so.

1:32:32  
And this is done by

1:32:43  
the following thing. So we innovate, we invent new variables for each of these three variables here, that's called bind fresh.

1:32:54  
And then, essentially, one walks through

1:32:59  
the type and replaces every occurrence of a variable with a new copy of it. And thereby we call up the whole type with the substitution.

1:33:12  
Okay,

1:33:14  
that is really technical, and I think, hard to explain on a conceptual level. This is a trickery in this album.

1:33:24  
But the big part was, what the big part is, is these checks here.

1:33:30  
So

1:33:34  
with type annotations,

1:33:38  
the situation is a bit simpler. But here, when when we define a function, we first have to start with like a clean sheet with the with the function and the parameter, we have no idea what what their types are, we just put type variables that we solve equations, we come up with something and then we check if the whole thing makes sense.

1:34:01  
So we insist that whatever we invented for the function, agrees with this thing with

1:34:07  
a t, x and t are the types we have invented for the arguments and the return value.

1:34:15  
And similar thing in a call.

1:34:21  
Okay, and here are some more examples that you can then play with.

1:34:30  
Things to take home. This is maybe the first place where we've needed actually a bit of imperative programming to make the algorithm nice and efficient. In that, this solution, we don't really collect equations, we solve them as we go. Partially in this unification thing and partially just doing this re linking of

1:34:54  
variables to more specific information we've learned

1:34:59  
and

1:35:00  
This linking uses the fact that we have cleverly represented a type variable that is initially really a variable as a string. But as soon as you know that the type variable, which is thought of as kind of an unknown, is something more precise, then you replace the no link with a link tool.

1:35:20  
And you know that you've already instantiate it into something, and then you get these chains of link tools.

1:35:34  
That should be it for now, for my part,

1:35:39  
I can promise that the remaining

1:35:44  
lectures on functional programming are gonna be much, much simpler No, again, so this was by far, I think, the hardest

1:35:54  
thing in the whole course that we know, discussed over two lectures type inference.

1:36:00  
And I just hope that you've got some glimpse into it.

1:36:05  
On the level of ideas, it's very important to have a feel for what is going on, either in F sharp or in our own type inference. But the details of it are fairly involved.

1:36:24  
On Thursday, and next week, I'll talk a bit more about sort of foundations of functional programming, we will actually look at the very small core with which one can express everything we've done so far. It's called the lambda calculus, it was actually invented before any real FP languages

1:36:48  
were conceived for computer programming.

1:36:53  
And certain things are easier to see and explain. They're actually also on the level even though of this type inference, but it's very important to understand that this is

1:37:04  
ultimately ultimately all functional programming reduces to this and everything else is is syntactic sugar and niceties that you build to

1:37:17  
to have a really convenient programming language on top of this underlying

1:37:23  
little computation mechanism.

1:37:26  
What is going to come?

1:37:37  
How about more questions?

1:37:53  
Throw me phonologies Okay, yes, let it sink.

1:37:59  
And yes, we go on to different things. So in the next lectures, I'll show a bit more slides or maybe just

1:38:08  
write on this whiteboard. And yeah, it will be of a different flavour. Okay, then. I do stop here

1:38:22  
and seal on Thursday.

Transcribed by https://otter.ai
4:15  
Hello

4:19  
Hello, can you hear me

4:23  
I can only see three people around

4:27  
that is a bit

4:30  
interesting.

4:36  
Let's see how we go

5:52  
We have to readjust to thank you.

6:57  
I'm sorry,

6:58  
I have to change something in the setup my computer claims it's super busy, although it's doing nothing. Okay, let me check again Ken, can you still hear me?

8:41  
Yes, that's perfect. Okay.

8:43  
I don't know, then I think I'll just start I'm sorry for this delay, there is something really strange about the connection, my computer. Anyway,

9:02  
my plan today is to talk about lambda calculus. This is the last section of topics and functional programming before we go on to imperative programming. And lambda calculus is, if you wish, a tiny little formalism that in some sense is the core of all of functional programming. And it's a good vehicle to explain some of the subtleties that are going on on functional programming in a really minimum setting.

9:41  
What is it about? It is a formalism that was actually invented my good stay in the late 30s or the fall. northeast of last century

10:04  
by two logicians, whose name were Alonzo church, and Haskell curry. And it comes in two basic versions that correspond to sort of untyped and type functional programming. In untyped, lambda calculus, this is really a very, very minimalistic kind of formal calculus. One can write terms, lambda terms, also called expressions. And the basic feature is that these can be simplified or that they compute according to certain rules. And really, these rules capture the essence of, of what we've seen so far in functional programming. There is a different version that is called typed lambda calculus there. In addition to expressions, you also have types of types or types like we've seen before. Most importantly, you can take two types and form a new type of out of them that you call a function type. And this is the mechanism of producing interesting types in lambda calculus. And then terms that in some sense are good or satisfactory, they can be assigned types. And then there are other terms that you can write in the syntax of, of lambda calculus, that are less we help what less well behaved in essence, they can't be typed. So types are a way to classify terms into sort of meaningful or nice or good, and other terms that are a bit more problematic or ill behaved. And the idea then is to to capture the essence of what it is really to compute with functions. We saw in in all these functional programming exercises, that what you do in functional programming is you make functions you define functions, and then you apply functions. And at the end of the day, pretty much everything is either a simple value, or a function. So some of the functions we may write in a different notation, like maybe plus and times, we don't think of them so much as functions, we think of them kind of as binary operators. Where in the notation you put the operator sign between the two arguments rather than in front, etc. But really, they are also just just functions. We have these data types with like, like lists, for example, where you have data constructors, nil and cons. They are a special case of functions, but in the end, they are again just also functions. So lambda calculus is there to sort of state in a very minimal setting, what a computation with functions.

13:14  
Do what is it about? Okay, let's actually see. So yeah, what does this say say? Almost what they already said, We split lambda calculus into two flavours on pipe pipe. And if untyped you can write meaningless terms. So one kind of

13:41  
meaninglessness that is treated in lambda calculus is the idea that you apply a function to an argument that doesn't really fit. This is eliminated in typed lambda calculus untyped lambda calculus allows you to write these things. Then actual FP languages, they actually use variants are extensions of this on typed and typed lambda calculus. So they do a bit more. So what is what is the central idea? We saw it in F sharp in this phone notation of writing anonymous functions. So a central idea of lambda calculus is to work with the function to define it to apply it to pass it as an argument to another function, you really don't if you don't want to give it a name. So a function can be anonymous or nameless. So when For example, want to define a simple function like multiplying with a constant or adding a constant. This is a very familiar way of writing this, like I could say that function f takes a parameter x. And what it returns is expressed in terms of the parameter in this way, instead of it, and instead of explicitly working with his name F, we could also and that is what is done in lambda calculus, right? Fun x arrows 17 times x in any language, like F sharp. And in lambda calculus, the corresponding notation is this. So that's actually for where the name lambda comes in lambda calculus, which is the Greek letter lambda. And what we have in this notation is the following thing. So we have the function body, this bit here, 17 times x, coming with a certain prefix, and the prefix, the main thing here is lambda, it says, Look, here we are forming a function. And what is that function? It is this expression 17 times x, which we see as Perryman parameterised in x. So we say, No longer do I think of this thing as 17 times some fixed x, where I'm not told here, what the axes but some environment will tell me, that's not the way of thinking. Rather, we say this is a function that whatever x is given returns 17 times that x. And this then is an expression for exactly the same function. Of course, there are practical reasons to give functions names, namely, I may want to use the same function in many places of my code, so it would be a bit silly, if I have to write the function definition, this one here, all over the place many times. So that is somehow passed, beside the point of working with functions. But actually, the rest of the lambda calculus mechanics allows you to do this. So although at the moment, when you define a function, you don't have to give it a name, you still have a possibility to morally give things names and just work with these names. That's done with a combination of these this construct of anonymous functions that are also called lambda instructions. And then function simple function application. So we'll see this in action. shortly. Yes, okay. So we go to untyped, lambda calculus untyped, lambda calculus can be defined literally on one slide on the level of syntax. So there is exactly one syntactic category of things that we could write. And

18:35  
these are called terms. But it can also talk about expressions, it's, it's really the same thing. And then, terms are built from variables, which are just assumed to be some given set of names, that that they're readily made for you a supply of variables that you can work over or identify with, you might call and then there is exactly three forms of terms that you can write it all and the other following you can write variables which are treated as terms. You can write lambda abstractions, and you can write applications. So what are those, a variable as a term is literally written as just a variable. So if x is a variable, you can also think of x as a programming terms it corresponds to the use of a variable, then, abstraction is the thing that I already showed from distance. So given the term, I can prefix it with any variable and the lambda and this talk is just some sort of a standard punctuation mark conference here. So these formal things are called lambda abstractions and they are there for defining functions without giving them A specific name. And then the third form is we're allowed to write applications. So a term and another term written next to each other. Maybe we'll put parentheses around so that we can clearly see the two parts of an application. D is the function that I'm applying you is the argument I'm applying to, you think of it as a function application or function call, as we also talked about. And that's literally all the reason. We can't write anything, anything gets beyond that.

21:12  
Okay.

21:14  
And then you can combine these things in any way you please. Let me change the sharing so that I can give some examples. Okay. So, you can combine these things in any ways that you please. So for example, the following would be

21:56  
terms.

21:58  
I can write variables. And they are terms. So things like X or Y, or Zed are terms on their own. But then I can start putting together more complicated things out of those. So I can, for example, write x applies to y. Or I can write things like maybe x apply to y. Apply to Zed. Yeah, looks like a formula game. So I mean, who says here that these things are functions or so. But somehow they should be else could How could they apply here, we should be able to think of at least in this expression, x applied to y apply to Zed, I should be able to think of x as a as a function, then we can write more complicated things, then we can make things functions really, because for example, say I want to abstract set out of the thing I just wrote.

23:07  
That's another term. And then I can abstract yet further things out. Or maybe before I apply, for example, to this, I apply lambda said x, y, two W. And then maybe in the end, I abstract something else. So all of these would be lambda terms. If you write them down like this, he'll quickly drown in a sea of parentheses. So one must seek for ways of minimising their amounts. So let's, let's make some conventions about those. So, one of the typical things that you do is, you agree that application associated to the left. So we when we write such a thing, like the apply to you apply to be in principle, one could think of two places where to place the parentheses here, but we mean this one that we should explain. So to apply to you apply to be looks ambiguous. So of course, we could think that it means this but alternatively, we could think that it means this.

24:33  
Now which one is correct? trouble here is I tend to press the wrong button.

25:23  
So we had just a stick. So we could ask which one of these is correct?

26:24  
And the answer is, in this case, we always say, parentheses to the right to the left is the morally correct way 3d? There is a similar question about lambda. So we don't want to write too many parentheses for lambda. So then what could we do? And typically convention is we say that lambda extends to the closest closing parentheses. So when we written something like lambda x to you,

27:02  
a priori it could mean two different things. It could mean this or this. And again, we have to ask which one of them is correct.

27:20  
And here, the correct one is the second one. So and the reason is, we say lambda extends as far to the right as possible until the closes closing parentheses. So here, there are no parentheses at all. So the scope of this lambda is to the very end of the expression. So therefore, the idea is the body of the lambda is the whole thing here. So we already wrote lots of terms where we are this question about perhaps what what do they need? So it is okay here to write all sorts of things that typing discipline would not allow. So one of the things for example, that you could like, write would be something like x applied to x. Now reasonably, that should not be possible. Or maybe it's possible with polymorphic types, but at least with simply simple types is not possible. Because I mean, if x is of some type A to be some fixed types, how is it possible, then that I could apply it to itself because it would require an argument of type A, but the argument is also of type eight, and eight doesn't equal eight. And that is literally it. I mean, it looks like a very poor language, what can you write it all, you can only write function abstractions, is defined functions, you can write applications, you can write variables, it looks like you can't write anything, you cannot even write addition or multiplication or anything. In fact, you can, you can code up all these things, but that's somehow not the point. It is also okay to just throw in some, some constants, like maybe plus some times or or numerals into lambda calculus. And this just gives a lambda calculus with some constants. these constants may be assigned specific, meaning that you can work with them like this, and people often do. Now, in a real functional programming language, we had these leps, which were very useful because they allow us to write local definitions and nothing like this seems to be possible here. So how about them? Well, it turns out that they are really not strictly necessary. At least not until we start to make some finer things distinctions about how exactly should computation or simplification of expressions go when there are multiple choices here. So how should that Write down such a lead in lambda calculus. Well, one way to do it would be to think like this. So what is the idea here? Anyway, the idea here is that u is an expression in which I can use a local variable x. and morally, the value of x is t. So one way to express it would be to say, Well, let's think of u as a function in the parameter x. So we abstract out x from you, and we think, now you doesn't have an independent, meaning he has a meaning when we provide the x. And then then we just provide the x. So we make a function, we say, here is a function you've seen as parameterised in x. And then what is the actual value of x? Well, this has been specified here. Let's say this is then lambda x you apply to t. Well, I've written that the two things are exactly the same. In some approaches, they aren't actually exactly the same. And that has to do with with, with the extra strategy of simplifying expressions. But in ideal lambda calculus, these things should be pretty much the same. So we also have function, let's say we had these kind of definitions of the formula, f of y equals t in U. How about those? Well, they're just a special case. Because when I make the definition f of y equals T, what I really mean is, I am giving a name F to this function, lambda y t that I could write even without giving it the name, right, because here the point is, we see t as a function in y, and then we name it as F. So So this thing here is really an abbreviation for this thing. And for let we already know what it is. So the whole thing could be understood this as think u

32:06  
is a function in a parameter F, the actual value that we want to give to this parameter in a specific call of this function, is lambda y of t. So both both the symbol x and function let's can actually be expressed in the lambda calculus, since it's one of the sort of purposes of lambda calculus is to have a minimal core in which you can explain everything about functional computing, then you can treat that as a syntactic sugar which is not part of the core. Okay, now, I will soon get to explaining how computation happens in lambda calculus. For that, we have to introduce some terminology, conventions, and then we can write down how computation goes. So the first important bit of terminology is bind versus bound versus free variables. So for every expression, it's important to understand

33:29  
if

33:32  
sort of the meaning of a variable used in this expression is supposed to come from outside or it's already fixed in the inside, so to say. So, when we have a lambda abstraction like lambda x dot t, we say this binds the occurrences of x in T. So, in such an expression, all the axes that you can see in T refer back to this x, because any other axes are not visible. So, this is captured in this terminology, this lambda abstraction binds the occurrences of x and t. Now, if you've got any term given, then you can talk about the variables in it and you can ask which lambda is the one that binds the variable or maybe the variable is not

34:27  
bound at all it is free. So if we for example, look at this example that I wrote down here. So this is the big lambda term. certain variables occur bound here. So for example, y is used here. And it's part of this expression. And it is bound here. Yeah. Similar said the curse here. And it's called the small aids folder this place. But x and w are not bound anywhere in this term. So they are free on the top level.

35:22  
So this is the terminology bind bound variables free variables, then there is the important principle, the terms that differ only by the names of bound variables. They can be considered equal, they're sort of notational variants of each other. These terms were that only differ by names of both variables, they also called alpha convertible. So, let me give you some examples. So, I can perhaps write the term like this. And this is a perfectly good term, we're actually every variable use is bound. But we want to consider it to be the same as these, because all I've done is I've replaced one local variable name with another systematically. So, why was introduced here, so, this occurrence is bound by that lambda y. So, if I make a different choice here, so I say I want to write lambdas. And if I systematically replace every free occurrence in the body of the lambda of y with Zed, I don't get an equal turn, we can do a similar thing tu tu tu tu x and for example, I can write the whole thing is also the same as this. That's a well understood principle also from from programming languages, right? So, local variables can be renamed if this is done systematically and carefully. So, I should also emphasise something. So, for example, let's start here in the top line again. It's not okay to arbitrarily rename variables. For example, The following is not the same, I cannot just take y

37:55  
and rename it into x and get this term. Why? Because this contradicts an important restriction on renaming variables, which is called avoiding capture. What is capture is the following principle. So suppose I'm given this lambda term, and I want to rename x into something.

38:41  
Now, I'm free to use anything instead of x. As long as it's not something that is already free in. If this is the case, this is capture and must be avoided. So here is a simple example of this. This little lambda term, it's okay to replace x with Zed. Because that doesn't occur here in the body of the lambda. So by renaming X to Zed, I'm not mixing up the bound variable x with anything that was free in the whole term. But for example, the following is not okay. So if we start with the same term, I cannot choose to rename x into y, y, because y is already free here Actually, it's free also here. Yeah. So why is a free variable. And if I rename it, if I rename X to Y, I'm mixing up font and free variables.

40:02  
So similar in my example, here was the situation I'm talking about renaming y. So we're interested in this part of the term, which is the body of the lambda obstruction, lambda y, y, x.

40:24  
If you look here,

40:26  
this part has x free, x is bound somewhere, but that's further outside. In this part, x is free. So therefore, it's not okay to rename y

40:39  
into x.

40:41  
But some other renaming are okay. So let me give you some more examples to make the distinction. So suppose we have something like,

41:01  
suppose we have a term like this. I could ask, can I rename this why, with a corresponding uses a wine the body of the lambda? He does that he has that seems to be used around. So it looks like a bit dangerous. But actually, it's not. Because all I need to check is that I don't have that free here. And here, it's not free, it's not used

41:35  
to so

41:37  
therefore, I can rewrite this, as Linda said, setbacks apply to lenders. And this is okay. This looks perhaps more complicated, because it's a programme or an expression that has two parts that both use a local variable set. But it's okay. Since these are independent uses, there is there is no confusion about scope, the scope of this lambda binding is, is all of this part, the scope of this finding is all this part

42:18  
and the to

42:19  
never mix up in any way. So for example, it's okay now to do some further renaming, if I want to like I could say that that's the same as this. And when I rename this set here, into W, it doesn't mean that I thereby also need to rename this set into W, because they are different. bindings, and they have different scopes. To talk to some of this part, we have to make difference. So for every variable use, one of two things happens, it's either bound by some lambda in the global expression. Or it's simply free, sort of it's a top level free variable. Terms differing only by the vowel by the name by the names of bound variables are considering are considered equal subject to this condition that you can't do this kind of renaming. So that you get variable capture. A free variable shouldn't be captured by lambda. Incidentally,

43:42  
this okay. So here is more examples of exactly the same. For example, here we've taken a term and chosen for example, to rename x into x prime. This is perfectly okay, because x prime is not mentioned here. Here, again, x is renamed into x prime, which is okay, because it's not mentioned here.

44:09  
Here.

44:14  
I'm replacing x with x prime. And now it's important to remember how the scoping around lambda goes or when do we have to read the parentheses? So we have this lambda here, the body of this lambda is not only this part, it's the whole of this. So morally, there are parentheses around what I've just painted orange. So therefore, when you do renaming, x becomes x prime, all throughout this point. And here's yet another example. Now, how does computation happen in lambda calculus, computation amounts to simplifying term in small steps. And or historically, these things have sort of anachronistic names, we said that renaming of old variables was called alpha convertibility. I think it's called that only because alpha is the first letter of the Greek alphabet. Now in computation, you don't use alpha, only use B, which is the second letter. Anyway, so you go in these small steps that are called beta reduction steps. And the idea is at every stage, or at every step, we try to make one of these simplification steps. And you repeat this process until you reach the term where you cannot do anything anymore. None of the simplification steps or rules applies. The terms that you reach there by they're called Peter on the whole process of computation or simplification, in sort of official jargon is called normalisation. You want to normalise it. So here, for example, is an application of this, I'm not yet justifying that what happens at these simple steps are simple steps are indicated by this arrow here. But anyway, things like this actually turns out to simplify in one step to raise what really happens is this guy here is a function in x. And what the simplifications that does is that it puts the argument in place of the parameters. So the parameters x, and v is the actual argument of the call, and X has been replaced with V. And the whole thing here, this part, simplified into this. Here's the next step. I later give you the formal rules, what happens, but informally, what happens is exactly the same type of thing as before. So here is an expression that is a lambda abstraction is a function, we say, we have the expression y plus V, which we see as parameterised in y. And then we actually call this function with this argument, which means this parameter is passed the argument this w v, is passed to y, or is passed to the whole function as the value of the parameter y. So therefore, the Y gets replaced by the whole thing. And that complete final result of this, this is called the normal form. Why? Because it turns out that now no further simplification rules apply the rules that they haven't shown yet. They're also they haven't shown yet turned out to be non deterministic in the sense that it's often the case that you have a term, but there are several possible simplifications to apply first. In a real language, you actually restrict this and you say, if there is multiple simplifications to do, then one of them has a preference and that one will be applied. So, there is a particular evaluation or reduction strategy. I should also say that there is a bit of difference between sort of idealised normalisation in lambda calculus and the one that is used in actual functional programming languages. The first difference comes from the fact that in an actual language in addition to where variables applications and abstractions, you also have constants as we already discussed, like rate plus and times. So, there will also be simplification rules for those in addition to the rules of lambda calculus, also, when often adapt to a more narrow notion of reduction. So, first of all reduction is made deterministic,

49:22  
but some of the reduction steps perhaps are not also applied in a real FP language. So for example, you do not necessarily apply reduction steps inside abstraction. So under lambda you refuse to simplify. This is a very typical thing to do. But we're not yet there. Let me first tell you what beta reduction does. One way to explain what what beta reduction does is to give it by a system of kind of productive rules. Now, you may or may not have seen such a thing before, let me try to explain. So this is like laying down the rules of the game, formally. So I'm about to define when does one term reduce to another, t reducing to you is written t aeroseal. And here I'm telling what are all the possible cases where this happens, here is the main principle case, which says, whenever you have a term like this, you can, in one step, reduce it to the following thing, you just keep T. And here is some formal notation, you replace every free occurrence of x in T by you.

50:59  
So this

51:00  
replacement thing, he is officially called substitution. And we'll actually discuss it in quite some detail. So that's where you start. So if your term is of this form, then you can replace it with a substituted form of t, for substitution instance of t, where x has been replaced with you everywhere where x is two. That's not the only thing you can do. Namely, it's not necessarily the case that your top level term is of this form. But it's possible that this form occurs somewhere deeper in the term. So for example, it can well be that your term is actually a lambda abstraction. Now then, if the body t reduces to t prime, then the whole lambda x of t reduces to lambda x of t prime. So what is this horizontal line doing here, these kind of things are called rules. A rule says, a certain reduction is possible if some other reduction is possible. So I'm concluding the possibility of this simplification step from the fact that I already knew from somewhere else that this one was possible. Okay. It's also possible that the top level term is d applied you for some T and Q, then I can do one of the two things one is captured here in this rule, the other one is captured here in this I can perhaps, in one step, reduce D to D prime, then it's also true that this whole application in one step reduces to P prime, you know, similar, maybe I can't reduce D, maybe I can reduce you in one step to your prime, then it's okay to say to you reduce this to to pry. So what is the overall effect of this thing? This is one possible style of writing what happens but at least what happens is fairly simple. given some top level term, you just look for occurrences of sub terms of this form, some left lambda abstraction applied to something else. And these are what you can simplify, they can either occur on the top level, so your given term is already in this form, and it simplifies. Or it's not the case. But your toddler term which is of one of these forms. It contains inside it some sub term

53:50  
that simplifies like this. So these rules in the second line here, they just allow you to go deeper in a given term,

53:58  
and find the sub term of this form and then eventually simplify that. Okay, substitution, I have to tell you more carefully what it is. In most cases, it's easy to understand what it does. But again, there is this danger of variable capture that also occurs here and capture needs to be avoided. These terms that directly reduce baby certainly fighting, they are called bheatha, red X's. And then all of the beta reductions that really do is that it finds the subject of this form in a given term and it replaces it with something of this form. So a bita reduction step simplifies one of the possible beat directives occurring somewhere in it. Now, when are you in a position that you cannot apply this rule anymore? Well, that happens if you no longer have any bita red axes. So this thing is called the single step data reduction of single step bigger reduction. multiples that data reduction is just applying 01 or multiple single step, pizza reductions. Okay, so let's maybe go and justify this thing that we saw here.

55:52  
So here, these two cases where simplification is used. And this happens like this. So first, we want to apply simplification to this guy. And we want to know, what can we simplify to? On the top level, this is not of the form some lambda apply to something. Because what is happening here is we do indeed have some lambda is applied to something, but the result is further applied to something else. So not that's not of the form to apply beta reduction directly on the top level. But what I can do is I can go inside this term. And I can ask, maybe I can simplify

57:09  
the argument?

57:22  
I guess, no, we can, because this is exactly of the form a lambda apply to something else. And then we have a rule that says, in this case, I'm allowed to replace the bound variable x with the actual argument, or the uses of the bound variable x with the actual argument and we get rid of the lambda. So lambda x is come and I go get lambda y, y applied to B. So this happened by this fall here. That's what I've done. But now, what is my overall picture, I have this big thing. Which is actually applied to something else. And they know how to simplify this part. Well, if I know how to simplify the function, then I know how to simplify the function application. That's exactly the case. So if t simplifies to t prime, then t apply to you up simplifies to T climate. So the result here is lambda y by V, apply to that. So that's the justification of the first simplification step here. Now, let's do the second one. Okay. The second one, I have to work with lambda Why

59:11  
Why me?

59:14  
W v, I need to simplify to something that is already on the top level of the form lambda applied to something. So therefore, I can use my simplification rule

59:29  
immediately.

59:31  
Yeah, and what as you can see, we have to take the parameter, which is why and replace it with w v. So the result is w v. applied to V. Four for why I put this web and I got rid of this and why at the beginning Now my parentheses rules are such that we always when we feed C to applications in a row, then we don't need to use parentheses. So it's okay actually not to drop them.

1:00:19  
That is the result. Okay. So far, so good. And it shouldn't be much more complicated than so but actually it is a bit. So we have to be maybe careful about how does substitution go. So I said there is this thing, which we formally wrote like this, we take a turn T, and I want to replace every free occurrence of x with. So how should this be defined, maybe we should look at all possible cases where p can be, it would be kind of a recursive definition. So if t is itself x, then of course, when I replace x with B, it's just me. If t is some other variable, and I want to replace x in it with V, while y is not x, so therefore there is nothing to replace Y remains y,

1:01:20  
then

1:01:23  
variable application is a nice case. So I've got an application to apply to you. And I want to replace all three occurrences of x will be that simple. There's really something very bad with the, with my laptop, so when I lean, then it starts sending signals, I need to recursively replace x with V in T and recursively. replace x with V in you, and then just apply the results. That difficulty and and situations that require care occur in the case when this term is actually a lambda abstraction itself. So we have this form lambda x dot t, when I use the same variable name for lambda binding, as is the variable that actually want to replace the view occurrences off. Or it's a different variable. This case here actually is pretty nice. So because we are saying we want to replace three occurrences of x with V. But the occurrences that X can have in T are not free, they are bound by x. But the idea of substitution is to replace the three axes, the X is that the outside world so to say can say there are none of those in here, so that the term just remains.

1:03:05  
But how about extra variable here is different. The same thing is the variable here is different. So I've got the lambda y, the T, I need to replace free access with the What can I do? Well, I should say this is a lambda abstraction again, and I should simply just go inside it and replace all variables, all occurrences of x with V, because V, that's almost right, except for the annoying subtlety v can contain in general, why freely and if I now put v on there, why then y becomes bound. So this is again capture that we already talked about before. So that needs to be avoided. So we have to put here a site condition that y should not be free. Then what does it mean? Of course, one can be free in vi so what to do that? Well, then we have to do a trick. So if this force equation doesn't apply out right, then we actually need to go to alpha convertible form of this term, T. So rename y to some very bold, that is not free indeed. But it's also different from x because if we remove or rename anything to x, then

1:04:43  
we

1:04:45  
will modify the problem. Let me give you some examples of this. So this is a very subtle case. So here are the first ones are all Some easy and good cases of substitution where there's nothing to worry about. So, but then the further and more complicated examples will come. So if I've got a term like this, and my task is to replace all three occurrences of y with that W, then that's okay. Because

1:05:25  
Zed w doesn't contain x friendly. Therefore, it's okay just to go here and sign y and swap the Y for Zed W. Here, there is a more complicated one, but nothing much different happens. So I've got this term. And we have to replace three occurrences of x by this piece here.

1:06:02  
Well, there is exactly one occurrence of x. And I've replaced it by this.

1:06:12  
And this time, we are not substituting under lambda. So the problem of will capture or the possible problem capture can also be right. Here, there is a different one. lambda x dot x, y. And we want to replace y with this thing. So here Everything looks a bit dangerous, because it's the same x's and y's as if throughout. So is there a possibility for capture now? Actually, there isn't. So I have to check these things, this term here to see if it contains text this one freely, it doesn't. So therefore, it's okay. To put the whole thing here instead of why here has why here are having sex the same thing, but instead of why I have this here. Notice that this one contains x, sorry, complete x, but not free. And here, there is no collusion. In the result, there is two different bindings of x. But they don't mix up

1:07:39  
in a bad way.

1:07:45  
How about this, I'm replacing y with Zed in this term. And that's okay. That doesn't mention x. This happens.

1:08:04  
Here,

1:08:06  
we also want to replace something with Zed but not y with that, but x with a Zed and the result is nothing changes. Why is that? Because the whole thing here is lambda x. So x is a bound variable. And substitution only works for free variables, we don't have any free occurrence of x seen from outside in this term, so therefore, there is nothing to change. So what happened in this particular cases, we applied this rule, which says this case, don't do anything. What happens here, this is now the risky case. Now, another, all of these are variants on the same right now, lambda x x, y, but I want to replace y with x. That is the dangerous case, the easily you will think I take the y and replace it with x and get this thing as a result. But that's not the right thing to do, because here are binding x in this term. The X that I want to substitute for Y is a different x is a free x. So, if I did the substitution naively, I would bind the free variable by accident or by this bad thing called capture. So that is not allowed. So if we need to do is before I even go to substituting, I replace this thing with an alpha convertible equivalent, so I choose instead of x any variable set that is not free here. And well, but any variable that is not free in here, and that is one such, so I get this result. And now I'm in a better situation, I'm set in this thing to change y for x. And the result is this. And you can really see that they are morally different things because this guy has all occurrences of x bound, whereas this one contains a free x, which was exactly what the intent was here. So whenever capture is about to arise, we need to rename all variables. So here, the fourth rule doesn't always apply, it doesn't apply when y is not free and V and V in this situation, the variable y needs to be re named into something that is not free in in this minute here, and that is also different from next.

1:11:08  
Okay.

1:11:18  
Yes. Okay.

1:11:20  
I don't have so much else to say maybe, like 10 minutes worth, so maybe it's okay to go without the break with I think I have something like maybe five more slides.

1:11:36  
Yeah, that's okay. Just continue, that's okay. Okay.

1:11:39  
Okay. Now, this is the this is the formalism, it takes some effort to get used to. And it may look a bit far from functional programming, but when you think of it, it really isn't, it is it is all about making functions, applying functions. And sort of in a hidden way, it is about these laps as well. And sort of hygiene that you have to keep thinking of local variables not mixing up with with globally free variables. So, what I what I now want to still show is is a discussion of some properties that that this calculus has and significance of these things for for actual functional problems. So I said very something maybe a bit worrying a term can easily have multiple redirects use and then multiple simplifications applies what could be an example of this maybe something like

1:13:23  
if you look at the term like this, this has multiple beta redexes, multiple places where I see a lambda abstraction followed by an application. And then there are two ways to to start with a reduction to start simplification. So So hearing this term, what we see is, we see a nice thing in two places. So one is this when the whole term, because it is a lambda applied to something. Yeah. So that is what people call a beta redx. One could apply simplification directly to these guys.

1:14:02  
But then

1:14:05  
I also have another occurrence of the same thing because look here. So here, I also have a lambda followed by something. Maybe this is a lambda, and that's what it's applied to. And when I start simplifying this thing, it looks like I could potentially get two different normal forms. Let's see Is it really the case. So if I started simplifying on the top level, what I would need to do is to replace any free occurrence of x in y any free occurrence of x in y with The occurrence of x in y with this big thing.

1:15:11  
And that could give me something right? Well, there are no x's and y's. So therefore, if I do the substitution, just only wise. So this is one of the things I could do. And it finishes in one step just here. But there is the other thing that I could do, right? The other thing would be temporarily not to work in the function part at all. So this is lambda x dot y. But to do the simplification in this part, what I can also do it, namely, replace every occurrence of W in here, with V. And that would give me these letters now looks like the computation to computations go in a different direction. But actually, it's not. Because if I simplify this one further, now it only contains exactly one red X, which is this one, this lambda like this argument. As a result, I get why. And here I also got here, I also got why. So it looks like two different ways about going. And two different ways to go about things. So here I started on the outside, I took the outermost be threaded simplified it got why, in the other approach, I got the innermost Well, there is only two but in general, you could start with the innermost work with the innermost ones until there are no left. And you think you could get a different result, but you don't hear within. So a formal property that you can show is untyped lambda calculus is confluent in the sense that if you can reduce the multiple steps to you, and you can also reduce the multiple steps, this aerostat means multiple steps to V, then actually doesn't matter that you arrive the different results, because you can always find a further turn w such that you reduce this to W and V also reduces to W. So intuitively, this means if a term has a normal form, so a form from which you cannot go on, then whichever way you reduce things, you will eventually get there. Maybe I should draw a picture about this one is so

1:17:41  
incredible.

1:17:49  
So I've got the 30s, we could imagine that we do multiple simplification steps and maybe arrive at you. This is what I said. Maybe doing some other simplification steps I can somewhat arrive at To me, this looks like potentially dangerous. But what this conference says is, you can always find a way to continue simplification is such a way that in the end you receive arrive at the same thing

1:18:27  
like this.

1:18:36  
That's called Confluence. Confluence means things. So that's from Latin, right? It should be should mean that we've got a property that everything somehow flows together or flows into the same place. And yeah, pictorially This is exactly this. So no, it's not possible that you somehow have a term with two different normal forms to have a term with two different normal forms would mean that you start with the start applying the simplification steps you arrive at you, and then you cannot continue for some reason. And at the same time, there is also some other v that you can also reach for where you also cannot continue. Now, if that were the case, then both u and v would be normal forms of P with conferences, this is not possible. however far you have gone with reduction in different ways. And you can always arrive at the kind of an agreed result stem from wherever you already went. And this, this already happened to us here, right? It looked like we went two different ways. But in the end, we got exactly the same thing. So like this says it's pure untyped lambda calculus, really reduction order doesn't matter. Maybe you make more steps with a particular reduction order like here we make two versus one But the end result cannot depend on. As I already mentioned, this has an immediate consequence of the uniqueness of normal forms. So it's not possible that there can be two different

1:20:19  
two different normal forms that you arrive at. Because that directly contradicts Confluence. However, what is possible is that you have a term that you can just keep reducing,

1:20:43  
and you'll never get stuck. So that you have an unfinished reduction sequence. So that is somehow different. The uniqueness of normal forms doesn't say that there has to exist a normal form, it says, It can't be that there are two different models. So that's the disclaimer here. Although we say there cannot be two different normal forms, it may be that there is no normal format. Now, this is a very good news. And this is exploited a lot in functional programming languages in exactly by making evaluation strategy deterministic because since you cannot possibly arrive at different results, then in some sense, any reduction strategy should be good, because it's guaranteed to give the same result, then you should maybe choose the reduction strategy based on some criteria of of like performance optimality, rather than have that it gives or doesn't give different results. However, this is not the full truth. The full truth is that in a real functional programming language, you have the effects like maybe printing and then different evaluation strategies give different effects, and also different normal forms for the same term. Maybe the simplest example of this would be something like you have a language with printing, and you can maybe do stuff like I want to add together, print five, followed by he did want to do the following, I want to print hello followed by five and add these together with print

1:22:47  
weld

1:22:50  
17.

1:22:53  
Now,

1:22:54  
this is a programme that should give me as a result 22 but the reduction order matters. So surely, I cannot add any numerical value expressions together before I have evaluated them. But here there is two to evaluate the first one of them gives five the other one gives 70. The first one first prints Hello with the second one first prints

1:23:21  
world.

1:23:22  
So if I started evaluation here, this would print hello, and return five. And if I then went on here, world would be printed and 17 would be returned. And then we were able to add five and 17 together The result is 22. But on the screen you see hello world. However, if you started on the right, that's also possible then you would get well printed on the screen 17 returned you will go here you will get Hello printed on the screen five return venue at five and 17 is still in that order, get 22 but on the screen you see two different things. So as soon as your FB language has effects, maybe printing but maybe even simpler things such as exceptions. And different evaluation strategies can give different effects and also a different normal form for the centre. So then it's no longer true that you will have Confluence and uniqueness of normal forms are made you have Confluence to the degree that the final returns results are the same, but the effects produced during the computation are different.

1:24:47  
Then, I should say that I already gave the warning that not every computation needs to terminate even in such a simple language and So therefore you cannot assume or think it would be easy to show that every time has a normal form. It's simply not true. Not everything has a normal form. And here is an example. It's usually called omega capital a Greek letter omega term is here. This is without a normal form. Why? Well, first of all, it's not itself a normal form because it is of the form a lambda applied to something. So it's clear that I can apply a simplification step right? Then let's try to apply the simplifications that if I apply the simplification step here, what does it say? It says, I have to take the three occurrences of x in here of which there are two, this and this and this. And I have to replace both of them with the actual argument provided to the function in the core. So here, here is the parameter using two places. And I have to pass in the actual argument. But the result, when I replace both of the axes with the same thing, is again, the same thing. So I made a simplification step, but accidentally arrived at the same result. But now, of course, I'm in a loop, because to this guy, I can, again, apply the very same simplification step. So at any stage, exactly one thing I can do, but this is still a thing I can do, and it takes me back to the same, so I can never finish. So the computation can always go on, nothing is a normal form. Okay, this is the simplest example of this kind of computation. And it's maybe a bit futile because nothing changes, you can also write terms that don't have normal forms, but where at every stage of simplification, something new happens. So this shows that this test of power, okay. And now, what is also important to realise is that if a term has a normal form, it doesn't mean that every evaluation strategy will find it, I can also have a term that has a normal form, but some evaluation strategies, that is to say reduction orders find it, and others don't.

1:27:29  
We could think of this term for example. Yeah, this one contains two beet red X's one is inside omega. And that's the one we wanted to see. So this omega is like this. And it clearly contains a lambda apply to something, a lambda is here.

1:27:53  
But then there is another one, which is the top level thing. So here, there's also a lambda applied to something which is omega. Now, if I were to first deal with the top level, the outermost red X, then it will replace every occurrence of x, y O, which there are none with omega. So therefore, the result is simply y, similarly to actually what I showed here, and the path, and that's clearly a normal form, and I'm done in one step. But if instead, I chose to apply the simplification instead of omega, then of course, I know that omega in one step goes back to omega. And I haven't changed anything. And now I can work with all my data again, and I can go on and on and on. And this one will simply not finish or not terminate at all. So there are two maybe canonical evaluation strategies. There are all sorts of intermediate ones as well, but these are sort of the two extremes, one is often called normal. This means given a lambda turn when you want to simplify it always take the outermost leftmost red X first. So you prefer big red X's to small ones or you prefer red X's closer to the top level of the term as compared to going deep inside the term. And if there are several that are not contained one in each other, then you take the left that the one that is more to the left, the left most of them so that's called normal evaluation strategy. There is also the applicative evaluation strategy which says, when there are multiple radix is always take the one that is that is inner innermost. And if there are multiple sites, then again, the leftmost one of them so in our most red X is one that doesn't itself contain any further red X's and if there are multiple such pick the left most one of them And then this is something that you can find out when you think about it for any term that has the normal format or the normal That is to say the left most popular most devaluation strategy will always find it. So, here Actually, we had a normal form, which is why and if we started on the outside the leftmost outermost actually find the payments that the applicative one is actually very important in actually functional programming, especially in the context of effects you may want to prefer it. But this may generally fail to terminate, because it's very eager. So, when there is a function of like an argument before it starts evaluating the function application, it wants to fully evaluate the argument, but here the argument sort of goes in an infinite loop and this goes on forever, but if actually you worked with to look closer at what the function application is, you see that the argument is never needed. So, why then work on it and this is what the normal evaluation strategy finds out? It tries not to even look into the argument before it puts the argument in place of of parameters. If the argument is not used, then you will never go and evaluate the argument if the argument is there not the point thrown away as happens here.

1:31:32  
Okay,

1:31:33  
and that maybe is it for today. So, what did I say? So, there is this little formalism called lambda calculus with only three constructs, variables, applications abstractions, that captures a lot about functional computation. So we define what terms are, then there is the notion of equal terms given by alpha convertibility, which sort of formalises the idea that local variable names don't matter. But Aleutian confusing then there is computation which goes by normalisation trying to make a term normal by applying the simplification steps called data reduction steps. And then I said, pure lambda calculus is conflict reduction order doesn't matter. As long as you just want to ask which normal forms there are, there can never be more than one normal form. However, a caveat is there are terms without normal form. And there are also terms for which some strategy finds a normal form. So they do have a normal form, but some strategies to find it and other strategies don't find it. The most successful in terms of finding the normal form is the leftmost outermost evaluation strategy that will always find them all for me. And that maybe should be about

1:33:17  
questions.

1:33:22  
I think it's quite clear. I don't have any question I think. I'm afraid I have to talk to you a bit more with his former staff by showing next time how types go. And the main message there will be the types will remove as long as we don't do polymorphic types will remove the possibility of non termination. And they also sort of the more intuitively nonsensical terms. So there is a bit more to say, but it is more or less. on the same level, I don't go deep. I'll just show you the typing rules. And I comment on a few properties that the type system has.

1:34:09  
Okay.

1:34:13  
If there aren't any questions, maybe we

1:34:17  
are recording here.

Transcribed by https://otter.ai
5:06  
Okay, Hello, can you hear me?

5:09  
Yes,

5:10  
very good. So,

5:16  
good afternoon

5:20  
continue today a bit with lambda calculus which is something I started last time what was this about was about the basic core formalism for functional programming, which if you wish, every actual real world functional language is some sort of syntactic sugar on top plus added conveniences plus maybe some deviations from the sort of very strict underlying discipline that I was a big part explaining last time and they will continue explaining today. So, what we saw last time was untyped lambda calculus, which is this super minimal language where you can only write expressions also called lambda terms that only can cost consists of feet, three things namely variables, applications of functions, and then this basic mechanism of making functions that we also called anonymous functions before that we write fun in F sharp and that is written lambda in lambda calculus and nothing else, just the bare bones. And then we looked at a few examples, I explained how computation goes there, in the basic lambda calculus, there is quite a bit of freedom. Regarding this in a practical functional programming language, you exploit the particular or you choose a particular evaluation strategy, the one that is used by F sharp

6:54  
is

6:56  
strict, which is in lambda calculus notation corresponds to innermost evaluation strategy. So, let me recall a bit of this and then we go on today to type lambda calculus, where we add a bit. So in addition, for the ability that we can write expressions, we can then also write down types or type expressions, if you wish more precisely, and that one is also super minimal, you can only write two kinds of things you can write down basic types that are assumed to be given. And then you can form functions basis of them. So if A and B are types, a arrow B is a function type, and nothing else is allowed. So you don't have any, say paired types or list types or option types are so we will like to generalise a bit further and go to polymorphically typed lambda calculus, which is also quite minimalistic, but this has the peculiarity that you can actually code up quite a few data types. And we'll see this in action. Okay, so let's get going I'll share my screen Firstly, they just share a window. So, yet only to recall, what I showed to you was that we have this untyped lambda calculus in which you can only write these three things variables. This is what in F sharp is written phone x arrow t are fun X lt to define T, the expression to be a function in x, which is a variable that hopefully occurs somewhere in T for this to be useful. And then finally, a function application t you where t is an expression for a function, and u is an expression for the argument. And then I explained that this is very liberal in the sense that you can write things that feel very suspect, like applying x to x, which is a bit like applying a function to itself. How can this be. But untyped lambda calculus allows this simply typed lambda calculus forbids this. And if we go polymorphic, we can already start to do things like this again. But there they make sense because the idea is that x can be something of a polymorphic type and then as the function if there's one type, and there's an argument that might have another as instantiation. Okay, we talked about terms. I said that we really don't need left here. I told you about which terms are equal, considered equal or alpha convertible, that was the idea that bond variable names really don't matter. And you can change them if you're systematic about so here. For example, x is replaced with exprime systematically throughout. But there are constraints about this. Namely, you can't create capture. So you cannot rename various variables in such a way that the free variable becomes bound by accident. Then I explained the computation mechanism here, which was going in small steps like this, the small steps were called beta reduction steps. And you just apply these steps as long as you can, in principle, non deterministically If multiple steps are possible, but you may choose a fixed evaluation strategy, and then this is determined the next plane what beta reduction was, basically, it's about the following thing. It is a sort of a description, which says, if you just made the function, and then you applied, what does it really mean. And all it really means is the argument is passed to the function through the parameter, right, what else? So, the, the outcome here should be you with the argument, lambda x t is the function that you take T, and everywhere where you see x occurring freely, which is a sign that it's about this x, and that lambda x binds here in t, then you just replace x with you this was the notation for substitution. And then the further rules say that you can't only apply this on the top level, but actually, you can apply it anywhere inside a term. So, for example, lambda x t simplifies to lambda x t prime, provided t simplifies to t prime. And the idea being that this itself is not

11:50  
something that you can reduce by this rule. But maybe tea is such a thing, or maybe tea contains further such a thing. And similar things apply to application. So, you're allowed to simplify both the function and the argument by the rules. And then I gave you some examples, I told the closer how substitution works. And it does pretty much what you expect, except again, you have to avoid captures, you have to be careful when you substitute so that you don't make a free variable bound and I talked about it at length, I won't repeat it here. Then I told you lambda calculus has some particularly nice properties. These are important to remember. One is called Confluence, the other one is called and that's on the next one no further, okay. So, let's take one by one, one is called conference which says, If I can reduce a term t to one term you using some number of steps, but I can reduce the same t also to V, then this and maybe u and v are different terms, then this is no sort of a repairable disagreement, because I can always find the term w such that both o u and v reduced to W in one zero or many steps. So aerostar simply means no steps at all once there are many steps that is a good property. For Confluence by the word is from Latin it means things flow together or to a common sync, so to say, when I told you that an immediate consequence of conferences uniqueness of normal forms, so for any term, if I reduce it into a way that gets stuck in the sense that I cannot reduce further this thing is called the normal form. And from conferences immediate that if there is a normal form that can only be one for a given firm, then I told you that not everything has a normal form. And then finally, I told you about evaluation strategies. That was the last point last time What did what was it about? Well, first of all, in any terms that can be multiple places, where you find an abstraction applied to something all of these are good for reduction. We can choose to pick whichever in general lambda calculus, but under a particular evaluation strategy, I might want to say that I prefer red X yeah irreducible expression like this, which is outermost, which means in the sense that it is not the sub term of any other term that is also red X. So if you take some outermost red X, for example, the leftmost this gives you a normal evaluation strategy, so called if instead, you reduce the leftmost guy at every time that's called leftmost, innermost These strategies are different in that the normal form always sorry, the normal evaluation strategy always finds a normal form if there is one at all. But the applicative, one may miss it. And the example was this term here, where see where omega was a particular term, that in one step reduces to itself. If you use the normal evaluation strategy, all that happens is omega is passed to this function via the parameter x, which means all occurrences of x in y of which there are none get replaced by omega, so we don't get any omega is actually only one is left. And this is a normal form, this is just a variable from here, you cannot go anywhere else. In one step, you have reached a term that you can't reduce further. But the applicative emigration strategy, which looked for the innermost radix, finds the red X inside omega, which is deeper than the top level thing. It finds the red X here, and they just rewrite it into omega itself, which was something that I showed last time. So, in one step, I rewrite the term back to itself. Obviously, in the next step, I can just repeat it and then this goes on forever. And nothing useful ever comes out. That was the end of the story. There. If you weren't in the class, then please do check, because this is important. But now we go to today's topic, which is lambda calculus again.

16:47  
And we add very, very little and then I'll give you a lots of examples of this. So what do we add? Is types. So what is going to happen? In addition to terms, we will have types? And it is a bit like we've seen in F sharp now I'm just making it all a little formal, a little more formal? Yeah, what is the idea of types, the idea of types is, is to tell you something about terms like, you know, this term cannot be arbitrary. I don't yet know what its value is, maybe there's an integer, right? Or I don't get know what what the value of my term is. But maybe I know that this is a function from Booleans, to lists of integers. This is what pipes are, they sort of classify the values a term can take, that is the main idea behind them. This is also how they used here. So they have kind of a discipline mechanism to make sure that everything in a sense, makes sense. Yeah, so you're not mixing apples and oranges together. So if you've got the function that takes oranges, as an input, you will not offer apples, or you can detect that this is happening. Or someone is trying to offer apples to a function needing oranges, just on the level of checking the types. Okay, so term in general is typed with a type. But typically, this cannot be figured out just like this. But this actually depends on what types we want for the free variables unless we looking for something like the most general type. But the typical way that you think of it is you fixed what the types intended types of the free variables are in a term. And that should determine all the rest the types of all sub terms up until the top level term. Now, what are some examples of this? The idea should be something like, when you see a function, lambda x dot x, then that should actually perfectly well work with with Type A arrow a for any type A, where a could be any specific type, like I don't know a type variable or some function space made of two different type variables, etc. So we think of these type variables here as the basic types are here is another one, lambda x lambda y dot x in an F sharp with write phone x arrow phone, why Arrow x. This is a function that takes something of type A followed by something of type B, and returns na. And that actually works for any types a and b. So let's be precise. So these are some examples sort of on an In formal level, but now let's make everything precise. So what is a type and how are types ascribed terms? So first, what is a time? Here, we only allow two kinds of types. So the basic building blocks are type variables. In an actual functional language, real functional language, you will also have some base types like maybe interval or float, but here we don't hear as the basis, we just use some type variables. So they basically stand for any type you could consider. But then, another kind of types is function types, these are types of the form a arrows B, where a and b are already types. And therefore, sorry, where a and b already are types. And this stands for a function where A is the type of input and B is the type of the return value or is the type of the argument these the type of return value.

21:09  
So, similar to similar to similar to so untyped lambda calculus, we have to make some electrical conventions. So, there we agree that application always associated to the left and lamda extends to the closest closing parentheses. In lambda calculus, the important thing as we've also seen in F sharp and that's adopted in most FP languages is that this one associates to the right. So, you may write something like this. But the idea, then behind this, this so, when, when that is when you see two arrows in a row, and there are no parentheses, this means the second and the third guy are taken together in parentheses together with the arrow, the first guy is separate. The idea being here always that these are these curried two plays functions.

22:27  
So here,

22:28  
you say, I've got a function that first expects an argument of type A, and then it already returns something but that is, in turn a function that is happy to accept another argument of type B. So you can use this beast as, as a two place function, or as a type of to place functions with return type C, but but the arguments have to be given one by one not as a pair, isn't it? Okay, let me let me try to give you a few examples. But I need to know, used to Windows

23:19  
different differently.

23:32  
So that's almost good. So some examples of types, for example. So I'm saying we've got type variables, so things like

23:50  
x perhaps, or y would be types. But then also, you can start forming other types out of them. So I can, for example, say x equals y is a type. But I can make more complicated types. Now I can say x arrows, y. arrows, x is also a time. So any of these things will be a time if I just use arrows in arbitrary ways. So different matter what, what kind of terms leave there, as we'll see in very short as we will see very shortly, right? And then the convention is, you don't need to write or parentheses. So for example, here, the parentheses are actually unnecessary. Because, sorry, here, the parentheses are necessary. But these parentheses here are unnecessary because arrow associates to the right so I could, in principle, get rid of those and that would amount to the same thing.

25:07  
Okay, now and this is all the reason is simply typed lambda calculus right you have to take into account that in a real FP language there will be some base types and typically some other type constructors beyond arrow like in F sharp what we know, where we have star, for example, for tuple types for pair types, triple types, quadruple types, I mean any any any tuple types. And then also we have the unit type, which is kind of Mallory types. And then we have lists etc with those we could already see are kind of almost like user defined data types with special syntax. But then also you need to have a mechanism for these user defined data types, which we don't have directly in simply type Okay, from where do terms get types and that goes by rules. And this is something I will have to explain in some detail. The main game is to fix some rules, when can I say that the term T has a Type A and the term T will not have a Type A absolutely if it contains free variables. But then we assume some type environment here called gamma that fixes what the types of my free variables are. So, this gamma here is often called the typing context. And it's a list of typings for individual variable. So, I might want to say that x one is of type a one bla bla accent is of type A n where that indexes are sort of term level variables and a one through a n or any types in principle can be anything this symbol here is kind of a horizontal tea is called turn style. So that's an English word that is maybe not used too often, but it is this thing. For example, in a in a food store, that is often there when you collect your basket and you go through a narrow place something turns around then you can enter the place is called turnstile in some countries, you also have a like I don't know pastures for for sheep. So, people can enter gates, but but obviously bigger animals cannot there are leap Okay. Now, we want to establish these kinds of judgments that the term has type A in some type in context gamma and we want to give rules for this what are the rules lambda calculus is a minimalistic formalism. So is typed lambda calculus about here these are all the rules there is nothing else. So, what are they the only way that the variable can be of type A is that the environment tell so so the environment is a list of assignments of types of variables, and among them, there should be one that says x is of type A, if I want to conclude that x is of type A at all, okay. abstraction is another case. So when is an abstraction of some type abstraction always is of a function type. And abstraction is a function from type A to B in context gamma, if I can establish that T, the body is of type B, in the context gamma extended with one further guy, namely that x is of type A. So if, under the assumption that x is of type A, we can freely choose what assumption we want to make. But if under such assumption, we do get that t is of type B, then we can be sure that in the original gamma that doesn't have this extra Association, we can compute that lambda x t has this time. That's the most complicated rule here. So, here we see a new thing that you also saw in lambda calculus, what does this horizontal rule line here mean? It means you have to read this thing as a rule. If the thing above the line which is often called the premise holds, then the thing of below the line which is often called the conclusion

29:57  
holds,

29:59  
so, If you already established this, you're allowed to say I've now also established this. These are called rules. Okay, and here is another rule. So what is my only rule for ascribing any type at all to an application, which generally then is of the form t apply to you in some context gamma? Well, if in the context gamma t happens to have type A to B, or you can justify that in such a context T has type A to B, then it better be that in the same context, the argument has type A why, sorry, sorry for the blinking. Why? Because the application can only make sense if the functions argument type and the type of the actual argument. They do agree, right? They have to be the same. And then what's the type of the function application or function call as we also call it? It is just the return type of the function of course, yeah, it should be sort of intuitive. But, but the way that you can formally talk about these things, goes goes by rules, which is an idea actually inherited from formal logic to sort of programming theory. Let me give you some examples first on slides, but then I can write them as we go. So, how do I justify that lambda x dot x has type a way where a here is kind of a schematic letter for any type, it could be x, it could be Y, it could be x arrows, y any any type fits here instead of a to age like a meta variable four types? Well, by my rules, how do I justify such a thing, I have to make sure that the bound vary that if I make an assumption about the bound variable with with a given argument type, then I can conclude that the body has the given return type. So, these things are what I need to check. So, let's see. So let's let's, let's make it as an assumption that x is of type A and let's try to conclude x is of type A, that looks trivial because surely x must be of type A, if we assume x is of type A. And indeed, this is the case, not only sort of intuitively, but because we have this rule, which says I'm allowed to conclude x is of type A, if somewhere in my context, that's like the lookup function right? In type inference, as we saw in F sharp, I can find that x really is in my dictionary, and it has been ascribed to type a. So here is a bit more an example that is a bit more complicated. And you can see that what starts to emerge here are what are called byte derivation. So these are formally they're like trees of judgments. Were always the children of any node justifying the parent. Like here, I've got n. So this is a tree that's the route Yeah, there are various nodes and every horizontal line stands for branching. Most branching is unary but at this place, there is a binary sorry, this place here that is binary branching, because this

33:37  
rule,

33:38  
sorry, this concludes this judgement is a conclusion of the rule with two premises. So both of these are sort of children nodes. And of course, they also the corresponding children sub trees, which are very shallow. Okay, so you see, trees emerging, and these are called derivations. And at every stage, the children justify the parent. The fact that we believe in these two justifies that we now accept this but the fact that they've already now accepted this justifies that we also want to accept this the fact that we now have accepted this justifies that it's also okay to accept this. Okay, so this is how you read these trees from top to bottom. At any line, in this rendering of the tree, the lines immediately above which are the children nodes, they justify the given line. You can read these trees, top to bottom, but actually the search for such trees are the construction of such trees goes bottom up, or root first, as people call it. swell I'll develop the interactively for your venue when you see what I mean. But let me first still show this example. So what does it say? That is actually the pipe function of, of, of F sharp, right, because in F sharp we have this thing where I can write, sorry, x f with this funny operator notation. And that one is actually defined, like f applied to x and circle the right left here. And then, but of course, you can do it as an anonymous function. And then we need to just talk about which my variables are and it will be like, in F sharp we would write fun, x arrow, fun. F. paddle FX is also allowed to write shorter fun, x f, f x, but that's the same thing. Now, in lambda calculus, the corresponding thing is just this, which is not so far apart from

36:15  
what we see here.

36:18  
Okay, how is this justified, it wants to have this type A arrow, a arrow B to B, and I've put in these parentheses here, but they are not strictly speaking necessary because of the right assertion. So it really is really like a two place function that takes two arguments, one by one first this, then this, then this gives back this. How do I justify that this is actually a valid typing? Well, this is a lambda. So I put the lambda bound variable with the correct time into my context, and I try to check that the body here has the correct type, which has to be the return type here. Yeah, so let's test to see I'm reading the tree bottom up just to kind of show how I would come up with such a tree. So if I know this is the type that I want to have, then for checking, it suffices to go like this, that as the first step, I say, Okay, I need to see this, then how do I see this? This is a similar game. Now, because I've got a lambda that I want to take with a certain function space, what I need to do is throw this lambda bound variable F to my context, my context grows, right, you can now there are two variables that are free. And then only the body has to have the return type of the function that is the now this line here, is quite different from the from the two below it, because no, I'm not piping alanda. Now I'm typing an application or a function call, at which place I have to be able to somehow say, well, in the industry context, which I use in both cases, sorry. notes into writing, in this fixed context that I want to use in both cases, I have to on one hand, give a type for the function, which is F. And on the other hand, give it time for the argument, which is x. Well, the argument is a variable for this one, it's not actually so hard to give a type because the context pretty much gives me a hint, what it could be, like the variable type doesn't occur anywhere here, this B doesn't give me any clue what the what the type of the argument should be. But from here, I could get a guess that perhaps it should be a. Okay. So x of type A, but then this is to say that the argument type of the function is a and the return type is B. So we really need to check that F has type A arrows B, but it actually also has because in the context, we have already said f has type A arrows B, and therefore we are done. So these two lines are justified by a rule for the variable case, which doesn't have any premises. So here we've done these are like leaves no premises. This was justified by the application case and the last two were justified by lambda cases. There is nothing more often, I don't know students are confused maybe because their notation fields

39:55  
new

39:57  
or unfamiliar, but there is really not a lot going on. So one thing that this kind of type discipline avoids is you can't possibly give types to the nonsense terms like the Omega from the last lecture, which was defined like this. If you're trying to invent any type for it, you'll find out to pump can we can later maybe discuss it a bit more, why?

40:24  
Okay, here.

40:29  
And there is a further example of pipe assignment, but maybe I should actually do it sort of interactive instead. So let me just copy the last line. And then let's look at it as it develops lambda x, lambda y lambda

40:48  
x, y Zed.

41:08  
Okay,

41:09  
so I want to do this. And now rather than showing you the example, I'll show you the rules.

41:19  
So,

41:20  
this is the example we want to develop these are the rules of the game. So, how on earth can I derive this thing? Well, this is first of all lamda. So, I only have one choice I have to say, I will work with a context where now the lambda bound variable is my only assumption that they may it's the assumption is x is of type A arrows B arrow C. And then in that context, I need to derive lambda one lambda Zed x, y, Zed, which will have to be of type a aerobie.

42:18  
Now what can I do next? Actually, I'm in a similar situation as before, because this term here, this one here is actually lambda. So I have to say, I know want to extend my context with y, which is the lambda bound variable and there I will put the knowledge that I will now assume that y is of type A or ob, whereas the body is of type A arrow C. So this is what happens next.

42:57  
Sorry.

43:06  
Then I draw the turnstile sign. And I will have to say that the rest of time. Yep. What else can I do now? I'm still in a similar situation, because there isn't yet. You know, there is yet further lamda to deal with. So what should we say? Any suggestions? What needs to go to the context next with what type?

43:46  
Just shout. I will Meanwhile, right? Or the part that is already there.

43:59  
Now what else do I need to say? The number one variable is Zed. Right, so I'm now gonna check if I can type the body with Type C, under an additional assumption that Zed is of type A, isn't it? What is the body? The body is everything else I see here. Namely, fix. Now we're in a new situation. Our term on the top level is no longer a lender. But it is an epic application, isn't it? So I have to use the rule for application which is this one here. That is a bit more interesting. And that is perhaps I'm guessing to be done. Actually

45:15  
a little bit differently.

45:20  
Let's give this thing a name. The the current context, I'll call it gamma, then we will have less to write in the future.

45:29  
So let me call this gamma. Yep. My task now will be to show two things. On one hand, that gamma, derives, exit in some function type. Because that's the function here. And on the other hand, I also have to say gamma turns fine.

46:01  
Why is it in some argument type? About the function type, I actually know pretty well. Sorry, not about the full function. So I know the return type, the return type must be seen, isn't it? Look here, the conclusion is B. So therefore, in the first premise, I also I need to have a function space. And the return type must be B. But I have no idea what the argument type should be. I only know it has to be the same as here. So maybe I just put question mark for the time being.

46:43  
And then we'll see

46:45  
if we can do any better. Maybe now we already can, because here is the function application again. And what do I need to make sure to pay for this thing to have a Type B, the function has to have the type eight arrows B for some suitable a, and then the argument has to be of the same type A. So let's check here in gamma, I have to have some type for y in gamma, I have to have some type for Zed. And then I will be done. Within What are these types? Well, in gamma, we actually do have a type for y, which is a arrows B. And then by the variable rule, we can actually use it. So we can say, we know under gamma that y has this time. And actually gamma also contains Zed. You can see here and ascribes type eight with. Okay, then we are actually with my two premises, we are in exactly this form that the function here has of pi as like a barrel B, and the argument has type A, of course, the coincidence of letters is purely coincidental here, and therefore, the results should have by B as well. So now I can make my question mark, I can be more precise about my question mark, people have to be and that one was the question mark for the same thing. So that's also be okay, so we're in a somewhat better shape. Now we have to still finish this part here. So we have to check everything is good here. So that's again, an application. So let's see, in gamma, I have to ascribe the type to x and also to set and this will go by variable also here, we will already be done. Now, x is of type A arrows B arrow C in gamma. So there is no choice about what the type of x can be.

49:11  
What a set has type A in the same context that's visible here. Right? No, I'm making a mistake somewhere. No, not making a mistake anywhere. It's perfect. Now, because the argument type is a, the return type is voc. So therefore, the function type is a arrows B arrow c, where you can think but you don't have to write that the parentheses are here. Yep. Is this agreeable. This must be what is actually on the slide than done in exactly the same way. Okay. So, this is kind of an exercise by complaint with

50:05  
I will

50:07  
do more of these right now, rather let me say tell you two properties about this type system and then we can take a short break. So, one very important property of this type system called typed lambda calculus is what is was historically called subject reduction property. These days people like to call it type preservation property, which is maybe more telling this means that these simplification steps by which computation of terms goes called beta reduction that we saw last time, these preserve the type of a term, what do I mean? I mean, if t takes type A in context gamma, and you can simplify t in one step to you another term then you must also take the same time. And this is a super useful property, it basically says during computation types of things cannot change. So, therefore, if everything was well typed, you know, if your programme was well timed, nothing can go wrong with it type wise during computation during execution, so to say. And in practice, this means that you never get these kind of methods not understood or wrong function argument type messages because typing is exactly about this, it's fundamentally about making sure that if a function expects an argument and is given an argument, then the arguments type agrees with a function type. This is pretty much everything that that that the typing is about I mean, there is more Of course, when you have polymorphic typing, then we also talk about type instantiation, etc. Like if you use a polymorphic function, you're really using an instance of it, you have to form correct instances, but we'll get there. So, so this is a property that is required in any reasonable timed FP language. It's called subject reduction of type reservation. The name type reservation is pretty obvious from the statement that you have a type you reduce, and the same type is preserved. Subject reduction comes from an older terminology, which was like if you wish from ganar. Sometimes the term in such a piping is called the subject. And the type is called predicate like in natural language, if I don't know when you say john loves Mary, then john is the subject and loves marries the predicate. So here the same idea. So it's about reducing subject, and keeping the predicate so to say, That's the meaning of the word. If it sounds strange, it does sound strange. Okay, that's one property. And the other one I wanted to show is, that is what makes typed lambda calculus radically different from untyped is every term has a normal form. So you can't write nonsense terms like omega, where you're trying to apply a thing to itself, which is then funny, chasing your own tail, if you wish. And not only has every term a normal form, actually, this type lambda calculus is strongly normalising. And well, one way to see it as soon as you know that every firm already has a normal form Previously, we said reduction or evaluation strategies don't matter, they will all give the same result. So now if you know if one of them gives a certain result, they all must give the same. So the calculus is strongly normalising, which means whichever evaluation strategy you will take, will compute exactly the same normal form. Now this sounds like the best place to be and kind of Garden of Eden but there is still a trade off here because it's sort of is a is a very nice, safe haven Nothing can go wrong with computations here. You can take whichever evaluation strategy you please maybe driven by some performance considerations and which one you can implement better. But sadly, in real typed FP languages, even if they're strongly typed in languages like F sharp this this Prop, these properties are lost. So, it may very well be that sometimes terms may reduce infinity. So and then therefore, not not not reaching normal form in a in a in a reduction strategy. How is this possible? This is possible because very often in such languages, you have some general recursion mechanism as primitive Like I explained, last time that you can express left via just lambda terms you don't really need left. If it's an ordinary left, also function left but as soon as you have a recursive function that is a different game, recursive function lead cannot be expressed in terms of other constructions in a pipe language. So if you want to add it, you have to add it this primitive. And then it's possible to add primitives with their own reduction rules such that these these new primitives, they give you non non terminating behaviours, terms that reduce infinitely. So that's something to keep in mind. In real languages, you have recursion given by lack rec, or loops or some other such Turing complete mechanism. And then these properties lost. Which is good for sort of universality of computation point of view. But it's bad for like, sort of clean software engineering point of view. Okay. Another thing that also happens in real life is this nice result, the different evaluation strategies give you the same normal form. They also don't hold or sort of more finer, they can give you different effects, especially and therefore also, in some cases, different normal form. In the end, especially if there is something called effect handling present, like handling of exceptions. So we saw this example, last time I showed you addition together with printing, so if you there have a different evaluation strategy left versus right most, you don't get things printed out in a different order, even if maybe the final number that your addition returns is the same. So it's the same, of course here under the type discipline. So you could say, yeah, this is weaker than via languages, but in some sense is good, because it isolates a very sort of strong core, or a very safe core. And then you can add little other features, one by one, making sure that you don't go too far from this sort of safe at the end nicety so that you really have strong properties of your language in terms of what you can guarantee. That's how much I wanted to say before the break, but do you have questions perhaps, because if you did, you'd be so nice to discuss. Let me check what is going on here in the real world. Can you give me some reaction of any sort.

58:16  
This we're still here.

58:18  
You're still there. That is good. That's good. I'm also here. I don't want to do so much else. After the break, which could perhaps be until 320 I want to add polymorphism. I want to talk more about this topic next time showing what you can use it for. But but for for this time only just show you what changes. If you allow. So generalisation and instantiation of types, you can then type more. And all these funny things come back that were not allowed before, but but it's still a far more discipline settings and then pure untyped lambda calculus without any typing discipline on top of it at all. Okay, so if there are no questions, let's take a break maybe five minutes until 1720 and then maybe you can continue for another 2025 minutes.

59:33  
Okay. I'll be back in five minutes. Okay let's continue where we stopped here, let

1:04:46  
me share Sorry.

1:05:08  
Yes. This is what you saw before. We finished off with simply typed lambda calculus, just type variables functions basis. And I told you, the ideal system is strongly normalising, which means whichever evaluation strategy you will take, you will reach

1:05:32  
a normal form with your term. Now let's do polymorphic lambda calculus. This is also called system F, this is a historic name, and doesn't mean much, maybe f was for functions.

1:05:57  
It goes a bit closer to the F sharp type system and actually goes beyond it in the sense that it's a more expressive type system. Now, when it comes to generalisation and instantiation, works under a very liberal discipline. So in system F, we are allowed, in addition to just type variables and function types, we can have types of this format, I have to explain this. A is a general type, x is a type variable. And this upside down a is called for all i think it literally stands for all the A stands for all. And you should read it as you know, something that's like a where a contains x, and instead of x, you're allowed to put anything you can think this x is in tool, whatever some other functions face. But of course, we don't have int and bool here, but but but for x, you can put any type. So this is a way to say that what you've done is is fully General, in some sense, we have it but only on the top level, in the in the in the calculus that we already had. For example, here, we concluded that we have this type for for our huge term. But really, if you think of it, we don't use anything particular about the types a and b and c. So a in particular could be maybe x or x and B could be x arrow Zed and see could be Zed, everything could be anything. So literally, in some sense, this thing has a much stronger type, it has the type for all x for all y for all Zed x arrows, y arrow said, arrows, x arrows, y arrows x arrow Zed, we could say we've actually established this because we've not used anything in particular about A, B and C at all. But this is kind of an uninteresting form of polymorphism because it's only on the top level. So we can say okay, my mind I can I can generalise the type of my term. But kind of, but I cannot internally use anything in my term that I would have thought of as polymorphic. This changes in in polymorphically typed lambda calculus, because now I can write different types that use this for all all over the place. So for example, I could write things like for example, the following could be a type, I could write a type that says for all x, x i was x arrows.

1:09:01  
What do I want to say,

1:09:04  
for all x x x equals x, for example, so that's different, because now I can use for all also deep inside my, my my my type expressions, right? That is not in any sense allowed in when just simply tackling this polymorphically typed lambda calculus allows us will now see examples of this. So what happens here is on the level of piping rules, we only add two new piping rules. And these are interesting and maybe dangerous sounding, looking piping rules because previously, for every term construction, I had a rule for variables. There was one rule for lambda abstractions, there was one and for applications there was a third and you could clearly see See, if you constructed the type derivation when to apply which rule because the shape of your term, you know, the topmost constructor will tell you that, sorry. This is not the case here. So, if you look at these two rules that we now add in both cases, in the conclusion, I have a general term t about which I make no specific assumptions. Well, something is specific, though, so, so here I have a for all in the type, so the rule only applies if you really bottom up when when the type is a for all type, the universal type then, when am I allowed to, to conclude the T has time for all x a, you're allowed to conclude it when actually T has type A. And remember, a can contain x, when x doesn't occur freely anywhere in gamma. This basically says, I'm not the X in my type is not constrained in any way. So, therefore, it is meaningful that I say, you know this T has typed this type for all x. I will see examples of this in a sec, but let me just comment the other rule. The other rule is kind of for the opposite. So, this one is called generalisation, maybe I should have written it down, because you say T has a type and now you say it has a more general type. And we saw a bit of this in in the F sharp polymorphic polymorphic type inference. Now, I'm essentially sort of explaining what is going on for me. The other rule is what corresponds to instantiation. It says, if T has a very general time for all x a, then it actually has also all of these instantiations that you can make of it, which you can obtain by taking a and replacing x with B. And doing so, actually, you're not supposed to accidentally bind any free variable in B. So I should actually say this rule also as a side condition that the free variables of B not bound in a don't get boundary. Okay. So, what are some examples of this, maybe I should just write here on the side. So, I could for example, have something like this. So, if I have established for example, my gamma perhaps says I don't know why gamma perhaps says some x is of type for all, capital X, X Arrow x. Maybe wine

1:13:13  
has the type

1:13:17  
maybe just for all yy with with crazy, but it's okay. If in this situation, I can establish that some type T

1:13:33  
have it has the type say that URL w then I'm allowed to conclude that I can put the universal quantifier in front of the set arrow w so in the same context

1:13:50  
I'm allowed to conclude tea has type say for all that said no W and maybe I can even further generalise and say it also has type for all w that sort it is a capital X.

1:14:34  
So these are allowed generalisation steps, but of course here T has to be something specific and here there must be some sort of a justification why it has this type. So this is valid generalisation. Why was it valid? Because Zed or w didn't occur free here. So if that were free here, for example, Hold on,

1:15:01  
let me find this

1:15:04  
guy just feed it to a charity. So suppose my type here would have been zap arrows x. Now you can see that the type variables that is free on the left. Now I'm not allowed to do the following. So this will not be okay. I cannot conclude

1:15:47  
let's now T is of type for all W. Because that is there is now not free for generalising, because we actually make some assumption about the type set, we say there is a very, very, very variable x depends on some set, which is free. Yeah, so it's controlled independently. So to say that now here at this point, we want to privatises that, and at that point, this that would be a bound variable. Whereas this set is still a free type variable. And then it will turn out that the type of little x, which is in terms of the capital Zed and the type of little t which is in terms of also the capital Zed but somehow a different one, then they would have nothing to do with each other, but T will reasonably contain x, I mean, T is not just the variable here these a name for some big term, then, this is no longer justified because morally these two sets now are different after this step.

1:16:57  
Okay.

1:17:00  
So what are some properties of this calculus? a crazy thing is that you can now type quite interesting terms, among others, this famous thing that is called self applications, you're allowed, for example, to type the term lambda x, x dot, sorry, lambda x x applied to x. Yeah, this sounds like crazy because

1:17:36  
we are applying a function to itself. But it's meaningful if x actually has a polymorphic type, if we think of x as little x as something, which actually can obtain multiple specific types. So here is a valid type derivation, which maybe looks crazy. I'll also read write the manual, then it will look here. So what I'm doing here, we're following the rules, we are trying to assign this guy, the type A arrows a, where A is not no longer a meta variable, a is actually just shorthand for this specific thing. So we've taken the time x times x, and we've said, for all x x x, this is a but so really, officially, I should maybe write this thing instead of a everywhere, but let's just use these abbreviations. Because otherwise, it would be huge that the whole little three times this one, I have to assume x is of type A, and then I have to conclude x applied to x of type A, at this moment, this sounds completely crazy, like, Okay, if x is of type A, how can I then get an X applied to x is of type A, because if x is of type A, then the argument this x here is of type A. But then if the result also has to be of type A, then clearly this x the function has to be of type A arrows A, which is not what we've said. Yeah, have we know, we've said that x is of type A, that's the only thing we say in the context. But now let's, let's see if we can take it. So against all odds. So what did we say we just need, we need that the argument is of type A, which we can justify that's here. Because our context tells us x which is the argument is of type A, that is fine. But then we also x is also in the function position, we have to say, as a function it has to be of type A arrows a because the return type is eight. The argument type is a. Now that looks crazy, because my context says x has to be of type A, and then I want to conclude x is of type A arrow say but look It is actually not. Because I can get from here to here by specialisation or instantiation. Because what does it say it says whenever something is of type for all x a, for some A, then I can take, I can get rid of the universal quantifier. And I can just replace in a x with any B. In particular, actually a itself also works. So, so this step here from here to here is a case of instantiation, we use the fact that a is this thing. And then we just take the body here x arrows x and replace x with a. Now, if an X that was x, you replace x with a substitution, you do get a yellow say, this is exactly what I've written here. So, that's a bit of a surprise, and maybe, maybe sounds crazy. I ready to talk properly, then I show you a different version of it, which maybe doesn't sound too crazy. And that's, that's the one that F sharp will actually use today to derive a type right. So F sharp manages this.

1:21:38  
But it comes with a different type. So you can do some crazy things, you can do very crazy things, you cannot still type omega, which was the nonsense term, that which when you started simplifying, it gave you back the same thing immediately. So this one cannot be typed. The argument that it cannot be typed is quite complicated, but you can just trust me, it can't be typed. So so we are in a system now that is stronger than than simply typed lambda calculus, where the for all is not present. But it's still not very strong. Real FP languages go in a bit of a different direction, so they allow for all but not in every position. So F sharp, in particular, allows you to generalise functions that you've different that you've defined by Latin lectric. These can be generalised. But before they apply, they have to be instantiated again. And we'll see this. So F sharp is really a bit weaker. But then it's stronger in other aspects as far as I told you. So I mean, for example, it allows rec, which this one doesn't allow directly. And it has all these side effects like printing and exceptions. And printing in particular gives you different results under different devaluation orders. And handling is something that you can't express in, in, in sort of lambda calculus simpliciter. Okay. Let me give you the properties. This actually is the last slide before I want to go on to another topic, which we'll do next time. But the good properties are still there in in this very liberal system, subject reduction still holds despite this type system being quite crazy. So if a term has a type under a context, and you can reduce it to another in one or many steps, then the term still has the same type. And a strong normalisation also holds. So if you've got the type of a term, not just any term, of course, but the type of altar, then any reduction sequence of T terminates, and after normal for so whichever order you evaluate, you get to normal. And therefore, every term has a unique normal form because we also had a conference for which we haven't lost because you haven't changed the terms. Okay, let me quickly go back to this example, because I want to show it in in a tiny bit more detail to illustrate what happens. So, what is we have here we are talking about this term, which I want to type like. And what happens here is we use the lambda rule at this point, which tells us put the lambda bound variable in the context with its type which is a and then try to derive the type for the body which is x times x, x x applied to x sorry, return type, which is this.

1:25:04  
That's all good.

1:25:06  
Then we have the application rule. The application rule told us what. And this is a place where we can actually do slightly differently. So let me move into some space. Application rule says, in the same context, I have to type the function and the

1:25:29  
argument.

1:25:32  
And let's try to defer using generalisation and the instantiation as long as possible and think naively. So this x here is the function. Step one. And the other x is the argument is that one. And about Sorry, I'm running ahead of myself. So I want to say I need to pipe this x, which is the function and this x, which is the argument somehow, so that everything fits about to a function, I know that it needs to return something of type A. Because that's what comes back here of this place right? Now, but the argument, it's easy for me to just use that x is of type A, because this is what I get from the context directly, and then here, I will be done. That didn't mean to use generalisation or instantiation in any way. As soon as I say, I want my argument to be of type A, you have no choice than the functions, input type or argument type also has to be a. And that is the strange place. Because if you just look at these things, we see no agreement. But then, remember, we know in the context x being of type A, we can derive x is of type A. And let's just simply look at what A is a, by what we agreed is. It's not just a meta variable, it's actually an abbreviation for this concrete thing. Yeah. And then we have the essential is the association rule, which says

1:27:41  
that I can replace x here with anything. And in particular, I can choose to replace x with a. So I can take this thing x that was x and replace x with a, hey, what do I get is exactly what I have here as Ray. So I've used all the right tools. So this was the variable rule. This was like the lambda rule. This was the application rule, I call it up here is the variable rule. And this is the rule that we could call instantiation or specialisation, people also call it is this fine? That is actually not quite what F sharp does F sharp morally uses a different derivation for the same that is a bit more systematic, because this looks like a real rabbit out of the hat. So what happens there is is more of the following. And you can see if we can do this, okay. Okay, so

1:29:30  
cool.

1:29:31  
Okay, so let's edit it a bit. So it actually does a bit differently. Namely, at this point,

1:29:44  
here,

1:29:48  
I cannot really use anything as a function in a function application. I can Only use monomorphic types is a polymorphic type because it contains fraud. I mean, this is here is the definition of a. So it will actually specialise at this place.

1:30:18  
Something else will happen compared to before. I can go from here to X being of the type capital X, narrows x, y, because this ad here is after all just for all x, x arrows x, isn't it? And this guy after all is just

1:30:50  
x arrows x. When I have done no interesting substitution, I've just replaced x with x itself. Yeah, so I can go from this polymorphic type to a monomorphic type where I just say x is a function space from x to x, and there is no universal quantification here.

1:31:17  
How could I then continue? Well, at this place here, I need to use generalisation going over the space. So here I am in a context which is closed, it doesn't contain capital X freely. So therefore, I can replace this guy by x x. x applied to x has to be in the type x narrows x. In this context, x is only at this place, I tried to use the application now.

1:32:08  
This was instantiation.

1:32:12  
Now I mean a bit different situation than I was before. So here is an application. The return type is x or x, the argument type is X or Y axis, we just decided, therefore, I need to show that the function is of type x Arrow x. And now I'll write something different from what was before. Namely, instead of this guy, I want to write x Arrow x Arrow x Arrow x. That's the type I want to give to little x as a function. Now my letters are maybe not great, is equipped maybe a confusion between small and big X's? This is a small one

1:33:03  
really small.

1:33:06  
Okay, from where does this come, I could get it from the old place, but not replacing x with a but with a arrow z.

1:33:22  
Okay, with x equals x. So that's what this guy here is. And then this is instantiation that is applied here. Okay, so this is a full derivation in a different way. And maybe more systematic. So

1:33:51  
let's see again. So here is an application and application is given a polymorphic type that's not accepted. This application should be something of a more specific type. So we actually use generalisation I can use it here with with x capital X, because it doesn't occur free on the left, capital A is for all x, x or x. So x here is bound. Okay, then my task is to, to make something like this happen. So one cheap way to do this is I say, Okay, I can instantiate a to x Arrow x, why not? It's allowed. And then nine needs something of this function type and it perfectly works. And that isn't the the mechanics of it. Okay, I think for today, this is quite a bit and maybe Yeah, apparently, especially this is getting a bit complicated. But next time, we'll have plenty time to discuss this closure. So next time I'll want actually to show and this is where we don't go right now that you can encode data types in this polymorphically typed lambda calculus. So that's one of the reasons why people say, lambda calculus really, in the core is everything you need to do functional programming. Namely, you can code up here things like Booleans natural numbers, if you wish, lists, option types, any of these data types that you see in in FP languages and similar also record types. And tuples are closely related. So while this looks like very minimal, we only had these three typing rules plus the two new ones, it is actually super super powerful. Okay. How about

1:36:12  
questions?

1:36:34  
Anyone there any question? Or is this reasonably?

1:36:40  
We have no questions.

1:36:43  
I'll try to do more examples next time as well. So it's not only like you know, bright lines, but I'll try to write something as I go simply to to show a bit of the dynamic of it because if you just look at the constructed tree, it looks like a given Yeah, okay, it is there before where did it come? Okay, but then if we are done with this, then this is good. Tomorrow. A whole lot of the lab sessions will actually run in the hybrid mode in the sense that you can go to school, I'll send out an announcement right now about the exact classrooms. The two last sessions will be of the day, we'd be by zoom only, but but the others who can go to can also go to school and meet the TA which may be is can be more efficient.

1:37:41  
Okay. Then, if this is it, well then I say goodbye for today.

Transcribed by https://otter.ai
0:13  
Very good.

0:26  
Okay, so we do encoding data types in,

0:33  
in this system polymorphic,

0:36  
lambda calculus,

0:40  
also called system math. So what happens?

0:44  
It turns out that you can code up a whole

0:47  
lot of things here. So, I will do two main examples, which are the Boolean type

0:54  
and natural numbers.

0:57  
But actually, you can also code up tuple types here quite easily.

1:03  
And, in fact, any kind of interesting user defined data types, like various sorts of trees etc can be

1:11  
coded.

1:17  
Let's see how this can be done.

1:20  
These encodings go under the name of church encoding or in predictive encoding, if you see somewhere in the book, that's exactly this.

1:29  
So, one of the main things that we need to do with with Boolean is in a programming language, well, we need to have a type of Boolean around.

1:39  
And then it's important to have a constant for truth that I call TT here a constant for false.

1:47  
And some way of looking at the Boolean and making some decision based on it that you typically call if then else.

1:54  
And everything else that you may actually want to do with Boolean is can be coded up through these things, right? Because,

2:04  
say, logical and for example, or logical or, or negation, you can write down all of these through

2:12  
if then else. So for example, if you want to say not B, of course, it's the same as to say if B, then false. Else true, because that just flips the truth value.

2:25  
Why is this? Sharing properly?

2:32  
You're not seeing what I'm showing, right? No,

2:36  
that's not good. Why is it doing this to me now? Okay, try again. So this was the only slide that I managed to show.

2:45  
I want to talk about Booleans. So,

2:49  
and I said, we want to have around at least a pipe for Booleans. If I want to work with Booleans, and then the constant to unfold. And if then else, don't look at the right hand sides here yet at all. So I'm just saying, What is sort of the minimal infrastructure that I need to have around in order to programme with billions? Then the last thing I said was,

3:13  
in the case of

3:15  
negation, for example, or not, this is the thing that you can easily write up with if then else, because

3:24  
you would say something like, not B is the same as if B,

3:29  
then false else true. So just by picking suitable branches for the if, then else, you're done.

3:36  
Now it turns out,

3:39  
and Firstly, it looks like a rabbit out of a hat. But actually, there is a bit of a method behind it. That,

3:46  
of course, these things are not present in the polymorphic, lambda calculus. As such, we don't have a primitive type called bool. We don't have any constant like this given, but we can call them up. So it turns out

4:00  
the Booleans, you can code up with this type. Yeah, it looks maybe a bit crazy. So it says it's the type of

4:12  
all functions that work at all types x, and take an X and give an X, sorry, take an X, take another x and give back an x.

4:24  
Now, if you think how many such functions you can actually write, maybe there is only two because

4:31  
what can such a function do that works on any type x takes two arguments of type x and returns a value of type x.

4:42  
And you know nothing about the type x you can't use any particular operations like you don't know it's a character. So you cannot apply character operations. You don't know it's an integer. You can't apply integer operations, you know, nothing. Someone gives you two elements of x and you're supposed to produce an element of x.

4:59  
What

5:00  
Can you do in such a case?

5:05  
Well, there isn't a lot is there,

5:09  
you can either take the first argument, then throw the second away. Or you can take the second argument that throw the first one away. And then you return what you kept. What else can you do? And this maybe indicates why this is a good idea, because a Boolean type should have two elements. And here is a complicated type that actually only has two elements, right? Take two arguments, keep one of them, there is two possibilities. And we exploit this fact. And it turns out that these works people.

5:39  
So I need two elements, then I just define them in some way. I define true and false, where I say two is the one that keeps the first element. So that one should be good, right? takes something that I call t here.

5:57  
These sort of hidden, actually, for two brands, and F is for false brands, if you if you wish, but but they're just variable names. That sort of it says keep the true branch. False, is similar, but it keeps the other one.

6:10  
Maybe better, don't think through bronze and Postgres, just think, think two things, return one of them.

6:19  
And then if then else actually turns out, and that's more complicated, you can code up with,

6:27  
with something like this.

6:30  
Yeah.

6:32  
If the nails has to take

6:35  
three arguments, one of them has to be of type Boolean, the other ones have to be of whatever type of equal types. And it has to give us something of exactly the same type. And then it turns out, you can apply B to t. And then here's the intuition.

6:50  
The T is really kind of the true true brands, and f is the false branch and things will work out beautifully. We'll see this, but first I have to justify that this kind of definition is good at all. So let me try to show to you the TT FF and it he actually have the types that we intend for them.

7:14  
So let me try to do this, then I have to share differently Just a second.

7:30  
Share the whole screen.

7:40  
I just need some space for you.

7:43  
Good.

7:46  
So let's think why is TT of the good point at all?

7:52  
TT has to be a five Boolean right?

8:10  
TT is.

8:24  
Tt is this thing

8:28  
is actually this thing lambda t.

8:42  
And we want to show that this is of type Boolean,

8:50  
Boolean, or really, this type

8:55  
for all x, x, x arrows x,

9:02  
isn't it?

9:04  
Now how to prove such a thing? Well,

9:09  
I've got my rules. There is the rule for lambda. But that only works when I have a function space in the tight but here I have a fraud. I first need to

9:17  
be using the generalisation rule, sort of backwards because I work my way up from conclusions to premises.

9:26  
So let's see.

9:28  
I have to write Thursday, lambda

9:34  
has to be of the type x arrows x arrows x

9:43  
where

9:44  
I've replaced the bound variable x by a free variable x, which is an OK, application of the generalisation rule,

9:54  
because it says that as long as x doesn't apply in the few variables of God

10:00  
Math, I can I can just go from this to this.

10:05  
And if my ex is among the three variables of gamma, then I better again use alpha renaming I just change the bond variables for something more suitable, which is always possible.

10:17  
Okay.

10:19  
So then what is the next step actually that this was a good place to be?

10:27  
The next step should be the rule for lambda,

10:31  
which is this. So I say, okay,

10:35  
in a context where t is of type x, I better show that lambda f p

10:43  
is of type x x.

10:47  
Yeah. And then

10:50  
I apply this one more time. And now I extend the context one more time, I say in a context where t is of type x,

10:59  
and f is of type x

11:03  
the body of the lambda which here is only T has to be of type x,

11:09  
you see what is happening. So, if here is the lambda bound variable,

11:16  
In this step, it's made a free variable push to the context,

11:22  
then t contains f freely. And the type of T has to be the return type of this function, isn't it?

11:30  
And then, am I done? Well, yes, because T is a variable and it actually occurs in the context. So, by this rule here, I'm actually finished. So, this is the proof that actually TT to our constant for truth.

11:56  
He's a Boolean. And you can easily imagine that instead instead of T everywhere, I would have had F in these places, here, here, here, here, which is actually the definition of false then the proof would have gone through exact the same way.

12:18  
Remember that false is defined like this.

12:23  
Yeah. So, for

12:27  
FF,

12:29  
just replace

12:35  
with

12:37  
above.

12:41  
Okay,

12:42  
that's easy.

12:44  
But even else is a certainly more in so let's let's that example as well, because that kind of explains what is going on.

12:57  
Okay, what do we want to say?

13:01  
if then else is this thing here? Now I'll need a bit more space lambda

13:08  
lambda t

13:12  
dt.

13:15  
So, this whole thing is what we want to call if the nails

13:21  
it has to live in. What is the good time for for for if the nails for if then else we want

13:30  
that it is a function that for all x

13:34  
given a Boolean

13:37  
given

13:41  
the value of type x, given another value of pipe x gives me back something of pipe x.

13:49  
Why?

13:53  
Well, because

13:57  
that's what if then else does it takes it should take three arguments.

14:02  
The first one is the guard branches about the two branches is reasonable to require that they are the same but they can be anything so that's for all x. And then what comes back Of course, should be of the same type as as both of the branches. So now let's see if we can take that one. Again. The first step is just generalisation.

14:24  
So we have to say

14:35  
just this

14:45  
and then I have a whole lot of lenders so now I need to apply the lamda rule three times.

14:51  
Let me do it one by one anyway for clarity, although we could perhaps

14:56  
jump ahead ourselves and apply three boards at once.

15:00  
That's maybe harder to.

15:02  
So first I say in the context where p is Boolean, the rest the body

15:09  
has to be

15:12  
has to be a function from x to x to x.

15:23  
Okay, then we throw t also to the context, then we have something like

15:30  
t, x

15:33  
yields lambda f, b, t, f is

15:40  
x Finally,

15:43  
know something must happen at some point when not yet something very interesting.

15:49  
The blue

15:52  
t in x and then also we have to assume F is in x

16:00  
and then we conclude

16:03  
the T

16:06  
will have to be in x. Now, it gets a bit interesting because this is an application

16:12  
isn't it?

16:14  
So, let me give this thing here name because it's a long context. So I call the whole thing gamma.

16:22  
I don't want to copy it all over the place

16:27  
in the context gamma, then I need BTF is of type x. So, how do I achieve this?

16:34  
Whoa, what is happening?

16:43  
Well, I have to in the context gamma, I have to type bt on one hand,

16:51  
isn't it?

16:53  
And F on the other hand, so, let's not write the types yet.

16:59  
Because bt is applied to F here, isn't it?

17:12  
Well actually, for if there is not even so much choice about what its type is because in the context gamma we know that f is of type x. So, maybe we just use this this is the variable rule. If this is the case, then B to be applied to T must be a function from x to x

17:30  
Okay, then I need to type

17:35  
in the context gamma i need to type B

17:39  
and in the context gamma I also need to type D

17:47  
need more space sorry,

18:02  
he has to be of type

18:05  
x

18:08  
and B then So, T is already in the context gamma with type x. So, here we also done

18:16  
but that means that V will have to now be of type x arrows, x Arrow x

18:25  
Yeah, because the input type is x

18:31  
and the return type is x Arrow x. Now, how to achieve this in the context we have something quite different for for B we know that these Boolean

18:41  
So, let me reclaim the space.

19:10  
Yes.

19:41  
Okay. So,

19:47  
where could that come from? Well,

19:53  
we are actually not in such a bad shape because, hey, from the context we know that B is of this

20:00  
Type,

20:01  
v is a Boolean.

20:06  
But Booleans word just after all, the type for all x, x arrows x that x. So if I instantiate

20:18  
apply the instantiation rule at this point, then whatever,

20:23  
x is good for the capital X in here, so therefore, I can also take this particular one, which is the free variable that was invented at this place. And this completes the proof.

20:35  
So, we actually need to use that the INT internally or the actual meaning of bool is, is these polymorphic functions.

20:44  
So, morally,

20:46  
B can only be either

20:49  
projection to the left or projection to the right. I mean, it's one of the two selectors between two given arguments. And here we exactly apply it to choose between the two given branches. So, that's that's the trick.

21:05  
Okay, then, does this work correctly? I mean, can we really get the behaviour that you have for Booleans? So these are the proofs sort of fully spelled out in one go without explanation.

21:20  
I've written a set of x. Okay, but yeah, anyway.

21:25  
Now let's check that it works the correct way. So

21:30  
if then else, for example,

21:36  
let's check that it does the right thing. If if the actual guard is true, so what happens?

21:44  
So let's suppose the actual guard is true. And then there are some branches called them you want v.

21:50  
Yeah, you'd expect that this thing should compute to the branch you. And I should not even need to look inside v that should be somehow be the idea with announced let's see if it works. So if then else, by definition is this thing, we're applying it to TT, u and v?

22:08  
Well, this is a bit theoretics, because I can see a lambda abstraction applied. So at this place,

22:17  
in one step, I get to the form where the parameter has been replaced by the

22:25  
by the actual argument in the function body, which is this guy. So the result is this.

22:33  
Yeah, this part here simplifies to this, and u and v are untouched.

22:40  
They're the same. And then I can repeat. So here, I've got the function that is applied to u and v is just one more thing. So I plug in u for T, I get this

22:54  
as the leftover of this body here, so to say. And then again, I've got a lambda that is applied, which means for the place of f, I need to put VI

23:06  
and then the result is this. Okay? It looks like I didn't get to you. But hey, TT is not a variable or constant. pt actually is a selector. So let's write out sort of in full detail with TD ease. Of course, I could have written it out already here. But that would have simply made the whole thing a whole lot more unreadable. Let's write out what T is T T is this thing. So again, there is a lambda abstraction applied to something. So you goes for T, and I get this thing.

23:40  
And then I have to plug V, for F, because what is left over

23:47  
is again, sorry, is again,

23:50  
today, nothing works is again, a lambda, the bodies EU, the EU doesn't contain f,

23:57  
u is something completely different from from this bound variable f here, right?

24:04  
And we plug V for you nothing happens, the result is just you, which is exactly the right behaviour, if then else.

24:13  
And then at fourth, it behaves analogously. But of course, it picks out the other brands.

24:19  
So Booleans are this particular polymorphic function space that contains exactly

24:27  
two functions. And then what if then else does, it just takes the given function and applies it to two branches? And of course, it's just picks one of the two branches, that's the nature of it.

24:42  
And that's all that there is to be said about bool true or false if and else. You also saw these type derivations.

24:54  
Yes, where I didn't do that sort of last generalisation step here. So that's the difference.

25:01  
Otherwise do the same.

25:04  
And then as I said, anything else that comes to your mind you can define like not obviously is is a function

25:11  
with the lambda.

25:14  
And the definition is, whatever is given, plug it into the guard position of his toenails, and just give false into as branches and the what the whole thing does it swaps the roles of true and false right true becomes false false becomes true.

25:29  
The short circuit and

25:33  
that, in a good case only looks at

25:37  
the first conjunct is this. So, it takes two arguments B and B prime.

25:43  
It does if then else based on D. Yeah, if P is false, then already what is returned is false.

25:52  
Because if P is false, it doesn't help whether B prime is false or true. I mean, the end has no chance of being true anymore. We can already at this stage say false. Otherwise, of course. So if p is true, then the truth value of B and P prime is decided by B prime. So depending on what the prime is

26:12  
the result this is correct. But you notice that in case this false, you don't really even need to look at the prime. So this is the is the branch of if then else that is actually not touched. And if you do outermost reduction, you don't try to simplify the prime because it's it's sort of erased before we even get

26:32  
on or is completely similar. So if the first disjunct is true, then

26:40  
we just say true. Otherwise, we return the second.

26:47  
How does it feel?

26:54  
Yeah,

26:56  
it is obviously trickery. Right? So I mean, how on earth did people invent this? And this requires some insight. And it was it was a very clever move. But then once you've shown it, then maybe after that

27:12  
it's not so complicated anymore, once you sort of

27:17  
adjusted yourself to this, but then you might ask, okay, yeah, but this seems to be like a one off case, what do I do for something else? What do I do for pear types? Or tuple? types? Or, or lists or the Option type? Is there some system behind it? There actually is, I won't show you the full system.

27:34  
But

27:36  
I'd like to show another example.

27:49  
And the exam is of natural numbers, it turns out, you can you can code up those as well.

27:56  
So it'll be a bit of exercise. And actually, I'll show you more detail maybe after a short coffee break, but let me comment. So the tick seems pretty similar. So the natural numbers some

28:10  
bizarre

28:12  
like you might have for some for all quantified thing

28:17  
then you can define zero

28:20  
which is a bit similar to two in the sense that it is between is and the first

28:29  
S is for successor and you can make all nutana one successor successor one yeah. So, for example is a sort of successor

28:42  
sort of zero

28:44  
plus 103 times you can make any number in this way and then it turns out by some,

28:51  
but a way of

28:53  
being successor here is this and this are more mysterious

28:59  
than coding some false work and indeed it is a bit maybe tricky to understand at first why that is not is not by any and if you think this is crap, then I agree with you. It may be

29:16  
and then what to the programme would naturally be some form of recursion

29:24  
would allow you to do things like you say, you know, how do the functions from naturals typically goes by well my function foo with something and my function foo out of thing plus one is something that anything and then you go by recursion, this recursion can be

29:44  
down by by this kind of combinator that is here called fold.

29:49  
Fold, three art

30:04  
Now,

30:06  
the second argument is the base case, which says What do you want to do in the case zero? So for example, you expect that fold set of u and v would be you, because I'm applying my combinator are my How are the function is that here to zero. So, the second argument is just for what you want to do in the zero case,

30:27  
the set, the third argument is for what you want to do in the case, when the first argument is successor of something. And then the idea is you do something, whatever we here, that's specified in the third argument, applied to whatever was the result of recursion applied to, you know, the argument was smaller. So So here, I'm applying fold maybe to eight, to suppose t seven, S of t is then eight. And this reduces to

31:00  
whatever fold gives you on seven, because T then would be seven.

31:06  
And, yeah, this is the result of the recursive call, and v is just some function that does whatever to the result of the recursive call and gives you then something back so you can for example, programme, I don't know addition or multiplication and with with subtleties, the factorial function in that way, for example, or is that something that Prime

31:30  
no more complicated way?

31:33  
You reduce programming with natural numbers

31:36  
to do things called folds.

31:39  
Okay.

31:43  
How is that?

31:47  
Are there questions

31:49  
about this?

31:52  
I can see in the chat you say I've been lagging um, this is true. And this is the unfortunate

32:00  
connection because the proper one is down and I'm using some poor judgement.

32:12  
Then

32:14  
we go complaints.

32:30  
Can you say something just for me? If the connection is working at all?

32:37  
We're here.

32:39  
Okay, but the lagging is?

32:43  
Is it the voice and don't synchronise, it just stops and doesn't go on at all.

32:49  
Sometimes

32:51  
the sound just cuts off and the video freezes.

32:58  
Yeah, unfortunately.

33:02  
I've tried to play a bit during the next five minutes seeing and use some different settings, but I'm the main network

33:10  
host

33:12  
does not function.

33:18  
Okay.

33:20  
After the break, I would want a bit more about lecture numbers and then a bit about version and that will be actually

33:29  
let's take Let's take a short and we'll say 12 What is it?

33:35  
45

33:39  
Okay,

43:38  
Okay Sorry, I'm plagued with it. I think I'm on a different network now, which might also be unstable, but hopefully better.

43:49  
Is it lagging at this moment as well?

43:52  
No, it's good.

43:54  
It's good.

43:57  
So sorry for the delay, but I think it

44:01  
maybe it's a bit better now.

44:10  
There's really very little I can do about this.

44:12  
Let me share again.

44:34  
Okay, you should be seeing something No, I hope.

44:40  
So that's where we stopped natural numbers.

44:43  
So, what happens in this encoding in particular is

44:48  
as I said, So, to encode the particular number.

44:53  
The idea should be that

44:58  
this is of course,

45:00  
Um,

45:02  
basically s s s apply to set

45:42  
thank you

46:22  
to do something.

46:43  
Thing is apparently that they have every possible technical failure.

47:04  
Okay, in your pride

47:11  
Yes, I wanted to say, that's your number like three, of course,

47:16  
you can write it down as capitalists apply to capitalists apply to capitalists

47:23  
apply to set.

47:27  
And then you can write it out what it means by definition, which is in terms of,

47:34  
you know, writing out as like this writing outset like this, a whole lot of simplifications will happen. So,

47:44  
you can define it like this, but if you simplify using our beta reduction thing, then it actually becomes better. And it obtains this form.

47:56  
And namely, this, where in the particular case of three, we just do get lambdas, that lambda s, and the S three times

48:07  
supply present, and these are smaller systems, small sets.

48:12  
So, these are just variables, whereas a capital letter things were the ones that we saw up here.

48:20  
Okay, so, this sounds like some infrastructure, it may be a bit mysterious, why does the right thing So, we can check a few things.

48:28  
But the technique then how your programme with this would be basically the following. So, for example,

48:34  
for tradition, we know what we want, right, we want that, when we add together

48:41  
say

48:42  
and and then

48:47  
then in specific cases, some particular things must happen, right. So, for the zero case,

48:56  
we expect that

49:03  
we expect that

49:08  
what comes out would simply be the second number, right, because if you add together 01 from number M that should be m. So, we expect

49:16  
that

49:18  
these are equal but this simplifies to in some number of steps to m. Similarly, if you have additional say a successor of n, and then then we expect that this should be the same as what is it? Maybe something recursive? Yeah. Let's suppose we don't yet know how to add together SN and then but we already know how to add together n of them.

49:48  
Just like making a recursive call,

49:51  
then how should I get the wrong result of adding together and in and then to the result of adding together Sn Sn and then we'll have

50:00  
Of course, I just need to add one to the result.

50:04  
So, this is like good specification, what we might want to have. And then when you look at the form here, this is very similar to what fold always achieved for you. So, there is some base case. So here m, and there is some step case,

50:25  
where you are applying some given thing to the result of the recursive call, which here perfectly happens, right. So, if you proceed from this idea, then we see that we can write down

50:39  
addition as something that takes in

50:45  
a number

50:47  
that's the first summoned and other number the second summoned on what comes back is the following is this function that goes by recursion over the first summoned in the base case returns M,

51:01  
which is this here.

51:03  
So, when n is zero, what comes back is M. And in all other cases, what we need to do is we need to add one, so applying successor to the result of the recursive call.

51:16  
And this then becomes programming technology because when you need to do something else, then you need to sort of apply the same principles, you simply need to think what is the correct recursive definition

51:29  
of things. So, let me do one more let me do multiplication. So, for multiplication you want

51:37  
recursively, you can also do it by recursion in the first argument. So, there are two factors. Let's, let's look at cases for the first, if I multiply together zero when some m, what do I want? Well, surely zero times anything should just be zero. So that's what I want back.

51:54  
Um,

51:57  
what about the sort of step case of recursion. So when the first factor is something of the form s n,

52:08  
then the second is a general M.

52:11  
So this is like multiplying together n plus one and n.

52:15  
And I need to do it by I'm allowed to use multiplication of,

52:21  
or the result of multiplication of n and m, because that's what comes back from recursion. And now I'm allowed to apply something to it. So what could it be? So how do you get from n times m to n plus one times m?

52:38  
Well, multiplication is nothing else than repeated addition, you need to add em one more time to the result. So we can formalise this as

52:53  
add

52:57  
to this thing.

52:59  
And that will be

53:03  
and then you can capture it. So once we trust that fold does the right thing

53:10  
i can

53:13  
i can get for multiplication what I want, because what is multiplication takes in two numbers, the first factor the second factor, then I fold over the first factor. So that's the one that I analysed and recurse on, I look at two cases if the first factor is zero, but has to come back to zero. In the other case, whatever comes back when I applied to,

53:37  
you know, when I make a recursive call,

53:40  
the way that I need to adjust what comes back from the recursive call to return from the main call is I add to the result one more time, which is this guy.

53:53  
Of course, I haven't yet justified to you why by fold works the correct way that would be to play with these definitions. And to see that really, this kind of behaviour

54:05  
is achieved at all. And that's not so clear, right?

54:13  
Okay, then there is a final example that I wanted to give here. So for example,

54:20  
we can write a test of whether a given number

54:25  
is zero.

54:28  
So this also takes two cases, maybe I'll write them here. So is zero.

54:33  
I can apply to either zero, or I can apply to some single the form s n.

54:44  
And what should I answer?

54:54  
Well, if I'm in the base case, then I should say sure the number is zero. So then I want to answer

55:00  
All right, so you put the wrong side.

55:10  
And in the other case, I want to insert false. So any number of the form successor of something clearly isn't zero. And that should be the definition. And it is actually, although no real recursion happens. So you don't see any recursion here in the staircase,

55:28  
it is still actually of the form of a fold. Why? Because the number comes in, that's the one that we fold on. In the base case, or the zero case, we say true.

55:38  
In the other case, I'm allowed to say something based on the result of the recursive call. And what I do here, I make the recursive call. But I don't use it in any way I just say no matter what it is, the outcome here is false.

55:54  
You can imagine that you could do more interesting things, maybe you could write a programme that tests whether the number is

56:01  
is even and odd.

56:04  
And then actually, you have to look at whether the previous number was even. And you have to flip that bit. So that properly requires a recursive call, but this one doesn't.

56:16  
Okay.

56:19  
So let's maybe play a bit here and

56:24  
see some of these things. Why why, for example, this one doesn't have the right type or why these recursion behaviours

56:33  
occur.

56:35  
Nothing worth highlighting doesn't work, nothing works.

56:43  
So

56:45  
successor, for example, why does it have the right type? Maybe I'll do that one. So, this is a somewhat more complicated situation than what we saw before.

56:57  
So, successor has to take us from net to net that's what I want, but but it really so

57:12  
successors defined like

57:24  
this.

57:27  
So, this whole thing here is this capital S for successor

57:33  
and then we want that the result of course is net to net

57:50  
so how on earth would I derive this?

57:55  
Well, it's a lambda and here is a function space. So, I can actually apply the rule for lambda, it will say that if n is of type net, I must be able to show that the body here which is all of the rest

58:11  
is of type math.

58:14  
Well, at this point, I really have to look at what the type net is. So not actually is more specifically this time for all x x Arrow x x x

58:27  
x.

58:31  
So good then we can use generalisation

58:36  
and I just need to show that 4x I can show that this thing has the correct point

58:51  
okay, why does he know I have a lambda again.

59:12  
So, that is the parameter it has to have the argument type of the function and the body has to have the return type of the function. So this thing here

59:28  
right, and then

59:32  
this is a lambda again. So this thing is all good in the context where n is not Zed is x, and S is x and O's x.

59:42  
I can show that as supply, and Zed S

59:48  
is of type

59:51  
x.

59:58  
So let's see. Maybe that's again

1:00:00  
a point where it's useful to actually the context will not change anymore, I would call this thing gamma not repeated anymore.

1:00:13  
So, in this context, I need to show that s

1:00:20  
some type and Enza this also has to have some type.

1:00:31  
Now, the type of se is fixed in the context gamma, we see that the type of S has to be x arrows x.

1:00:40  
So there is very little I can do interesting here.

1:00:46  
But this here is then what so if S is a function from x to x, it returns x, then the argument also has to be of type x

1:00:57  
from where should that then come.

1:01:01  
So, of course, I will run out of space as always. So in gamma, I need to type enset.

1:01:11  
And in gamma, I also need to type

1:01:21  
the type of this again is is fixed

1:01:25  
in gamma, so there is little I can do.

1:01:30  
But then ends up therefore has to have the type

1:01:34  
x arrows x to x.

1:01:40  
Yeah, because

1:01:42  
this is an application, this thing here of n set to s.

1:01:48  
So if this is the return type, and this is the argument type, the function type has to be this one from the argument type to the return type can be anything else.

1:01:59  
And then

1:02:01  
what that's an application again, so I need to type in

1:02:07  
and I need to type zet

1:02:10  
that has type x in this context, I can't really choose anything else to say.

1:02:17  
But then n has to have the type

1:02:21  
x arrows x arrows x

1:02:25  
to x.

1:02:29  
That's the perfect place to to to run out of space again.

1:02:34  
You can laugh at me,

1:02:37  
I can laugh at myself.

1:02:52  
This time, I'm less in writing. So I know what I need to do. Okay.

1:02:59  
Something funny happens here. So this one is in the wrong place.

1:03:06  
Okay, so how do I get there? Well, luckily, I know that enemies have typed Matt, according to the context gamma.

1:03:13  
So I can write in gamma x, you know, Ben is of type net, but not your C is for all x, x arrows x x x.

1:03:26  
x.

1:03:28  
So by specialisation, I can choose the for all bound x actually to be the free x.

1:03:36  
And that is exactly then there is nothing else to worry about. So maybe I should move things around a bit.

1:04:08  
So here

1:04:11  
that's the full proof.

1:04:16  
This is how it works.

1:04:18  
Now, why is that? Why do we have the right behaviour, maybe we could do a bit of that as well.

1:04:26  
Or not.

1:04:33  
Maybe I'll leave it

1:04:36  
as this okay. So that is a nice exercise to

1:04:41  
to,

1:04:43  
to try to, for example, prove the second one that this one really simplifies here. What you need to do is

1:04:50  
you have to take the definition of fold First of all, and start simplifying.

1:04:55  
And when you get far enough, it's maybe also useful to to actually

1:05:00  
Look at how St. Point, plug that one in

1:05:04  
and simplify further.

1:05:07  
And then you can actually get

1:05:10  
to this place.

1:05:12  
Which is,

1:05:14  
yeah, maybe a bit too much to do right now, I think it will take at least 10 minutes if I play slow. Okay.

1:05:22  
So that's the game.

1:05:24  
And somehow the idea is the same as with Booleans. But it's a bit more difficult to, to maybe see why this is the right time. But maybe intuitively, I can try to motivate it. So why do we think this type has the right number of elements, which here should be like, one function for every possible natural number? When you think of this function space, what is happening here?

1:05:49  
Anything in here is a function that works on all x, regardless of x. So you can't really look at values at all, you can just copy them around, pass them to other functions, throw them away, duplicate them do stuff like this. So So what functions are possible at all? Well, one possibilities, you're given these two guys, an element of x and the function from x to x, and you need to make an element of x, the first thing you can do is just throw away the function, just use the element does actually the code for zero, it does exactly this.

1:06:22  
And then all other cases, what else could you do? Well, here is this function around, that doesn't do much else. Other than, you know, it's a paid, you can see what it what it does, in general,

1:06:34  
but surely takes an element of x to an element of x. So I can start with this element of x that I'm given, and I can apply this function to it some number of times, any finite number of times, and then I get the next and that is then the idea. So any natural number can be represented by a function that takes two arguments, it uses the first argument as the seed. And then, you know, as big as the natural number is this many times it applies the second argument to it, and then returns the result. And, you know, if you think about it, for five minutes, you can convince yourself there is no really no other functions you can write. And that is exactly the trick here. And that's,

1:07:20  
you know, it doesn't very well justify why this is, this is a bit more complicated to see, but it just doesn't justify very well, this fact that and that's your number can be encoded like this, you know, an element of x comes in a function from x to x comes in, and you do one of these natural numbers, many things that you can do, namely, take the second function applied, and times to the first guy.

1:07:48  
And then accordingly, fold. Just given a number does literally this, it, it takes two things, you an element of x v, the function from x to x, and it just literally applies

1:08:03  
the function as many times to the given element as this natural number tells you, which is exactly the ration so it makes as many recursive calls, as this guy tells you on the base case.

1:08:18  
Okay. Now one final topic. Let's get over this. That's two more slides is

1:08:30  
how do you get general recursion into the lambda calculus?

1:08:35  
Well, by General recursion, I mean something like lead rec of F sharp

1:08:40  
general recursion is the Turing complete thing, which typed lambda calculus is in general recursion allows you to write non terminating functions.

1:08:51  
So it basically allows you to write infinite recursions are recursions that turn out to be infinite as you compute and also why loops where there is no guarantee that the condition will ever be true. So why loops also potentially non terminating, so clearly, because because general recursion

1:09:17  
brings in non termination, stronger malice. it contradicts strong normalisation that we had in typed lambda calculus. So in typed lambda calculus, you can't code up general recursion.

1:09:30  
You can throw within this primitive, and then you destroy strong minimization. And that's what you can do. But the different approach, of course, is throw away types. In an untyped case, actually, you can do general recursion, then all of the type checking is off. We are in untyped, lambda calculus, you don't have any of that. But actually, you can encode general recursion. So as soon as you let go of the discipline of typed lambda calculus, you are in some sense on your own

1:10:00  
Yeah, then you know, the,

1:10:10  
the control by the class teacher on you is gone. Yeah, nobody checks your times.

1:10:16  
But this means you're free, and you can do more than what you could do before.

1:10:20  
So here's a trick from where you can get general recursion, I previously told you about these sort of nonsense terms omega that go on forever, but they are nonsense from the point of view of pipes. But they are very good thing from the point of view, or if you actually on purpose, want to have recursion. So, so this y f here, for any F

1:10:42  
is kind of a modification of omega, where instead of just saying lambda x, x x apply to lambda x x x, there are these little F's plugged in, you can see self application of x to x as before, but now that is the F into places, why f has their interesting behaviour, that not only does computation go on forever here,

1:11:06  
in general, or at least, this is one of the possible reduction strategies Delta knows.

1:11:11  
But it actually produces something while it goes on forever. Remember, when you read when we have omega,

1:11:18  
so

1:11:19  
omega was a simpler version, omega was

1:11:24  
lambda x x x applied to lambda x x x, omega had the property that if you start simplifying, it just produces itself. So it's not very interesting.

1:11:39  
This one produces something. So why applied to any F is this thing by definition, if you think what happens when you simplify the outermost radix, namely, this application, sorry, this lambda abstraction applied to something,

1:11:56  
what happens is you keep the body for the two occurrences of x.

1:12:02  
The parameter, you put the argument, which is this guy, as the result, you get this,

1:12:11  
which is exactly what you had before, but there is one extra F in front,

1:12:15  
then with this F in the general case, so for example, if f is in variable, you can do anything. But why F, you can reduce again, following by exactly the same thing that we did. So you get another f outside, and yet another F, and yet another F. So it allows for these non terminating reduction sequences, of course, for specific F's, for example, if some if the nails, and sometimes the guard is true, of course, it's possible that

1:12:41  
you don't look at one of the branches, which then is a recursive one. And you can actually get out

1:12:47  
of the recursion. But, you know, the outermost strategy gives you this.

1:12:52  
So this Why is not possible. You don't have it in simply typed lambda calculus, you don't have a polymorphic type lambda calculus either. But the untyped lambda calculus is there. And then with this, you can actually write any function you want. Not following structured recursion, which says, You know, I don't know for a number, I always can only make a recursive call on a strictly, you know, on the predecessor number, but something that allows you to use recursion in whatever way. So here I use it to define the factorial function, which actually, you could also do with structural recursion

1:13:27  
using fold, which is allowed, but if you want to do it with general recursion, what is the trick?

1:13:34  
Well, the trick is, if you want to obtain a turn f such that f would reduce to h f, in some number of steps, for some fixed air for some fixed age, then you can just define F is y h.

1:13:54  
Great. So then one of the things I could do, I could abstract what is going on in the definition of factorial.

1:14:01  
So

1:14:03  
the recursive definition of factorial

1:14:17  
is this.

1:14:19  
Yeah.

1:14:20  
factorial prime is

1:14:31  
great right thing now.

1:14:35  
Yes, factorial prime abstracts out what is happening in the factorial, which is you do a test on whether you're given number is greater than zero in the base case. It's one the result of the factorial otherwise you make a recursive call.

1:14:50  
Yeah.

1:15:04  
There's something I badly don't like

1:15:10  
okay, yes

1:15:37  
then we have to define factorial as perfect.

1:15:42  
Let me rewrite it here

1:15:53  
I should rather want to say something like factorial is

1:15:57  
why applied to

1:16:04  
and then you have to abstract out from

1:16:08  
from the factorial definition respect prime. So, it will be Wirefly lambda fact prime, and then all the rest of lambda n

1:16:19  
greater than 01

1:16:22  
n times factorial prime and n minus one.

1:16:30  
So, this line is not completely okay,

1:16:33  
it should. So this is kind of a specification of what we want, but in the end, we need to abstract out the fact prime here from another with another lambda. So, if you do this, and then you start reducing factory for any given t,

1:16:48  
then you will see that it actually

1:16:53  
will reduce to this. So that, and that is precisely the behaviour that you would expect of your recursive factorial. programme. Right.

1:17:05  
Okay, um,

1:17:09  
I think we're done with time and everything

1:17:16  
are the questions about either natural numbers, or, for example, this recursion thing.

1:17:29  
I won't ask you to invent these coatings by yourself, there is a method behind coming up with these. So for example, you can really systematically also work out what's the way of coding up threes, or less or option or, or pairs or triples. But

1:17:50  
rather, I want to get across the message that

1:17:54  
similar to maybe Turing machines, if you've seen them in discrete maths or wherever, are kind of the universal

1:18:02  
computation paradigm for imperative programming that you can reduce everything to by complicated coding, then the same is actually the case for functional programming and lambda calculus or lambda calculus kind of the same for functional programming as our Turing machines for imperative programming.

1:18:23  
Of course, in real implementations, you don't go down all the way to say

1:18:30  
polymorphic lambda calculus with this complicated coding for data types. There are many reasons not to do it having to do with efficiency, for example.

1:18:40  
But in principle, this is doable. And what you typically do is in compiling functional languages is that you have a small core

1:18:49  
A variant or a small extension of lambda calculus and everything else that you have in in your language is compiled down to this little core. And that is actually the the thing that needs to be executed in a virtual machine of sorts. And everything else is compiled away before you before you get to,

1:19:08  
to,

1:19:11  
to running

1:19:13  
anything.

1:19:15  
Yeah.

1:19:21  
Okay.

1:19:26  
Let's fix the typo on this slide. And I put the new version up

1:19:31  
and

1:19:33  
I think I'm done here.

Transcribed by https://otter.ai
1:28  
Good day Taiwan

1:37  
Hello

7:24  
hello

7:29  
are you doing?

7:37  
Let me check if you can hear me properly? Yes, right here. Very good. I can't hear you very well, it Make it louder.

7:51  
Okay.

7:57  
Right.

7:59  
So we'll go to imperative programming today. And we'll start discussing features in languages like C

8:08  
and its relatives and Java and Python.

8:14  
So do something different

8:19  
in some sense more low level because we will in particular look at languages with with very weak type discipline and also languages where you

8:30  
do

8:32  
fine grained

8:39  
manipulation of memory and in particular manual manipulation of memory.

8:47  
Someone wrote that the sound quality dropped, is it still the case?

8:58  
Can you hear me well? Okay. Yeah, maybe it was something accidental.

9:04  
Okay, so yes.

9:09  
So these are maybe languages that you've seen more,

9:13  
depending on your background, whether it's Python,

9:17  
or Java, or for especially systems programming,

9:23  
C, and C sharp.

9:27  
And I'll start with something very simple and nice today.

9:32  
Where you can't do a lot. You can just write if and wines but differently from

9:39  
sort of functional language setting, you actually manipulate memory in

9:46  
in a mutable ways, we're no longer in the functional situation where variables don't really vary, but they have the same value throughout their lifetime. This is the main thing that is different and then

10:00  
Slowly, we will start moving towards a C like language. I'll start with this today, it works out, but it will surely also take Thursday and and also next Tuesday especially when we come to compilation, and when we come to versions of the language where you manage manually manipulate

10:25  
memory usage. So, you do your own memory management like in like in C, where you have to say allocate memory for this data structure

10:35  
deallocate memory

10:38  
and we discussed all the insecurity and unsafety that follows with this,

10:44  
what kinds of crazy things one can do? Okay, let me start sharing my screen

10:52  
maybe like this.

11:06  
So, yes, what are imperative languages imperative languages are the ones that you're most accustomed to. In many cases, they also come with objects.

11:18  
So object orientation objects and classes, but that's not strictly necessary, it depends on the variety of the language.

11:27  
But the main thing is you work with statements or commands primarily for manipulating memory.

11:37  
So, while in a functional language, you work with expressions whose primary point was to compute values,

11:47  
and maybe if you added some impurity to a functional language, you could also do other things like we discussed references

11:57  
in F sharp.

12:00  
So they are a way to integrate something imperative to

12:07  
functional first language. In an imperative language, everything is upside down. So there are expressions whose primary purpose is to compute the value. But the main syntactic category in an imperative language is always statements, also called commands, these two are really synonyms. Some people prefer one word some the other but they do mean exactly the same thing.

12:30  
In particular, if you write an imperative programme, then the top level thing is not an expression, it's always a statement or a command.

12:39  
So if you look at that, say,

12:44  
whole file containing an imperative programme.

12:49  
This is treated as

12:52  
a statement or a command.

12:56  
So commands

12:59  
don't return a value, but they are there to produce some side effect. So the most typical side effect is your update, mutable memory or store. So there is this idea that

13:14  
there are names by which you can denote locations in the store or sells in the store. And

13:22  
x may have been for yesterday, today, I set it to be 17. And that's okay. Then tomorrow, I asked what it is now. And if no one else changed it, it's still 17 this is how you programme, you, you write to a store, you read from the store,

13:39  
you keep track of what you have allocated in the store, etc. But of course, there are other side effects as well. So apart from updating the story read from the store, as I already mentioned,

13:50  
you can also print,

13:53  
say to the terminal,

13:56  
or you can you can print to a file. And then you can read

14:02  
from the console, or from a file.

14:08  
So this is this is the big game. You're working with these commands, that are instructions to the computing platform to manipulate memory primarily. These commands are such typically don't return anything. Maybe they are sort of binary in the sense that they might return a flag of whether they succeeded or not. So in shell scripting languages, typically you get something like this, you can you can find out whether so far you've been faring well or not.

14:44  
You can see if it's just minus one then maybe something went wrong. But but the primarily commands are they're not to produce any value of interest at all.

14:55  
And you just sequence together those and you build other control structures around

15:01  
So we'll start looking at these things, we start with something very simple, which is sort of,

15:08  
yeah, the minimal thing that you can come up that

15:13  
that has these imperative features in particular manipulation of store.

15:19  
But also added printing, just for the fun of it. So it does a bit more than, especially since commands return nothing, then the only way to see anything coming out of the the programme would be to print it, if it doesn't return anything as such.

15:38  
And this very first simple imperative language that we'll look at, it really has very little. So it doesn't have local names, only global names, and these are not declared.

15:50  
And even these names are only for integers. So there is no interesting other types.

15:56  
There are no functions or procedures, procedures.

16:02  
And the memory model is really very simple. In particular, there is no concept of,

16:08  
of pointers.

16:11  
So names that directly hold values, you don't have the idea that the name maps onto an address, and then the address will somehow store a value. So we are more naive than this. Okay. So my idea would be that you should be able to write little programmes that would say like x equals three,

16:33  
y equals

16:37  
x times four. And maybe you can put the whole thing in a while loop that says y Zed is

16:44  
smaller than

16:47  
17.

16:49  
With do this, something like this

16:57  
is the level of programmes that we can write, and maybe I'm interested in seeing some final results, perhaps as well, maybe I want to see what the value of y is. Or maybe I want to see what the value of y minus one is.

17:11  
So you should be able to write these things, but not so much more.

17:17  
And the reason why we want to look at it is there is this interesting concept of store that we so far

17:25  
didn't see as such. So we always worked with these environments, that contained values for immutable

17:34  
names. So, we had names for integers, they would have denoted integers, we have names for functions, they do not the closures, which are sort of a syntactic representation of a function together

17:50  
with the environment in which it was defined these kinds of things.

17:54  
But now,

17:56  
there was no notion of mutable store, now, there will have to be one.

18:03  
So here in particular, for example, in this example,

18:10  
this construct says x, whatever value it has, will now have value three, y, whatever value it had before will have the value

18:22  
that we find by taking the latest value that X has the value that X has at this programme point times four.

18:33  
And then we print y minus one. And in these programmes, you can you can choose to, to change your mind about what values or things are. So for example, at the end, I could say x is now actually 1001, for example.

18:48  
So now explicitly, in this very small programme, you see that x is first three, and it is the value that is used here. But then, when we finished the programme x is different value.

19:05  
Is this clear? That should be very familiar, I should make some little remarks, I really don't care about the precise concrete syntax of any particular

19:17  
imperative language here, there is lots of little differences.

19:22  
So very often,

19:25  
assignment is written something like this with an equal sign, but sometimes it's written with colon equals

19:33  
I don't really care which one you prefer. So this is very sort of see like, and is present in languages that derived from their this using some other places. There is the big issue of where exactly you put semicolons. So

19:52  
in some languages,

19:55  
the semi colon is something that you put at the end of every primitive

20:00  
So you would require that there is a semicolon here.

20:05  
And it's not actually a separator in a sequence

20:11  
of statements. So while doesn't need any punctuation mark at the end, so in these languages, you maybe don't put the semicolon here, and this is just as fine, I will use the semicolon as a separator. So it will always go between two statements when I put them in a sequence, but it really doesn't matter. And there are so many other differences. So some typical ones are around wine. So for some people, while it's typically written something like why an expression for the guard do a statement for the body, but it might be different. So again, in a C like language, you would maybe write something like this, maybe officer, maybe this is required to be a block.

21:00  
Similar things happened with if then else, the syntax might be

21:05  
something like this.

21:10  
But it also might not come.

21:14  
But it also might not contain the word, then it could be something like this. So all of these options are possible, but they don't really matter for us at all. So in any

21:25  
particular programming language that you're learning, of course, you have to know what, which which convention has been adopted. But but it's really the least important thing in the whole our business. So we don't concern ourselves with this.

21:41  
It is a bit of a concern, of course, when you write a lexer or parser, or if you use a Lexie, lexer parser generators, so which is automatic software for getting elect lexer parser then you have to be to think very carefully about what your syntactic conventions are, and whether everything is unambiguous. And sort of what is

22:04  
what is convenient for the programmer, what gives clean code in terms of

22:12  
enough punctuation for readability, but not too much either.

22:17  
So you don't get any clutter on the screen that you can't see through.

22:21  
But anyway, so, this is the language that I want to discuss, I will provide you with some abstract syntax for a language like this. And then we discussed what does it mean to to evaluate a programme in such a language. So what kind of infrastructure is needed for this? And

22:44  
later, we also get to things like compilations but but for the moment, just just some abstract syntax and an evaluator and some simple examples to get started.

22:56  
So what did I say I said,

23:00  
in an imperative language, almost always you will have at least two syntactic categories, maybe some more auxiliary ones, you will have at least expressions

23:11  
which in a functional language were the main thing and often the only thing maybe aside declarations.

23:18  
So here they are not the main thing, but they are something too.

23:25  
You can write that will stand for

23:29  
stuff that return values while under suitable circumstances. So the expressions will not be surprising, you will have numerals for integers.

23:41  
And we use strings as identifiers as names for integers.

23:49  
And then you can write

23:55  
up operator expressions something of the form

23:58  
you want often.

24:03  
Yep, like plus times a minus. And these operators themselves were all sort of represented by strings. So it's, it's not the fixed supply of operations here, but any string will do well, of course, we won't assign any string of meaning.

24:18  
Okay, what could be a minimum set of of statements or commands to work with?

24:40  
We will have assignments, and I'd write this

24:46  
and I'm not sure how I will write this. I will write this actually without a colon in the rest. So let me keep the same here. So we will have assignments and they are now not the same as the finish

25:00  
We're in a functional language, the idea of an assignment. These

25:05  
names always denote integers, but they can be integers that evolve over the time or the integers don't evolve, of course, but you know what integer, the name takes advantage of this evolves over the time

25:19  
over a program's execution. So x maybe has some value when you reach this point, but that doesn't matter. What does matter is, you have to evaluate a

25:32  
recipe, the expression, and the value of that expression

25:37  
will replace whatever value x had before.

25:41  
Yeah. So

25:46  
the point being that

25:49  
maybe you had that X was too before,

25:54  
I can make a new assignment that I can say, no extra three.

25:59  
Or maybe I can say x is x plus one.

26:03  
And this literally counts as an assignment that you're used to from,

26:08  
from your first programming language, whatever it was. So it doesn't say that any particular x equals x plus one at some point in time, which is any possibility, right, any number is equal to this same number plus one, but it says X has some value that

26:27  
until now, and from now on, it will have any value,

26:32  
then what you do an imperative language is always you can execute several commands, or you can put them in a sequence. And this can be done in several ways. So here, I mean, you could just do binary composition, say if s one and s two are statements, then s one semicolon s two is a statement, that's a possibility. But we can actually say that the whole list of statements makes a new statement.

27:01  
And you often call it a block. Yeah, there is maybe even more reasons to call it a block, if the block can have local variable.

27:11  
local variables introduced here, we don't have it, the block is just a sequence of statements grouped together. But the point, the idea is these are executed sequentially. Okay,

27:23  
then, it's always good to have some form of if then, or if then else. And here is the one represented like this, I forgot to say before, so a block in the abstract syntax is given by a list of statements. So

27:41  
standing for this form, then also in currency, in concrete syntax, we

27:50  
would perhaps want to have some loop constructs, so for a while, or maybe just one of them.

27:58  
So let's have both

28:01  
both are constructs that have a body that is a statement. And then there is something that controls how many times or under what circumstances the statement is repeated. That's the idea of a loop. In the case of a for loop,

28:16  
in this little language, we will have a control variables. So you can designate one name that you say will change its value in the loop,

28:26  
initially, c one, and you will stop the loop

28:32  
when the value of x has reached D two.

28:35  
Yeah.

28:37  
While do is the usual while do so you.

28:43  
So long as the value of he doesn't become false, you just keep repeating as

28:51  
the first time that you've just finished doing so maybe you didn't even start. And you observe that that condition here the guard is false, you leave the loop, you're just done that the whole the execution of the statement has finished.

29:07  
And then we could for example, choose to have printing Yeah. So then I can also pick up

29:13  
I can print out something.

29:18  
So that should be not surprising.

29:26  
And there are little variations that you can allow here. So sometimes people in such a simple idealised language that could actually serve as an intermediate language for compiling a bigger one.

29:39  
You wouldn't use this enery composition or the block structure for sequencing. Maybe you just say you allow sequences of two commands and maybe also allow the empty command or no op. Why do you need that? When you typically need no up

29:56  
if then else because if you don't have

30:00  
If then as a specific construct, you might want to talk about the situation where in the then case you do something, but then the else case you do nothing at all, then it's convenient to have the sort of empty command or skip or no up

30:17  
around to use as the else branch.

30:21  
Is this clear?

30:23  
Any questions this far?

30:32  
One could make this even more minimalistic by just keeping one of the one of the loops. If you're systematic, then perhaps you keep, while you could argue that in some sense, this is more universal than four, but that also depends on the precise

30:48  
syntax and semantics of four. So here, we are fairly liberal with four on the level of syntax, so the bounds for the loop

30:59  
they don't have to be numerals, neither of them so they can be arbitrary expressions.

31:05  
And

31:07  
they can be any expressions. So

31:11  
in particular, even e one and D two can refer to x itself or they can use x.

31:18  
You might say, this is a bad idea, but there is nothing to forbids you to do this. And you can give a meaningful meaning

31:28  
to this case, as well.

31:32  
Okay.

31:36  
So suppose I wanted to write the language processor for such a thing. So maybe an interpreter, maybe a compiler to some,

31:45  
some abstract machine, maybe through some stack machine, or Yeah, some sort of a machine operating memory, working with

31:56  
little instructions, and then maybe jump instructions.

32:03  
What do we need for this? The main thing, and this is what distinguishes imperative languages from functional is that you want to work with some notion of storage, or store, or memory, all of these are synonyms, at least on this naive level, I will use the word store,

32:22  
like you know, a department store, where you can buy goods. So it's just a place where you can store values and you can repeat retrieve values, you might also want to call it memory.

32:37  
This is such a simple language. And this lecture will become very soon

32:44  
that we can work with a very naive idea of what the store is.

32:52  
In particular, this will be a notion of storage that we cannot afford anymore. When we start to have local names, then this just doesn't work.

33:04  
For now, it's good. We don't have any local names. We only have global names, I mean, any variables that you see, in your programme, you say these are global top level names. And you can just start using variables without declaring them. Okay, there is the question of where does the variable get its value first? Well, you may initialise the store in some way. Or you may require

33:29  
that the programmer initialises all variables that it's that he or she uses. So you may require

33:37  
that the variable doesn't appear on the right hand side of an assignment before it has at least once appeared on the left hand side of assignment. So for example, an assignment like this, you could say initialise is the variable x if it didn't have a value before.

33:53  
Okay.

33:57  
There is some little thing then to notice.

34:02  
So what we need to store there in the storage, so here, it can be very simple. We can map just from names to values. And actually, in a language like this, we can adopt a convention similar to C. And other languages

34:20  
that have a very weak type discipline.

34:24  
Especially they don't have any static checking often, sometimes not even enough dynamic checking, so that you can get really very, very, very bad errors and can't understand what is happening. Because there is no diagnostics. Things simply go wrong and you're not given any signal of aetherium

34:44  
which we'll see.

34:47  
For the time being since there is no interest in pipes anyway, we can do the see like thing that

34:54  
we don't need specific Boolean values, we just reuse integers as Booleans

35:00  
And the different conventions there again,

35:03  
but we'll use the one that says zero is false. And any nonzero number counts as true. So if you do things like if three, then

35:19  
execute x equals x plus one else, the empty sequence, then what happens is?

35:31  
This is true. So actually, always, x is incremented by one. It's also silly.

35:39  
If, because

35:43  
surely, it's a constant one, right? But we could just as well, right, if Why? Now, why is a name that stands for integer depending on whether the same feature is zero, or if it's anything different from zero, like three or minus three, we will choose this branch or the other branch, in which case we do nothing

36:05  
is okay.

36:07  
And then what is important about these stores is

36:15  
they will need to allow

36:20  
that values of variables change. Now, this can be done in multiple ways, the naive, and the wasteful one would be when we, when we write an evaluator in F sharp would be to say that,

36:38  
each time I execute the command, I start from some store, and then I just return another store,

36:46  
which is basically a copy of the old store with all the appropriate changes.

36:52  
But this is pretty wasteful, because I have to copy the store over and over again, I mean, the moment that the increment my variable x, and don't change any other variables, the whole data structure will be copied. So that feels maybe a bit stupid. So

37:10  
even if, sort of ideally, you can use immutable data structures, dictionaries, as a model of store, simply each time you do something, you do get the new store, it's maybe better to work with immutable data structure. And that's what he's done here. So we met from names to values, but in a, in a,

37:37  
in a mutable data structure. And here's a little infrastructure for this, we just use

37:45  
f sharps

37:46  
map

37:49  
types.

37:51  
So these are dictionaries, but they are implemented more efficiently than the ones that we had. So we worked with lists so far,

38:01  
which have two issues. One is, of course, lists are immutable. The other one is look up in lists is also slow. In the sense that to find the key in a list, you have to in the worst case, walk through the whole list, and find your key at the last position is the least or maybe not find it at all. So of course, it's better to use some sort of tree based hash based structures for this. So map is

38:30  
provided for you. And that's something a bit more clever, but it really doesn't matter. So, the important things is there should be some notion of a store type

38:40  
that that can work with.

38:44  
And we should be able to create an empty store we should be able to extract

38:51  
a value based on a key from the storage and we should be able to

38:59  
change

39:02  
the value in the storage.

39:15  
Yes.

39:19  
Did I already say something wrong? I did. So I jumped ahead of myself. So

39:24  
with maps still.

39:27  
We do actually do get we don't do this immutably so set storage will take a storage and will actually

39:37  
return a store.

39:40  
So that's what comes back. Where as when when I get this thing there

39:47  
then I just get an integer back. So these are the four types.

39:51  
Okay, um,

39:54  
but yes,

39:56  
but but in an even better implementation you you do go

40:00  
And use immutable data structure. So then set store doesn't return anything, it is a command in the sense of F sharp, it turns return something of type unit, but it will have changed the existing

40:14  
store.

40:17  
Okay, then

40:21  
how would one evaluate expressions and statements.

40:26  
expressions are very similar to what we've seen in, in the cases with with functional programming, there is really no difference. There, we evaluate expressions based on whatever

40:44  
we could find in the environment. As we looked up things in the environment, now we look up things in the store.

40:53  
Using this function gets stored here, that is actually implemented via

41:00  
the function item,

41:02  
which is part of the interface of this type.

41:09  
So what are the cases this just goes by case distinction. So if your expression is a variable, all you need to do with this, you're given a store, you look it up there, and you get back a result, which is an integer.

41:28  
The other cases are, what you're given is a numeral, its value is just the integer that is present in your numeral. And if your expression is an opera operator applied to two expressions, then you need to evaluate those

41:46  
with respect to the given store, in this naive store format, where values are directly associated to names.

41:55  
And then you just apply one of these operations that are supported, let's say there are times plus minus, equals

42:04  
maybe right, double equals now frequent quality check, it doesn't really matter, less than

42:11  
okay.

42:13  
But the more important

42:17  
stuff is here. So how does one execute statements, statements don't return any value of interest, but here they modify the store. And the way we model it is, we run a statement in a given state of the store, and we do get back a new store.

42:43  
Yeah.

42:48  
How?

42:51  
Well what can What can a statement be

42:56  
it can be one of the five or six forms, it can be an assignment, it can be if the nails it can be a block.

43:05  
It can be a for loop while loop and it can be a print statement.

43:18  
The simplest of these is assignment.

43:24  
So what do we need to do, if you need to change the value of x based on the value of E,

43:31  
then you should evaluate e in the current store the given store

43:42  
and then you should produce a new store. Or if it's done beautifully, then you should just update the given store. So that at key x, you now have a new value. So if x before was to now maybe the 17 if evaluating e with respect to storage to store gives value of 70.

44:09  
if then else is very easy. And this is why we look at it even before block.

44:18  
So if then else has to be lazy in the sense that we do not evaluate too many things too early. So we evaluate the expression

44:31  
with respect to the store store.

44:34  
If

44:36  
the result is true, so any number different from zero, then we actually recursively call this function that we're currently looking at.

44:47  
To the then bronze which is statement one

44:52  
and in the same storage

44:55  
because evaluating the guard doesn't change the store in any

45:00  
Way,

45:02  
at least not in the simple language. In a more complicated language like C or Java, I can easily do.

45:09  
Okay, so then

45:13  
if

45:15  
the Boolean is zero, then instead, we treat the boolean value as false, I mean,

45:22  
and we execute the then branch, and nothing else needs to be done.

45:34  
What if I've got the block, the block is a list of statements.

45:44  
Well, I should traverse this list of statements, and execute every single one of them.

45:52  
But now, the important concept is I need to thread the thread through the store, I need to start with a given store, then I need to execute the first statement in the list of statements.

46:09  
This produces a new store. And that new one is the one from which I continue with the second statement, the second statement,

46:18  
changes the store again, in general produces a yet newer store. And the third statement has to be executed from that store, so to say. So this is called threading the store through, it's not the case, that every statement here would be

46:39  
started from the same state of the store that would be kind of parallel composition. But instead, instead, we execute the statements sequentially. So how do you programme this? Well, the easiest is you write a little helper

46:57  
for traversing the list. But the main thing is, you call the helper on the whole list. And

47:05  
the second argument stored here is is for

47:11  
for an accumulator of sorts, which initially is the given store. But then a new recursive calls will keep changing. Yeah.

47:23  
So if the list of statements

47:26  
that the helper is called on,

47:29  
sorry, the helper is defined here, we're defining look at statements and store and these will now vary, they need not be the initial

47:38  
ones. When,

47:41  
if the list of statements is empty means we have reached the end of the list, then we just return the store that we last produced.

47:51  
Otherwise,

47:53  
if the list of statements is of the form some first statement and more statements,

47:59  
then we execute the first statement from the given store.

48:03  
This produces a new store. And from that one, we recursively, carry on with a helper

48:12  
applied to the rest of the statements to every other statement in the list. And this way, you will go through all the statements in the next

48:28  
what next,

48:33  
maybe I should take wine next. That's actually also a little bit simpler than four.

48:40  
So a wild construct is given by a guard.

48:47  
And a statement,

48:49  
which is the body of the wild.

48:56  
This is also implemented in terms of helper the helper is called loop. And it uses

49:02  
a store as an accumulator. And initially the store is the given store.

49:07  
But then it keeps changing in the loop.

49:10  
So what does the loop do from a given store store?

49:17  
Well, it's time this is called again, we evaluate

49:24  
the guard again, in whatever the store is. Now, if the result is zero, then we're done. Then we leave the loop that corresponds to the case when the condition is false.

49:37  
Otherwise, we loop we call recursively our helper, but

49:45  
from a store that is obtained by going through the loop body ones executing the loop body ones, so either you do nothing when the guard is false or when the guard is true.

50:00  
If you execute the loop body from the store, you get the new store.

50:07  
And from there you loop on.

50:12  
Finally, and this is the tricky one, because there is also some choice about how you do

50:20  
it, let's do, let's take the for loop.

50:26  
So what happens here, the for loop is given by the control variable, then the expression determining with the initial value of the control variable during the loop, another expression that says when the loop must stop, so this is the value of such that when you've reached it, or when you've exceeded it, rather, you should no longer keep repeating.

50:54  
And then finally, there is the loop body.

50:59  
Now, this is the standard semantics, which is reasonable, which says,

51:06  
well, surely to get going with a with a loop, I should at least evaluate

51:14  
the first expression because that says, what is the value from which I need to,

51:33  
from which I need to,

51:38  
with which value of x i need to start the loop, right.

51:42  
But actually, it also makes sense at this very same point to evaluate once and for all, and not keep re evaluating it. But this is debatable.

51:52  
The other expression which says which would then given number,

51:57  
that will be the value,

52:01  
which will determine when we'll finish the loop. So once this value is exceeded, we should stop going

52:08  
around in the loop. Now how is the loop itself done the loop we can again do with a helper.

52:18  
But now the helper uses to accumulator

52:25  
to two accumulator arguments. One is for the current value of the control variable, which initially is whatever we get here. So it's the it's the value of the expression he start

52:42  
in the initial store.

52:45  
And the other argument is initially the initial store this one?

52:51  
Uh huh. But

52:59  
then these two things

53:03  
will append new values when we

53:06  
recursively call the helper again.

53:10  
So imperatively thinking this

53:15  
should actually be mutable. But now we implement this via recursion.

53:20  
So we recurse

53:29  
Yeah, so sorry. So the helper loop is defined recursively. And that is the definition. So what is done,

53:37  
whatever is the current value of the control variable,

53:41  
whatever is the state is the current state of the store, we do the following, we compare it to the value stops that we found once and that we never reconsider.

53:55  
If it is no greater, then we don't enter the loop or the again.

54:01  
Otherwise,

54:05  
what we do is actually we set the control variable to I. So this gives us some storage.

54:13  
Then we execute the statement in that storage,

54:19  
which gives us the new storage. And then we recursively call the helper again.

54:27  
But now no longer with it, but i plus one as the current

54:34  
value of the control variable.

54:36  
And

54:40  
then also

54:45  
Yeah, in the new store, so maybe I should I could

54:53  
write it out, maybe more stepwise. So what happens here is in the else case,

55:01  
Is that we do a whole bunch of things. So first we change the store a bit.

55:07  
So we,

55:09  
we set

55:12  
the value of x to y, x to I in the store. So this gives us a new store.

55:18  
Yeah. Then

55:22  
we execute the statement, the statement in this store, and we get the new one,

55:28  
maybe like this.

55:34  
Right.

55:36  
And then we recursively call loop.

55:42  
But again, in the newer state of the store,

55:48  
that's exactly the same as what was written here. It's just that here, I didn't use these intermediate names for these sub expressions here. But maybe, to see the order in which things happen. This is maybe more illuminating.

56:07  
And now at this point, you should perhaps ask is this all kind of right to do?

56:14  
Because various strange things can happen. This

56:20  
control variable, of course, may be modified in the loop body. So maybe x is my control variable, but maybe the loop body also changes this control variable, then what should happen in the loop then, and you may have sort of very different ideas

56:39  
about this. And this is not the only possible semantics for for loop. And here's the issue. So for loop, what a for loop does, it's very clear when this thing is just the numeral. And it's also very clear when statement doesn't contain any assignments to x.

57:00  
But, but if statement, if this statement here contains assignments to x is no longer so clear what what even the right meaning should be. So here, it's fixed in some way. We can look at examples.

57:15  
What happens in strange programmes, and I will do this shortly after the coffee break. But

57:25  
yes,

57:27  
the moment that you start to write down a language processor, even for such a simple language, you will start to ask questions that often you don't ask yourself.

57:38  
Typically, because you use the for loop in a certain way.

57:43  
I mean, with sufficient hygiene, you keep names sufficiently apart, you follow certain conventions. But

57:51  
these conventions are not mandatory, you're also allowed to write programmes that use the control variable in strange ways. And then all of a sudden, it becomes an important question to decide what is supposed to happen, because the language processor

58:08  
should probably follow some intended semantics of the language. And then the question is, what is this? And does every programmer understand it the same way?

58:18  
Okay, let me maybe show you some examples. Before we go on, take a break, and then I'll show you some other examples after. So

58:33  
what can I do here

58:48  
I can write little programmes. And, of course, they do get verbose in this abstract syntax. And so I'll also show

58:56  
how they look

58:58  
if you

59:00  
if you write them in concrete syntax, so here is maybe one of the simpler things that you may want to write

59:07  
is a programme that involves two

59:11  
variables, two names summon it I

59:16  
and it just sums numbers from a certain interval and the interval here is actually

59:23  
fixed, it is numbers from

59:29  
zero to 100 inclusive.

59:33  
And all that it does is it adds together these numbers and then finally, it prints the sun.

59:40  
So when you want to formalise this as abstract syntax tree, you have to think what is going on here? Well, the whole thing of course, is a sequence or a block even. So with braces we do know that so we have a block. In the block we have three things. That is assignment, there is an assignment, which is this there is a for loop, which is this

1:00:03  
And then there is a print command.

1:00:07  
Afterwards

1:00:10  
in that the assignment looks like this.

1:00:15  
So

1:00:18  
to the variable sum, but the left hand side is always a variable, I don't need to say var here, an assignment simply takes a string some, I assign an expression, which is numeral zero, which is perfect, then there is a for loop. It's determined by two expressions, which are very simple here, because they're just numerals.

1:00:37  
And the body isn't even a block it need not be because it's a single command. So I can just straightforwardly state it as a command, which is an assignment.

1:00:47  
And of course, here on the right, I can't write simply some,

1:00:51  
but I have to write var, some because some is not an expression with var sum is similar for var I.

1:01:00  
And then at the end, I want to print again, not sum, but var sum. So let's see if this is a valid expression. Or sorry, a valid statement.

1:01:20  
So F sharp indeed thinks this is a valid statement. And then I can

1:01:27  
start running it, what does running mean? Running means executing a statement in the empty store. So if every variable is initialised,

1:01:37  
in the programme, then I don't need any interesting store to to run it, I can run into the empty store. Let's see what happens.

1:01:48  
I say Ron, next one. And the result is the naive store.

1:01:54  
So this is that implementation. Now that replaced lists here, where it is 100 doesn't Assamese 5050.

1:02:05  
So you can see that I took various values during its lifetime, but at the end, it was 100.

1:02:14  
And then this was printed out.

1:02:18  
Okay, maybe this is not convincing, maybe we should want to see some intermediate results. So

1:02:31  
here is a little variation. That's also just for the fun of it use these while instead of four. So a different way to do this is I initialise, some to zero but I also initialise, I don't say one or zero doesn't matter.

1:02:48  
Maybe I should actually put zero to complete your line with this.

1:02:53  
And then

1:03:00  
we could do this for example.

1:03:07  
Okay, let me first keep the values that are there, but then we can do also the variations. So here, the, the programme is also different in in the sense that we don't actually control the loop by the value of AI. But we actually check

1:03:24  
how much the sum is. And we are willing to sum as long as the sum doesn't exceed

1:03:33  
10,000. And here's the here's the code. But we look at all intermediate sums. And then we finally look at the final is the final sum.

1:03:45  
If you were to formalise it, it's very similar to before, but now of course, the body of the wine isn't the single

1:03:53  
command. But it's a sequence of commands, you have to make it the block for this to be syntactically valid, to kind of put parentheses around the whole thing.

1:04:04  
Otherwise, then we are fine.

1:04:08  
So let's look at that one as well.

1:04:12  
Yes, so I've shot like Dewey's that this is what it is, and then when I

1:04:17  
run it,

1:04:21  
then I get the whole bunch of numbers,

1:04:25  
a large number

1:04:28  
which are the running sums of adding together stuff. So zero, plus one plus two plus three plus four plus five plus six plus seven, you can follow that these are correct. And then it goes a long way and at the very end,

1:04:44  
we print

1:04:47  
the eye that was reached and also then the first some that actually exceeded 10,000.

1:04:52  
So between this and this number, that is 130 41. So we would have continued if the loop had

1:05:00  
allowed us with the, with the, with the value of it being 142.

1:05:05  
and here also you can see what the final storage was that was reached.

1:05:15  
Now, of course,

1:05:22  
we don't have to initialise all the variables, ourselves. So I can also maybe do this little modification that

1:05:31  
say we do

1:05:33  
the modified first example, where say the sum is not initialised.

1:05:40  
Here.

1:05:47  
So that's exactly the same as before, except

1:05:53  
the first guy is gone.

1:05:56  
And then we have to run it in a different way, right?

1:06:16  
Yeah, no, I can't run it naively.

1:06:34  
until we find the whole point, just in case.

1:06:58  
Lucky today.

1:07:01  
Maybe this is the perfect time for a short break. I think it is that

1:07:07  
I think I can also fix this quickly, and then we'll take a short break here.

1:07:20  
Okay, so that was it. So now we have also.

1:07:29  
Now we also have x one prime.

1:07:32  
And when I try to run it, of course, it will complain because it will try to find

1:07:42  
a value

1:07:44  
for some at this place. And initially, there is nothing. So this can't quite work.

1:07:52  
And you get a lot of complaints. But the real one was here, the given key was not present in the dictionary. So that's about this something here. But then actually, of course, I can provide my own

1:08:06  
store to the thing. So we can just execute the thing in say,

1:08:18  
not the empty store.

1:08:21  
But we want to do set store.

1:08:26  
Which order are the arguments?

1:08:29  
Yes, set store empty store.

1:08:34  
And then give some value for the sum.

1:08:39  
For example,

1:08:41  
that sum is zero.

1:08:49  
And that is fine. And it works right then now of course, I can start with the different sum. So let's, let's make it something where we recognise what the correct value is. So now we should get a bigger value simply.

1:09:03  
So instead of 5050, it will be 15,050.

1:09:09  
So that's not so complicated, not so controversial. So let's take a short break, and unless you have questions, after that, I want to discuss the semantics of for a bit, because this was a particularly simple case of a for loop. And what happened was intuitively correct, that

1:09:28  
it's not so clear, that this is the only possible meaning if if things happen in the body of the for loop. So for in particular, if I here would actually be assigned something in the body of the for water, maybe I occurred

1:09:45  
here in this top expression. So then we have to discuss whether what we wrote was correct or whether it's some other modifications that we may intend is correct. Is there

1:09:57  
any questions?

1:10:12  
Okay, if there are no questions,

1:10:16  
then I suggest we take a break.

1:10:20  
Maybe a little longer can we say like until 335. So that's eight minutes.

1:10:27  
And then I can continue for another 2025. And we won't do a lot today. So I'll discuss the semantics of for loops. Maybe I'll give you

1:10:40  
a preview into what we will add, which are pointers, but I don't think we will get there. I think it's more important to to understand this manipulation of storage and what are the possible variations here?

1:11:00  
Okay,

1:11:04  
good, so break until

1:11:10  
335

1:11:16  
just

1:19:41  
Okay so let us continue let me share my screen

1:19:49  
again

1:19:51  
everything good theory yes

1:20:00  
So we saw a few programmes, let me just keep writing here, underneath

1:20:09  
where it was

1:20:12  
clear

1:20:14  
what should happen. So let's just go by modifying the first guy here.

1:20:21  
And let's write some variations.

1:20:32  
I've got a few worries.

1:20:35  
So one is, for example,

1:20:38  
what will happen if we modify this programme that we had by saying something like the sum is sum plus i.

1:20:55  
But then also, maybe we say i is

1:20:59  
i times two are

1:21:04  
in the loop. Now, what should happen?

1:21:12  
Maybe I'll modify also, so that it's uncontroversial. Let me start from equal one.

1:21:21  
Because if we multiply zero by two, we never get very far. But we start from one in the loop of the body, I increment the sum by I,

1:21:33  
I multiplied by what should happen, the first time that we enter the loop,

1:21:39  
I is one, I think this is non controversial.

1:21:44  
Then here we say I is iper, i times two, we could even say print I also in the

1:21:52  
inside the loop. And let me let me create some more structure here for you so that it's visible what is happening. So that's the

1:22:01  
structured rendering of the of the code.

1:22:07  
Now, what do you think I hear is too.

1:22:12  
Well, where do I continue? Maybe I continue with i equals two anyway, at this stage, but then I do my addition, then I multiply it by two is four in the next repetition will ID three or will it before?

1:22:30  
And what is added together?

1:22:34  
And how many times do we execute the loop?

1:22:38  
Let me maybe modify it a bit more so that we will also see a bit more so let's do the loop from one to 10.

1:22:49  
Well, we can check what happens but for that we need to write it up in our abstract syntax, but that's not so hard.

1:22:55  
It's a small modification of this piece of code here

1:23:00  
then we can play.

1:23:03  
So, let this be example three. So sum is zero, I is from one to 10

1:23:11  
then we have this but actually we want a block structure here.

1:23:18  
So this is a block

1:23:21  
and in this block we have all these things

1:23:30  
right.

1:23:34  
In the block we also do is i plus two blah, blah, blah, etc. Then we finished the block at one point.

1:23:44  
And then we do this here inside the block what happens

1:23:50  
is we want to do i is eight times 2.2 to array

1:24:00  
please.

1:24:03  
Only

1:24:09  
variable to print pie.

1:24:17  
This should be something

1:24:19  
that should do something. Let's see.

1:24:30  
What is unexpected

1:24:55  
think this is thinking quits to

1:24:57  
know what

1:25:03  
Now you can help me.

1:25:06  
That's one it's correct.

1:25:08  
Everyone is correct.

1:25:11  
Correct.

1:25:14  
This one is not correct. Okay, so here are some things happening. I'm not finishing my four

1:25:22  
bit problem. So it should be like this.

1:25:31  
I'm not sure who is tabulating here.

1:25:39  
Okay, so that's an expression. And we can see what happens. So when I run x three,

1:25:50  
when I open, and then I run x three,

1:25:56  
then I don't get something. Um,

1:25:58  
and we can observe what

1:26:06  
interestingly,

1:26:10  
the way I develops is like this, we can see that

1:26:21  
we can't directly see what it is, but we can see what has been added.

1:26:26  
Sorry.

1:26:29  
What is happening? print the

1:26:33  
patient, zero push to be one.

1:26:37  
When you assign it to the block, extra policy?

1:26:46  
Yes. Can you tell me what exactly is it? Okay, I guess.

1:26:50  
That's what I didn't like. I think that's better now, although I'm still surprised.

1:26:59  
Zero is from one to 10. Yes. And the rest is correct. I hope

1:27:23  
this doesn't change so much. So what is happening? Let's see.

1:27:27  
I think still, I'm doing something wrong in some other place. So

1:27:36  
I know it's good. It's good. It's good. So we print out I,

1:27:41  
which is

1:27:43  
cool. 468 10. So from this, we can figure out that before we multiply by two, it has been 1-234-567-8910.

1:27:59  
So the fact that we multiply by two, so say, for example, that it's here, six,

1:28:07  
it doesn't mean that in the next time when I enter the loop again, that it would be seven, and that I would then get the result 14.

1:28:18  
The Loop just goes sort of at its own pace, right.

1:28:23  
It had to use i equal 1234567, blah, blah, blah, blah. And what we do to Why do I here has very little significance. You can also see here from the final result, 55, which is the sum of numbers from zero or one to 10. Yeah.

1:28:46  
Yeah, the whole difference. So even whether I started here at zero, or one didn't matter, so much it was it was just the first guy is different. But since the each time I entered the loop, again, the the value of it is set, you know, based on the kind of internal accumulator that we have in the implementation of the loop. It doesn't matter that multiplying zero by two doesn't ever take us off the ground, right? Because that guy still will add one, two, first 012, etc. So that works well. So is this the intended semantics for for loops, or isn't it?

1:29:25  
Well, you could say these, but you could say it isn't just depending on what your taste is. And then you could go to your favourite programming language, type in the programme and see what it does for you.

1:29:37  
Because

1:29:40  
you could also say this is garbage, this should never happen, because

1:29:45  
this for thing he should increment i. But surely, if I changes in the loop, I should be able to take this into account, right.

1:29:55  
At least this is what happens in C style loops that you just specify by

1:30:00  
Given a control variable, giving something that is done each time you go through the loop and then giving something that is that is checked at the end of the loop.

1:30:11  
And in C style loops,

1:30:14  
surely,

1:30:16  
you know, whatever you do to your control variable, it will affect the whole loop it will affect the next repetitions. So, here this doesn't happen From where did this creeping? And do we want to keep it?

1:30:29  
Well, it must have crept in here when we were we defined for so this was one particular definition. And we chose

1:30:38  
to do exactly this. So, what decided this behaviour was the following.

1:30:46  
I is

1:30:52  
kept, is an accumulator for this helper loop. So help the helper loop keeps track of it. So, initially, it is determined by the start expression.

1:31:04  
And then at every recursive call,

1:31:10  
we just

1:31:13  
make the recursive call with the new value of the accumulator, which is the old value of the accumulator plus one.

1:31:20  
And we pay no attention to what has happened to the storage, isn't it?

1:31:31  
Well, we use the value of AI by sort of updating the storage, but we never read from the storage, we don't ever check what the value of x is in the store.

1:31:43  
So we could try to modify it and then we get the different semantics for for

1:31:53  
let's see what we do.

1:31:56  
We should make a little comment this is

1:32:03  
this is what usually

1:32:06  
what, oh,

1:32:22  
let's do our own version. So what could we possibly want to do?

1:32:27  
I might want to do the following.

1:32:31  
Let's also write that in this style. Maybe this is better readable. Or you can write more concisely.

1:32:38  
So let's write our own.

1:33:00  
How could we ever take into account but to take this into account. So here's the current accumulator, we compare it to stop that's very good. Then we update the store based on the accumulator. That's the one in which we execute the loop body.

1:33:18  
And then we repeat, but we don't look at what the value of x is, in the newest version of the store, which is store prep time. Rather, we continue with i plus one. So let's do something different. At this place, we don't really need to write i plus one we could write, we get store,

1:33:39  
store plus storage,

1:33:42  
prime prime, and then x, isn't it? And then add one to that. Do you agree? So then we will also take into account the changes to the loop variable that we've

1:33:53  
applied during the loop of the let me just check the time putting the arguments in the right order. Yes, yeah.

1:34:00  
So how about that this is not so bad.

1:34:05  
Where's my code here.

1:34:07  
So the change would be don't use

1:34:11  
i plus one,

1:34:13  
we actually

1:34:15  
use AI, we have we, at the beginning of the loop body, we, we we we take the value of x to be that guy.

1:34:27  
And then when we leave

1:34:30  
the current iteration of the loop body, we remember what the value of x is currently.

1:34:39  
So the next time when we enter the loop body, we will have taken the value of x added one to it and written the new value back to the store. So to say, you know, speaking in imperative terms, is this reasonable? I think it should be provided I got all my parentheses right. So let's try

1:35:01  
Block following this left is unfinished. Yes, because I forgot to copy something.

1:35:19  
There's some other interpretation or similar mistake.

1:35:26  
store with line 133.

1:35:38  
Raise your IQ

1:35:55  
another tabulation? I'm not sure from where these come?

1:36:05  
No.

1:36:07  
Let's see if we make a mistake in some other place. let let let Q,

1:36:14  
start stone.

1:36:17  
Can one of you see this?

1:36:30  
For me just on the fly everything here.

1:36:39  
Guess how much better I don't know what this editor is doing. So let's see our programme now.

1:36:47  
And let us observe if we have any,

1:36:51  
any difference in the behaviour.

1:36:55  
This is the piece of code, what do we expect should not happen? I expect we enter with one, then here we multiply one by two, then the next time we should go to the to the loop body again, we increment two by one, we should get three, we multiply three by two, we add one, then we shall already have seven. So we should only repeat the loop very few times. Let's see if this is what actually happens.

1:37:22  
We can then say

1:37:29  
then learn

1:37:31  
from one extreme

1:37:35  
when we get to 614 and 11, which indeed confirms that the first time went through the loop is one, then the next time we enter is three which gets multiplied by two, then it's six. Then the next time we enter is seven, which gets multiplied by two which 14

1:37:52  
and that's already greater than 10. So we won't go We won't carry on and what is 1111 should be the sum of the current eyes, which were one three

1:38:05  
and seven and there are some is 11 Yeah. So this is one possible semantics now, but there is one further issue with with loops. Namely, what happens

1:38:25  
if for example,

1:38:30  
we

1:38:35  
also use them

1:38:39  
use something non constant in the in the bounds here.

1:38:45  
So here we have

1:38:48  
because you saw before and let me do something. So here we had

1:38:53  
that the loop goes from one to 10.

1:39:05  
But why should they look go from one to 10 the loop

1:39:10  
this this this here could be something that is actually

1:39:19  
study, right? So it's already dynamic. So I could put in other things here. So So what about if I put

1:39:27  
10 minus some

1:39:32  
for example. So where do I need to put it?

1:39:36  
Here is this place so that would be

1:39:47  
minus

1:39:50  
10

1:39:54  
Sun

1:40:01  
And that should already be,

1:40:05  
let's see,

1:40:10  
really works against me today.

1:40:14  
And I don't plan

1:40:16  
for where those attempts come.

1:40:24  
Okay?

1:40:26  
Now if I run x for what happens?

1:40:32  
I do get this.

1:40:37  
Okay, this is maybe a bit difficult to understand.

1:40:41  
Alright, but let's keep it so we clearly compared to 10. So we stopped when the sum had exceeded.

1:40:53  
We stopped when I had become greater than 10.

1:40:57  
And why was this because initially when we evaluate 10, minus some sum is zero. So the comparison is to 10. So the moment when we see seven is smaller, sorry,

1:41:13  
in the moment that we see

1:41:18  
14, in fact, 15 is greater than 10. Because

1:41:26  
no 14 is greater than 10. At that point we stop.

1:41:32  
But maybe, if I use some here, and some is actually something that changes in the loop, maybe I should take this into account.

1:41:42  
And actually check at each time I enter the loop again, whether I'm in a good position and whether I should already stop, because initially I need to compare to 10. But by the time I've been through the loop,

1:41:58  
the sum is maybe no longer zero, it is maybe already one and then it is something else, then I think it was for one plus three. So we keep changing this. And then maybe we should actually finish the loop earlier.

1:42:16  
Let's see what happens. So where is this hidden here,

1:42:22  
where

1:42:24  
we only evaluate stop once, which is at the very beginning of the loop. Instead, of course,

1:42:31  
we could consider doing this dynamically. So each time I need to compare it to the stop condition, I should find what the stop condition is. And that could be an alternative definition. So let's do another version.

1:43:08  
I'm really shocked.

1:43:15  
Okay, let's do another version. So what could that be? So maybe we don't want to use this. But actually, I should evaluate the stop at this point.

1:43:37  
Actually, let me put the

1:43:40  
seizure three.

1:43:43  
I just put Let's stop here. Let's stop the eval the Stop, stop. And then now this is the current storage with which with which I am in my loop.

1:43:55  
And let's see if something now changes.

1:44:01  
Let's see.

1:44:12  
I'm pretty sure this editor is against me. So let me play everything here.

1:44:23  
And see if we can again get different behaviour. So

1:45:03  
Understand this now.

1:45:08  
In addition problem, this is all properly aligned. This is also

1:45:15  
this is also

1:45:43  
what is your issue now?

1:46:05  
Okay, I'm

1:46:12  
afraid this is against some stupid special symbol that now crept in.

1:46:40  
Yes, open.

1:46:49  
This is too bad. Maybe I have to leave you here. I wanted to demonstrate how the behaviour now changes again with the silly thing argues with me.

1:46:59  
Could it possibly be the the star parentheses right below loop start stuff at the top right now. Yes. Now above that one.

1:47:11  
The closing one above that loop start stuff. Yeah, that one. Could it be that?

1:47:18  
I don't think so. Because

1:47:25  
Because nasty

1:47:28  
comments are okay. Okay.

1:47:32  
I can change this, but I think it is super

1:47:36  
mad.

1:48:06  
I just can't see this. Or

1:48:14  
I can maybe do something very early.

1:48:17  
But

1:48:20  
just to get over it for now.

1:48:25  
But it shouldn't be like this.

1:48:43  
Okay, I'll do another thing. I just put it here.

1:48:47  
This shouldn't be like this.

1:48:49  
I don't

1:48:52  
introduce this extra name. I just put the condition directly in the right place. But maybe there is some special symbol, it still complains about the same thing.

1:49:04  
So it's really something that I cannot see.

1:49:23  
None of this should matter.

1:49:25  
I'm afraid there is still some

1:49:29  
special symbol somewhere.

1:49:35  
Yeah, sorry, I have to leave it here. Now then. Because my editor is letting me down.

1:49:41  
But the point should be

1:49:48  
where was I?

1:49:50  
The point should be that I should get a different result from the comparison now because we can do it manually and then I'll stop. So we start with i equal one

1:50:00  
So, here we say sum surely equals zero plus one which is one then we say is two then we print I then we actually add one to two and then we continue with three

1:50:12  
and then we say okay the sum is the current sum which was one plus three, which is four

1:50:21  
and i is i times tools, this is six, six is printed, then we continue with seven at this point, when

1:50:33  
we have to compare

1:50:38  
the value of i 210 minus some 10 minus some right now is six okay.

1:50:49  
And the current value

1:50:51  
is

1:50:53  
already seven. So, we will actually not do the third repetition of the loop. So, that should be the point if we if we each time re evaluate the stop condition. Now, in a language like this, maybe you don't do this, I mean the the first one that I wrote down before my editor stopped me

1:51:12  
is the standard one that you do.

1:51:16  
However, in languages like C, where a for loop is simply given by

1:51:25  
by like a loop initialisation what you do with each loop repetition and then the loop body, there is no specific notion of

1:51:33  
of control variables and sort of independently incrementing it.

1:51:38  
So, you manually Say what you want to increment or what else you do. So, there of course, whatever happens in the loop body is taken into account and the stop condition is checked, each time you go through the loop again. So, four is the first imperative construct, which sounds perhaps as the simplest possible, but actually already deciding what the for loop needs to do. In in cases, where

1:52:09  
where you change the control variable in the loop, or maybe where you use the control variable or some other variable that is changed in the loop in the stock on addition, you know, in the in the boundary,

1:52:23  
when you have to decide what, what what semantics you're after.

1:52:29  
Always this now I really ran out of time because of his stupid mistakes.

1:52:34  
Is this clear.

1:52:39  
So the main message is you manipulate instead of an environment can manipulate the store. The store fundamentally is mutable. Here, it's implemented by passing around the store as an argument, we could have a different implementation where you use immutable store data structure.

1:53:01  
But fundamentally,

1:53:03  
in low condition in lieu constructions, you have to decide

1:53:10  
you know, how you treat to control variables.

1:53:13  
And what happens during the loop body.

1:53:16  
It's time that we write the loop.

1:53:20  
Okay.

1:53:25  
Fair enough.

1:53:27  
If this is all I'll stop here. I'll stop the recording and we say bye. For today. Continue on Thursday with a C like language.

1:53:39  
All right. Thank you.

Transcribed by https://otter.ai
4:10  
Hello Good

4:17  
afternoon

4:25  
Can you hear me?

4:27  
Yes,

4:29  
very good.

4:31  
Make your volume also a bit louder okay more imperative programming What did we do last time

4:44  
I

4:47  
explained this very simple imperative language I emphasise there is a difference between expressions and commands in any reasonable imperative language so there are commands or statements whose prime idea is to manipulate memory also perform other side effects like input output from the terminal, or to the terminal from the console. And they explained this idea of store, which is something where like in an environment, you keep the values of variables or also maybe that definitions or functions. But the point is this must evolve in time, because we can change the values of things. So, we implemented it via a store passing mechanism. So, we didn't really use mutable store. But the idea was when you execute the statement, then you take the store as an argument, and you produce a new store. And if you execute commands in a sequence, then the second command sees the store that was produced by the first etc. So the story develops and is passed on from one command to another in a sequence. Then I explained that the language we looked at was, was very simple and naive, in the sense that we could deal with a very simple store model, where variable names are directly mapped to values. But as soon as you have local names, I said, this can't quite work like this. For the reason that you may have the same name in multiple uses. So in other block, you may have a variable X, you enter an inner block, which also has a variable x, the moment that you leave the inner block, you must be back at the old x, or the X of the outer scope. But if you just pass on store, and keep only one, store location, or address for the value of the variable x, then you will mix up the inner and the outer x. So this can't quite work like this, we need something more clever. And this is what we'll see today. So I think I failed at the end of the last lecture trying to show a simple thing. I'll show it now. Which was how you're going to have different semantics for the for loop, depending on how you exactly think for loops should be read in corner cases, where you change variables in the body of the loop, whose value actually affects when the loop is supposed to stop someday, then there's different options. And I had a silly issue with F sharp, I can show you where it was. The problem, of course, was something simple that you can't see online, but it was really a misalignment of one character. Okay, let me

8:15  
try to share,

8:18  
share,

8:32  
I think I want to share this window.

8:39  
So that was the code that we looked at. And we were at for loop. What are the options here? Okay, so how was for loop usually treated was like this. For loop is given by four things, there is the name of the control variable. So to say, there is the expression determining the initial value of the control variable, there is an expression determining when we should stop. So if the value of the control variable exceeds the value of this expression, we should stop. And this statement here was the body of the loop. And the idea then was to get going you evaluate this expression determining the initial value, ie start, you also evaluate the expression determining when you should stop. Let's call this value start and stop. And then you use a little helper function which is defined recursively that keeps you going on around in the loop. And it takes two accumulators. Start is something determines the value of the control variable for the next iteration of the loop. And store is the current store. And then what happened in the loop was the following, you first check. If the control variable already has a value greater than stop, when you finish and you just return the store that was passed to you, so you don't change anything. Otherwise, you you change the store, you change the value of the control variable x. To be my eye is what is the current accumulator, this is what you've been told to use as the value of the control

10:50  
value variable,

10:52  
then you execute the body of the loop. And then you just recursively continue with the new storage that the execution of the body of the loop produced. And then you say, Okay, next time, let the control variable be i plus one, this completely disregards that the control variable itself may change during the course of the loop, for which we had an example.

11:23  
For example, here, so we had the for loop, I was the control variable, and I was actually changed in the course of the loop. What the semantics does is that inside the loop body, you indeed multiply I by two, but when you go to the next iteration, you completely ignore that this happens, you just take the next value of y, according to the recipe here. Okay, then we said, This is what you usually do. But one alternative is to take into account what happens to the value of the control variable in the loop. And the modification then is, instead of continuing the loop,

12:06  
with

12:08  
with

12:10  
the new accumulator value being i plus one, you don't use whatever I was plus one, but you actually take whatever the most recent value of the control variable was, as you went through the loop body, and then you just increment that one. Yeah, so here, if I was maybe initially one, then here it is two, then for the next iteration, it won't be two, but it will actually be two plus one, which is three, and then you multiply three by two, you get six, and then for the next iteration is seven, you multiply that by two, it's 14, plus one is 15, which is already greater than 10.

12:52  
And you stop.

12:54  
Okay, and then we said, but something else may happen. Namely, you also have these examples, where perhaps the stop condition depends on something that you change in the body of the loop. So it's, it's kind of a moving target. So maybe Initially, it was 10. Indeed, because the initial sum is zero. But then the sum keeps changing. So after the first iteration is one, and maybe next time, it's already four. So then this value here is not constantly 10. And the question is, do I use the value that the stop condition had at the beginning of the loop? Or do I keep checking what value this guy takes, and, you know, according to change my mind about when I should stop. And that's the code that I wrote. Last time I wrote exactly this. And the only thing that went wrong, which I couldn't see was that by some copying thing, this thing was off by one. Therefore, the whole big match structure was broken at this point. And I was looking for the error in other places, stupid. So this shows how bad the diagnostics is here. It could be, it could be better. But anyway, the only little modification that you need to do is if you also want to use a dynamic value of stop is not to evaluate each stop once and for all before you get into the loop. But each time when you go round in the loop, rather, you evaluate stop. So the code is exactly the same, but it's not this initial value of each stop that counts. Well, for the first iteration it does, but for every next iteration, the storage may have changed. It's a new one. This this process loop goes around here as we implement By by my tail recursion, so it's next time the condition may be different. And then if you take this semantics, you don't stop. When I exceeds 10, you actually stop much earlier, namely, at the point when this guy has become equal to six, which is 10 minus four, whereas I has just become equal to seven, which is the previous value of i. And that was three times two plus one, which is seven. So seven is greater than six, and you stop at one point earlier. Okay, that's where we got. But the only interesting thing perhaps in this language was really, very some choice about what what for loops mean. And if, for example, you introduce repeat until loops, you get similar interesting questions. showing that there are corner cases in the semantics, and if you want to get rid of them, then you can also of course, alternatively, introduce syntactic checks, and just declare that some programmes are invalid. So for example, we could say this programme is nonsense. By saying, in the stop condition, I shouldn't use variables that are assigned to in the loop body. So here are some is actually changed in the loop body, it should perhaps be forbidden to talk about some here. And if you do these kind of syntactic exclusions, then the sort of ambiguity about what the right meaning of a for loop should be, they go away, because then there is no difference whether you evaluate stop only once or if you evaluate it each time because you do get the same value always. And then of course, you would use this choice rather, because it's more efficient, there is less computation involved don't do unnecessary, repeated, rare computations. However, as I said, last time, this kind of semantics is far more similar to what you have in C, where the syntax for for loops is different. But there is really a condition that is fully evaluated each time you go around.

17:29  
Okay.

17:34  
But you can only write programmes that are simple like this in this language. So what can't you do? And what are some goodies that we might want to have? Well, one is we have for the moment, no notion of scope. So all variables are global. There is also no interesting types we could give to them. So we don't have bear types. We don't have things that are very typical of imperative languages, like array types.

18:12  
There is no types at all. So therefore, I mean, no no form of type, enforcement of any sort. Also, we don't have functions here. And we do not have another very typical thing, which would be to work with pointers. Well, we have such a simple memory model that pointers wouldn't even make sense. Because the idea of working with pointers ease, that you can explicitly talk about addresses in the memory. So the idea would be variable names, mean addresses and addresses your store values. And then perhaps there could be direct means of manipulating addresses. And that's what pointers are. But here, since we didn't have any notion of, of address, none of this

19:04  
occurs.

19:06  
So now our next game would be to go to a more interesting language, something like C. And I'll explain the the features that that I'd like to involve by by little snippets from the fragment of C that we will support and then we discuss what is needed and what are some principles and concepts involved at all. So let me show you some some little code. So in principle, I be after a language that is really the See, but just a small part of it. So what do we have there? I'll show this first. On a bunch of examples, and then we tried to summarise the type of features that

20:03  
we want.

20:05  
So first,

20:07  
perhaps we should be able to have functions. It is typical to these kinds of languages that you define a bunch of functions and then you choose one of them as the main one. So differently perhaps from the functional languages, where the big weather code would basically be a big lead construct. And at the end, there is an expression that you want to evaluate, which is kind of the main thing. Here, you may point out the main thing that you're really after, by by a function that you call main, which may or may not take arguments, but the point is, when you run the programme, the function that is called is main. We want to have some types around because at the very least, we want to talk about integers, arrays, and then pointers to different things to integers, arrays and other pointers. And then you can annotate functions with pipes Actually, this is mandatory. So in this syntax here, which is slightly different from F sharps, we say that the return type of Maine is void that corresponds to F sharp unit, so nothing of interest comes back. So rather than write colon void at this point, we put void at the very beginning here, in general use prefix types rather than writing colons and postfix. So void is the type of return type of main and main takes a formal parameter n. And this declaration says n itself has to be an integer. And then there are blocks and you can nest blocks that you can see. And in particular, the function body is always a block in a function, you should be able to put return statements. This one doesn't have an example of this because nothing really is returned. But that will come in your time. But this one is an example of our simple, pretty silly programme that just counts down from a given number of n and keeps printing the printing numbers between n and zero going down. We will actually do very crazy things. I'll just first show you the example. And then we go through it step by step. Namely, let's look at this first as just a programme. So we will have here pointers and arrays and integers in all sorts of nested ways. And what actually happens in a programme like this is is pretty hard to understand. But this is what you're allowed to do in C, but just as a first glimpse. So apart from being able to so so here's the first thing to notice. We've got the main function that is called main here it takes no arguments you can have functions that take no arguments. In a language like F sharp, these don't exist, they are the same as constant. Here, this exists because even if you take no arguments and you produce nothing you you can do side effects and that's the main idea of of commands, which is what the body of a function is, in a language like this. One thing to notice is functions can have function bodies or blocks and these blocks may have local variables. So here, I have introduced a whole bunch of local variables p ay ay ay ay ay ay ay to IPA aap, there is some reason why these variables are named like this. This is for us not to get confused about what they are. But I for example, is defined to be a local integer.

24:23  
P

24:25  
is defined to be a pointer to an integer, this is C like syntax, maybe better would be to write something like this. So pointers to integers should perhaps be something like int star. But in C syntax, you actually put a star in front of the thing that you're declaring to be a pointer. So essentially, here you're saying star p, which stands for D referencing P is an integer, therefore it's p itself is a pointer to an integer. Okay, what else can We do. So here, that is a similar thing I'm declaring that I array is an array of 10 integers. And perhaps more systematic syntax would be something like this, that we'd be seeing that I'm now introducing a name IE. And it's it's an array of 10 integers. But that's not true, right? Traditionally, you write something like this. And that is also related to actually array access. Because iE 10 won't make sense. But you will have things like a zero, and I a one, up until I, nine, which are the 10 elements in the array, and you access them like this.

26:04  
But then come crazy things, because we can also do combinations. This one is still an integer. But these ones are crazy. So here, there is a combination of arrays, and pointers.

26:39  
And the idea is that the way you should read this is, when you don't see parentheses, they're kind of morally on the right. So I don't have to write it like this. But what I have are pointers to integers, which you can see here. But there is an array of 10 of them. So it's array of 10, pointers to integers crazily enough. But I can also have, for example, and here, I explicitly need to put parentheses like this, to have a different thing. Namely, here, fundamentally, there is an array, which takes, which contains, which will contain 10 integers. But actually, what I'm declaring itself is not the array but a pointer to such an array, which is the start here.

27:36  
And then you can have even more complicated locations for these things, then the main things that you can do is you can D reference,

27:50  
and you can fetch an address to a thing. So if p is a pointer to an integer, then I can ask what its value is, and I will write it like start P. So in F sharp, this was bank P. Yeah. And then maybe I can say, let the value of it now be,

28:11  
you know, the integer pointed to by p plus three, for example, and that would be good. But I can do worse things. I can also say, I is p plus three, but P is a pointer. So when you just write p, you don't get the value pointed to

28:36  
by P, but you only get the address. So in this case, I will be the address of p plus three.

28:43  
And these things will start to happen. But for the moment, maybe I don't go to the detail of this. I'll show you some more examples. And then let's be systematic about what is happening in this point. I'll only say one thing. So one thing that you see very often is ampersand ampersand is kind of the opposite of the star which is dereferencing. So given you can't apply this to everything, but say, given given a variable for integers, I can ask where is it in the memory? I can look for its address Yeah, and the result is a pointer which I can then assign to other pointers. So I can say P. Let p be equal to ampersand by and then ampersand and star are kind of each other's inverses. Because if I is an integer variable, then ampersand die is the address of that variable, which is a pointer then, but then I can dereference it writings Something like this. Now this will interfere with F sharps comments index. This is actually the same thing as I because I, I had a variable by up by prefixing. With it with ampersand. I'm now at the place where I get the address of that variable. But star allows me to dereference. And now I see what is the value stored at this address.

30:36  
And they're also the inverse the other way. So for example, if I've got a point there p, then I can dereference it.

30:49  
But then I can ask okay, but what is what is the address of this guy. And that's actually exactly the same thing as p again, and then it gets crazier than so let's look at some more examples. And then we come back to this, and we will have some headache here. So here is some other things that you can do. This is a little programme for pointing numbers between zero and the given number. And what it illustrates is, in a function, you can have local variables, which we already sort of saw, yes. And this function returns nothing, but it produces the side effect, you can see things popping up on your screen. Let's look at some more. So here is maybe a more interesting ones. So you're allowed. Apart from having this function mean, you can have many functions. So here we have two functions.

32:08  
Main is the one that will be called when we run the programme. And then we can submit a number from the command line to which the main function will be applied. And one thing that I we can see here is a global variable, which you can also have, and you can declare, so here we have an array of integers, which has length 22, these integers can be accessed via a zero through a 90. And then hopefully, these two functions will talk to each other. Because if we only run me, and print this never print R is never called, then it looks like a pointless function. But here we see the function calls. So in that sense, everything is good. What other features are there. So here you see something. A function may have local declarations. But it's not mandatory that they follow each other. So it's strictly. So it's not the case that the function body needs to be a bunch of declarations followed by a bunch of commands, you can actually interferes declarations with commands. So it's okay to for example, say that I is an integer, then maybe I want to initialise I, then I say F is also an integer, then I want to initialise F, then I do some stuff. So here's the loop, we go through the loop and the loop basically, is it's calculating sort of the running factorial of the control variable and putting all these computed values of the variable of the factorial sorry, in the array, yeah, this is happening. And finally, the rays printed. What is interesting here, you can pass pretty complicated things to today, I want to say two functions. So to print our we are not only passing an integer, which here is n, and here we call length length for the length of the array, but I can for example, pass the whole array to a function. Now, this example is maybe a bit artificial, but this function talks about a, and it doesn't locally declare a. So the A we're talking about here in these two places is therefore, the global array, a print R, however, has a with the same name as a parameter. So therefore, when inside print are I'm talking about a, this is a different day, this is a locally, which in this call actually is being made to coincide with a with a global one, but this would not necessarily need to be the case. So suppose this print our would not only print, but it would actually modify the array here, these modifications would only be applied to the local array here, and they would not be reflected in the global array in any way. Because the moment you call the function print R, here, you do actually copy the whole array or 20 elements from this globally, so to say, to to the local one, and they are located in different places in the store. So if you update one of them, corresponding to the inner scope of printer here, or the local scope of print are here, this has no effect on this guy here. This principle is called call by value. So parameters are passed to functions fundamentally, by value. by

36:57  
copying the actual value, yeah, and if the value is complex, like an array, you copy over the whole array, you may ask if this is the wise thing to do here. No, maybe not. I mean, in this programme, there would be many options. So first of all, I could just even not pass the array to the function at all, because it's available globally. And printer could also just work with the global array, that would be possible. And it's also possible to pass not an array, but not a pointer tweet. Actually, I'm thinking, I'm not telling you the full truth at this example. But let's look at let's look at the next one, and then we discuss. So it could be so as I told you, it could be differently. And then the question is, when I declare an array, what is it? So when I, when I pass around Not a single array element, but an array, what is it that I'm passing around, or what is the value of an array is the value of an array, the whole array, so not some single elements of it, or is the value of the array something else. And this is implemented differently in different languages. In C, we have the fact that something things are treated, or variables of some types are treated as directly containing the values. variables of some other types are treated as pointers, even if you don't declare them pointers. And this in particular, is the case with arrays. So when we say I'm introducing an array of length 20, then what really happens is that here, I'm allocating space

39:33  
for

39:35  
20 array elements. But if I just use a like here, not like a zero or a one or so, then what I mean is a pointer to the array, not the whole array. Therefore, when you do this call by value parameter passing, it looks as if you should copy over the whole array, but really what you do is you pass on On the pointer to the array, but the array is the same. So I had a pointer, I copied the pointer, but I didn't copy the whole array is the actual semantics that we're gonna implement, which is then different from for from a whole number of other languages where you would say no, if it's a complex data structure, you also pass it, pass it by values, you pass the whole data structure. So let's discuss this when we when we get to actually implementing arrays, and also when we go back discussing example. Now some simpler ones, that are modifications, I think add five here. Yes, sir, so far, we didn't see any way to return anything from a function.

41:08  
But we could here is an example that uses this call by value mechanism of C for passing around pointers, which sort of under the hood

41:32  
implements call by reference in the sense that it looks as if you will be passing values to functions as parameters, but since the variable or sorry, since since the argument is actually a pointer, then this has the same effect as as passing something by reference not copying it. And one way of using it is that you can return a result by a pointer argument. So let me try to explain this. So what is this programme doing? So, we've got a function that by itself returns nothing, it takes a parameter and which is an integer then this there is a body what happens here.

42:30  
So this function tries to illustrate multiple things at once. On one hand, we can see nested blocks here. So we

42:42  
have a local variable R, which is first declared this allocates memory for it, but doesn't initialise it to anything proper.

42:54  
And then we say okay, let the value of RB n, n is the integer that is passed in, then there is a block. And then there is a further print thing are is printed. In the inner block, there is another local variable declared which we again say R is an integer. This R is different from this, so it's located a different piece of memory. So when I update these are the outer will not be touched by. Okay, then what do we do? We call square, which is this function here, with two arguments ennahda. And these, this n, and the function square its mission is to just square a number, it's a silly one. But the way that we call it is to the function square, I pass the number and the value n. And then the address of our, so I'm not sending any particular value there, which would be that not the number n, but I'm sending the address of R. And then the idea is the function should perhaps use the fact that it knows the address of R, and then write something there. Then nothing is returned. But later, I can see what the new value of r is, perhaps. So that's exactly what we do. So we call square n address bar, and then we print our then hopefully our has a different value than it is here. Actually here. It's uninitialized. So only that guy will initialise it then we print R and then we print art. Again, what happens here is inner art is printed. Here, the outer art is printed. When you're given a sort of example execution Shortly, let's look at the function square. What does this one want, so some typing is going on. So square wants an integer. It's called i. So actually, when we make the call, the value of n is pasta wise I obtains the value of n. And then it wants a pointer to an integer that we call RP pointer to our sir. Okay, but this is a pointer. So what we can do is we square AI. And we don't assign it to Rp. If I did this, RP is a pointer. So if I did this, I would just change the actual address. So that would be silly. So RP points to some address, I don't want to change them, I want to change the value at this address sorry, and therefore I have to write star Rp. So this is d referencing RP the value at this address will be itI Okay, so let's run it with something. So, suppose I actually call it with main five See, then what happens here when I enter this thing, please, I allocate some memory for R. So R will be

46:38  
zero, maybe, then we say R equals n. So this means we actually store five address zero. Was this good because this this art is a local variable. So for this one, we have a location where you go to

47:22  
maybe I should oops, I should say address one because really what happens is n will go to address zero but let's ignore it for the moment. The exact address is not so important, but the way that these are manipulated Okay, then we enter the local block we declare a local our Uh huh. So at this point, we should allocate our but it should be a different RS which should go to a different address. So we maybe we put it at address two then we call square with n and R. In is the value which is five and r is the address of this R. So this is to maybe I should say here radio five and others. But really, the typing doesn't know anything about this it makes these up integers and addresses freely. And then Okay, then we should print out what now happens. So this is called by value. So we allocate stuff somewhere. I located maybe at three, and RP located.

48:58  
Four.

49:01  
But we do more stuff because parameter passing has to happen, right? So as address three, we should really put the value that is passed in which is five,

49:19  
address three. But now RP is a pointer. And it's located at four. But what do we store there? We should store where the point their points and the points to address to isn't it? So store

49:44  
address to address for you here. I could have said store value blah blah.

49:55  
Okay, so then what else do we do? Then here we need to look up on I is address three that receive we find value five. So, we multiply five by five and where do we need to put it, we need to put it where are p points RP is itself at address for and when we look where this points it points to address to So, there we put store 25 isn't it okay and then we return from the function nothing is returned. But, so, here odd was that located that address to nothing was stored there, but now we have 25 store that that are still so when we print it out we print 25 and then we print out are these are is the one that is allocated that address one and address one at address one we start five. So, now we print out five you can see that quite a bit is happening here. So there is this multiple multi layer organisation of things. So current values, sorry current variables are assigned addresses in an environment and a storage associates values to addresses. So there is like a two level organisation of memory there is an environment with associates addresses to names. And there is a store store that associates values to addresses. So if you want to look up a name, like maybe say R here, you first have to find out at which address cities and this one was allocated that address one and the environment knows this and then I have to go to the store and see which value was stored there and it will be fine. And if I'm in a slightly different environment where I say no, no our is not that does respond or is that address too. So then when I look up a value at address two in the same store, I do get a different value namely not five but 25 you get this so what we've seen is kind of a two level memory that one needs one is a environment or kind of a symbol table if you wish naively speaking and then there is a store that people also call E which is different from heaps in algorithms that just associates values to addresses and then there is this the effect of memory allocation that must happen when you when you declare when you process the variable declaration. What other examples did we have here? There was also six but this is maybe not so yeah, this may be is a kind of a similar game where we calculate a whole bunch of factorials you using a factorial function. And again, the

54:01  
what I want

54:02  
to compute the factorial of is passed as an integer, but what I want to

54:13  
do, so

54:15  
the value is returned via a pointer to an integer. So what we need to do is we send the pointer to the function. The function dereference is the pointer assign something to it. And then when I come back here, I can collect the value using the same mechanism. Okay. Now before the break. I should go back to the example because that was a tiny bit more complicated. Let's see what we need here. So this is just So, one single main function, where we have these pointers and arrays, and we sort of freely work with those essentially just by dereferencing pointers or asking what the address or something is

55:27  
and not much else. But, but the example illustrates the allocation mechanism and that actually illustrates how complicated things can get. So, let's go through this line by line and then we take a break Okay, the function main, what do we have here, we have a whole bunch of things that are local to the main some of them are more complicated, some of them are more difficult. So, so, here we introduce a pointer to an integer what happens at the declaration is simply that I have to allocate some memory for this pointer. So, this pointer will be at address zero. And if I were to dereference it right away, this is a null pointer, there is no interesting value there. And the way that we signify This is we we will have minus one there, this is like the initial value of all memory. This may be too naive, actual implementations may be far more unpredictable. So, when you use something that is uninitialized you can get an arbitrary value, there is no guarantee what kind of evaluate it would be may look like a normal value and you can really get mistakes from an initialization simply like this Okay, then, we want to declare an integer, so, I want need some space. So, we allocate I address one, but we don't initialise it. So, in this implementation, it will have the value of minus one, but in general, it could be something completely non deterministic and arbitrary. Then there is something more interesting we declare an array of 10 integers. So 10 integers will need 10 addresses in memory or 10 cells in memory. So, we just take the next available addresses. So they will go to 10 two addresses to 211 in our locator, but an actual allocative may be far more complicated. So this is it. This is like a naive idea. But but certainly here we need 10 words for these integers. So let's suppose they will be put that to 211. At this place, at this point also what happens is that I actually will point to, to to the beginning of the array, so I said when I want to look up at the say, if I write something like IE three, so this will go to address five. And this is done by simple pointer arithmetic. Ay ay ay ay is located at address two. So therefore when I want the third element of the array, we just go to address two plus five and look up the value there which is currently minus one. But I A to

58:55  
do that I put it

58:56  
actually points to pool. So at this point, maybe I should say this. If I now print, say i a

59:07  
three

59:11  
then you will simply see minus one because it's only initialised. If I were to print IE I will actually see two which is not the integer two you shouldn't think about it like this, but it's the address to Okay, let's do some more. I want to add a further pointer to an integer I suggest put it at the next available address which is 12.

59:50  
Yeah.

59:54  
So I a tool is now a point But for the moment it points nowhere, right? So is there no pointer

1:00:11  
similar to this one, it currently points nowhere it's located at zero. But at that address, you don't find any further address where where where the real integer of interest Okay, then what else now let's do a more complicated thing. So, this one was meant to be an array of 10 pointers to integers. So, at this moment, when we make the declaration this array will be at address you know the addresses from 13 to 22 will be reserved for you. And IPA itself will point to

1:01:12  
two

1:01:21  
tweets beginning to 13. Okay, then the final thing is a pointer to an array of 10 integers, the pointer will not take 10 addresses it will only need one so it will go to address 23. And initially there is nothing and one thing you may now realise is we haven't reserved any memory actually for these 10 integers. So, if we now try to put something at say, the seventh position in the array, this will end up in a place of memory in a definitely place of memory after we actually made the pointer to point to somewhere, but whether it's something meaningful depends on what we've actually made IP to point to and if it's something unreasonable then we will get an unreasonable result Okay. Now, let's do a few things. So, I is an uninitialized integers. So, when we print it out, we get minus one P is an uninitialized point that it should point to an address but it points nowhere. So actually also we get minus one when we print printed out then I can say okay let p point to wherever I ease I actually we put that address one.

1:02:56  
So, when we do this, then P points to I or which is also the same thing as to address or location what was one okay. So, therefore, if I do this then when I print p I do get one and one is not the value of i one is just where it is located. Yeah, we should not be confused

1:03:36  
about this perhaps. Okay, let's do something. What is the next thing we say is a tool is IAA. This is a very crazy thing, but in C you're allowed to do it. So I A is an array.

1:04:09  
So we reserved the 10 addresses for it. But it itself it points to two and it can be used as a pointer I don't need to use it as an array I can use it as a pointer, these kind of conversions are allowed within C. So therefore when I say I A to is IAA then although I was declared as a pointer, this is a valid thing and now I ate two points to well to the same place but I zero is so which is to say address two

1:04:56  
okay. If I were to dereference it, there is nothing that restore when I get minus one. Yeah. But if I were to print out, instead just a tool, which is this address, then I will get to, of course. Now what can I do? Now let's say I want p to be 227. But but not as an address, actually add the address that P points to because this one here is a D reference, I want to see 227.

1:05:51  
Okay, what what then happens? So I is address one p points to the same address. So therefore, the value of i is now 227 and P points to Location One containing 227 location and address are synonyms I started using address, it really doesn't matter. Now, it's very interesting to maybe print out all three for example, if I just print out P, P is a pointer, then I do get not the value stored at the address where P points to, but only the address itself. So, that is one, when I print out the reference of P This means I go to address one and I look up the value there, this is 227. And that is printed out. Further when I print I, I also get 227. And this point is interesting, because, you see, I never assigned anything to i the only way that I got this 20 2027 was that we created an alias. And when did it happen? It it happened at this point. Yeah, so there is two ways to talk about this address one b 27, I can directly refer to it by the name I. But I can also refer to it by the pointer P. And then if I were to dereference B, I get exactly the same address. And that address one contains the same value 227 whichever of the two ways I work to reach there, yep. Then I can do a silly thing, which I already commented on before, I can look up the address of I, which is one and then I so that one will give me an address and then the D reference or a pointer to an address, then the dereference of it is that address. And then I can store 12 if I do this, I change it to 12 even though I'm not writing it the easy way. I mean, I could have written y equals 12. And that's what I had exactly the same result. But this is a roundabout way of doing. So similarly, you can do silly things like this. So P is a pointer, I can dereference it. And then I can ask what is its address and make a new pointer. And if then I assign to the pointer p this new pointer I'm actually not changing anything because that is just p so equivalently like with everything p equals P so therefore, when I dereference p it is 12. Well, why is this? Well because the value of i is 12. So therefore also the dereference of piece 12 because both are located at value, sorry at address one.

1:09:24  
Okay, questions until this point or not. There is more but that actually gets complicated. So I'd rather like to postpone it a bit and then we can discuss it. No questions. No, not at this point. Not at this point. But because we could we take a quick break until say 15 sorry, 13 1305 and then maybe spend another 20 minutes. I won't get far today. But I want to get through this because that explains the mechanism. And then maybe we look at C syntax because there is a difference between L values and our values. And I'd like to introduce this concept to you and then next time, we can start thinking about, you know, what is the execution mechanism here and how do we work with a store model adopt. Okay, so let's take a quick quick break of five minutes. Okay so, in enmore um let me share this screen can never

1:18:02  
find the right one

1:18:12  
okay so we were in the middle of complicated code and the point was to illustrate how these different declarations affect each other. So, let me show you the declarations here. So these are the declarations we are working with in the upper half of the screen and in the lower one we're in the middle of the code. So P is a pointer to an integer. Whereas, ie is officially an array of 10 integers. But, I as such, if I just use it as a name like this, it points to two that contains an integer so it really for practical purposes, it works like a pointer to an integer. And and now we see sort of we will see interesting effects of it. So when I say P equals ay ay ay. so P is a pointer to a single integer. When I say d equals to i A, then P will point to is zero the zeroeth element in the array. And this is actually at address.

1:19:31  
One Where did it go?

1:19:39  
Now I can use these arrays in in wrong ways. I, I can refer to the first element of the array or the zero with depending on how you want to call it my writing is a square bracket zero, but I can also just write the reference of it. So if I make this one equal 14, then actually is zero becomes 14. So, arrays can be worked with in this sort of index notation, but you can just as well use the reference notation, it has exactly the same effect. So So indeed, when I write star II was 14, then I may want to print out is zero. And what is printed out this 14. Yeah, although it looks like I never had an assignment to the zero with element of A, with this command had this effect. Because I a zero refers to the same value that star Raiders. And I'll maybe let's do more crazy things, I may perhaps want to set the ninth or 10th depending on how you want to count element 218 14 for that, I may write IE nine equal 14. But I can also use the pointer dereference index. So it's okay manually to say I want to add nine to i A, which is a pointer so therefore denotes an address. And then I want to dereference which allows me to find the value at that address or, you know, refer to the place for the value at that address. And then when I put one 814 there, then IE nine is 1414. So really, after I've done this, when I print IE nine, I don't get worried 14

1:21:41  
I then may want to do the following thing. I ba was what it was an array of 10 pointers to integers. So then it's okay to say that the second or third depending on how you count element in that array is p because p afterall is a pointer to an integer. So, when you do that, IPA two will point to exactly the same place where P points which is the same as

1:22:14  
where not not to I points to talk points to p p points to IAA and where I point points to one. So that's not correct. We saw Yeah, that's what I want to say. So but that is at address zero. So what did we have there, we can print this thing. And what I'm printing out is not the value is and address is really at two

1:23:17  
which is fine, we have a value at address I have forgotten what address Do we still have no value. So if we were to print it out. So for example, if I if I were to print out its address tool, but if I were to dereference it, so if I did this which I can also write without parentheses By the way, then I would get minus two because there is still no value there. But here is then a test that says there are so many different ways that I can write the same. So I can so this one can be written without parentheses first of all. So I've got this array IPA that has multiple elements, I can be looking at the second element it is a pointer. So therefore I can do reference. But that means I could also just ask for the for the address of it. And thereby I kind of undone star so star and ampersand they cancel each other in effect. So listening is also just the same as IPA, which is by the way too, but I can write crazier things. So instead of referring to the second element of

1:24:59  
of the array, IPA via IPA to I can write IPA to star. And that gives me also the same second element. And then ampersand star doesn't do anything on top of it.

1:25:14  
And then you can play further like this. So it is really a very complicated mechanism. Hopefully you don't use all of the features of it. But when you do a language implementation, then you have to understand everything that's possible to write here. And people use ampersand then and star, of course, a lot in C code. Because you're Matt manually sort of manipulating the heap that you have in your mind. And you can do very unsafe things. So one things that you can do is, you have, for example, here, I've declared that I A is an array of 10 events, but nothing prohibits me from actually writing stuff like I have 15. And this will be valid, and it will refer to some address, namely, what I would get if I added 15 to a, and then D reference it for but of course, the value that is there can be anything, because we don't have any control over what else was allocated at that place, because we only reserved memory for 10 elements. So that's the nature of these languages. Okay, we'll finish off for today, let me show you the beginning of this micro c thing that will work with a bit. This is the language that we now try, we'll try to analyse. And an important point there will be that we have commands, of course, we have declarations, functions, blah, blah, but the most important point perhaps is, we will have two kinds of expressions, if you wish, there will be expressions and there will be something that we call accessors. expressions are things that denote values, and for them, you don't necessarily have an address or they are not necessarily stored at an address.

1:27:28  
So, these ones denote values are not necessarily scored in the store. And access source can be used in in two ways. So they then have both addresses and values. And sort of via addressees have a play have a you know have a definitely place in the store. So to say,

1:28:19  
let me try to illustrate what these things are. So expressions are also B. Sometimes we see they denote our values. And sometimes we say these things, you know, l values, where R stands for right hand side, and L stands for left hand side. And the point is that in general, your assignment commands, and assignments will also count as expressions, but that's a different matter. We'll have this form an accessor on the left. So that can be not just the name, but it can be a more complicated thing. For example, I can assign to an array element. So in general, it is an accessor. Whereas on the right, I can only have an expression. And every accessor counts as an expression but not the other way around. So one of the base cases for accessor is for expressions is accessors. I will write a for accessors. And then there are other expression forms. But it's not true that every access that every expression would be an accessory this way of conversion doesn't work. So one of the things to which I can assign and what can occur on the left hand side Have an expression is really the three kinds of things. So I can assign something to a name. That is pretty natural, because the name probably denotes a location or an address in the store. And that can store some value there. But Similarly, I can actually make assignments to the reference of P that is an accessor. Yeah, because where p is a pointer, why, because if p is a pointer, it doesn't store a value directly a pointer stores an address, or denotes an address I should rather say, and the address further stores of value. So, when I do a dereference of a pointer, what I what I do get is an address and that address is a perfect place where to make an assignment. And actually a similar thing happens with arrays, namely, I can make an update not to the whole array at once, but to a particular array element. So I can say for example, a zero equals something in general,

1:31:11  
a E,

1:31:12  
where A is an accessor. And he is an expression denoting a value, the point is, A is understood as an address. And he tells you how much further to the right I have to move from there, what do I need to what kind of offset to I sorry, or what kind of value Do I need to add to my address to get the new address, say, a three, when I write something like a three, the point is, a already denotes an address, when I look at a three is take this address plus three, you get a new address, and then that address, you can store something. So all of these counters accessors. And you can have them to the right authority to the left of the equal sign in an assignment. Whatever you can have to the left of the equal sign, equal sign of an assignment, you can also have to the right, and this is the first case of expressions. So any accessor counts as an expression, but then there is a whole lot of other things that also count as

1:32:37  
as expressions. So for example, I'm allowed to write a numeral like three. But the number is not necessarily stored at an address. So it doesn't make any sense to have three to the left in an assignment, you can't write, assign X to three, this doesn't work. Because three is just a number, it's not stored in any particular at any particular address. Therefore, this kind of assignment doesn't make sense. Similarly, when you've got operations, like plus minus times, blah, blah, you apply them to, to things, which may even be accessors, they are at some address, the result is not necessarily stored in some address. So the result is just the value you can use it as a value. But but but not more, the similar for AND and OR, similar for function calls, you can't assign anything to a function call. But you can have a function call in an expression to the right of an assignment. Then finally, when you've got an access or then you can ask what IP addresses this is also something that you can use to the right of a of an assignment sign, but not to the left. Because what you get back is an address, but this address is not necessarily stored anywhere, right? Maybe some variable X was an integer, then I can ask what is addresses, it is an address, but that address itself is not stored anywhere. So I can only use it to the right of the assignment. So to conclude, and I think this is I can't go much further today. In a language like C you will have two kinds of expressions, expressions proper. These are the ones that you can use to the right of an assignment sign and you will have accessors they are a more restricted class of expressions that you can only that you can use on the left as well. So anything that you can use on the left you can use on the right but not the other way around. And the particularity of accessors. Ease. These are things that are actually stored somewhere in the store. So an accessor, you can think of as both as an address, and as the value that you can access through that address. Whereas the general expression, you can only think, in general, in terms of some value, but it's not necessarily stored in the store. So some terminology for this is L values and our values. So we say that accessors have l values. And elevators are these addresses. And via l values, they also have the R values, they have the real normal values. Whereas expressions, they only have the real values, the R values. And this naming comes from the fact that these are the kinds of things that make sense to the left of an assignment. And these are the things that only make sense, to the right. Another kind of way of thinking of this is, left values are kind of like boxes, where you can put things and auto values are things that you can put in these boxes, and you you have to keep them different. And I think like a name is surely a box because you can assign stuff to a name. The same is true for a dereference. The same is true for an array element. But the number or maybe an operation applied to a number like a negation applied to five is not the box is just the thing that you can put in a box. So the next time I will, I will actually introduce an interpreter for this language. And we will have to then work with environments and stores and their location and I'll explain it in in painstaking detail, I'm afraid

1:37:00  
but

1:37:02  
the main concepts are two kinds of expressions and sort of two level access to real values. When when I think like an accessor denotes an address and under an address, you can have a value than the way that you reach the value is you first look up the address, then you go to the address and check the value there. So look up those two stages. How is this questions about this part?

Transcribed by https://otter.ai
0:54  
Right So, let me start the lecture, this lecture 19 we continue with micro C. So I was telling you a bit about imperative programming already we looked at the simple imperative language. And then I started to tell you about the C like imperative language, who's one of the main features is that there are pointers that also raise I explained you the complications of such a language. So, what does it mean to to work with pointers that you need to work with a tool level memory model where variables are mapped to locations or addresses, location and address are synonyms. And these further are mapped to values. So, when you want to actually consult the variable, then you first have to find the address at which it is there can be several variables around the same time with the same name from different scopes. So, of course, you consult the correct version of it, and it's lost value. Yeah, since in this the store keeps updated all the time, or we pass store around in our F sharp interpreter of the language. So, today I want to talk about this micro scene a bit more detail so that you see some of the tricks there. Let's start let me share my screen or rather my my text buffer

2:25  
and we go check

2:40  
this one as well. Right. So I'll tell you about the the micro C language then so first we look at the abstract syntax, then a bit about the structures for manipulating memory and then we actually will look at an interpreter that allows us to execute statements and evaluate expressions.

3:04  
So what kind of types will we have around? Well, the main thing is to have some base type like int or float or char here Actually,

3:15  
we have both integers and chars but it doesn't really matter then there are arrays, when you tell something is of an array type, you have to say an array of what and you can optionally also say the length

3:33  
right. And then there are also pointer types of reference types when you say something is a pointer, then you want to say it's a pointer to what like a pointer to an integer or a pointer to a pointer to an integer or any such thing. So, these are the types of types we have around here. We do not need to talk about function types, because functions are not first class, we will have top level functions around

4:01  
arguments will have types, there will be a return type which may also be void. Void is not listed here among the types but the return type can be void. You'll see very shortly how we model this

4:14  
okay. Now two more interesting things. The main syntactic category of course, are expression categories are expressions and statements. Then, I said there are two kinds of expressions there are those that denote values, data values, that we also talk about our values and those that denote addresses, that we also call l values. And of course, when something denotes an address, you can go to this address and look up the value there. So via and address these special kinds of expressions called accessors, they also denote data values, but this is in an indirect fashion. So what are expressions whose values are not necessarily stored Let's start with the simplest ones, and then we go to the more complicated ones. So, surely we can have around just numerals, which will be something of type integer. There are some unary operations like negation perhaps or negation integers that you can also see as well, negation of integers, and some others. Also, Pink is done via the exact the same thing, then there are some binary operations, like, plus times, but also equals less than equal etc. I put some binary Boolean operations separately that are here called and also and or else. The reason to put them separately is that most operations are strict. So, you always need to evaluate both arguments. But and then, or are a bit special in that you first evaluate the first argument and only then you see if you need the second one at all. Then finally, when f is a function, we only have top level functions, and you'll see how they arise, then I can apply this to a bunch of arguments, it should be the correct number of arguments for the interpreter not to fail. Today, we only talk about the interpreter. So, there is nothing in the in the way of type checking, but, but we'll see how this goes. Okay, then there are some some more expressions. But maybe I'll go get to them when we have first looked at accessors. So accessors are especially kinds of expressions that correspond to addresses as well. So

6:45  
yes, any accessor is actually an expression tool, but not the other way around. So, the base case, one of the base cases for expressions are actually accessors that are here denoted by this tech access, and what can an accessor be, so the simplest one is just a variable

7:01  
name.

7:04  
So that will, so if you've got a normal variable of type like integer, this will this will be an accessor. But then, there are also pointers. So, in principle, you can write expressions that are pointers, and then you can dereference them. So in general p will be an expression, but of course, not every expression will work. But, but this is one possibility, and then there are these index accesses. So, and the main use for these are arrays, then and then of course, multi dimensional arrays. So something like this A, and in brackets e will be an accessor. And the idea is you are doing a lookup of an array element, the array element is described by an expression whose value hopefully is an integer. And the array itself is a pointer, we'll see this more specifically. So these are all good. Now, when something is an accessor, and you use it as a as an expression, then the idea is you don't mean the address, you actually mean the the R value that you reach going through the address. So when you just write a the the idea is to do this two level lookup you first look up the address, and then you do look up the value under that address. But if something denotes an address or or is an L value like accessors are then you can also directly ask can I just instead see the address and then you can manipulate the address directly. So this is something that we talked about last time. And then most interestingly, assignments that in imp were statements or commands can also be used as expressions here. So this has to do with the following idea in C. In C. You can write assignments anywhere in an expression so I can write stuff like maybe x equals y equals Zed plus five for example, what is happening this y equals that is not the comparison of y and Zed. Rather the following happens when you look at this assignment. So the assignment is the top level assignment can also be seen both as an expression and the statement. But when you evaluate the following things should happen. You evaluate Zed You assign the result to y. But you also return the value of Zed as a value to which you can add five. And then you assign the result to x. So this is just a shorter way,

10:12  
if you wish, in some sense to write the equivalent of that let y be set. And also let x be Zed plus fine. So if you want to do these two things in a sequence, you can just Well, just as well also write this.

10:32  
Yeah, so you can read an assignment as a statement, then you don't think of it as particularly as returning something you just as a side effect. So the story is updated, but you can also see it as an expression which both has a side effect. So stories update, but also something is returned that can be used in further calculation.

10:53  
So these are expressions, okay. Then, what are the statements? Actually, any expression qualifies as a statement in particular assignments to, then you could ask, okay, but then

11:21  
what is the point, so the expression returns a value, but a statement is not supposed to return anything? Well, the point is, the expression has a side effect, and the side effect is kept. If you have an expression that you treat as a statement, the value is thrown away. So you can write several expressions, for example, next to each other, with a semicolon in a block like this, haven't gotten there yet. When you you throw away the values that the expressions return, but you keep all of the side effects. Okay, let's jump over return for a moment. In general, you can put statements in a sequence in a block. And then the additional thing is, you can also put declarations of local variables in a block. A block is actually a list of statements or declarations. And a statement or, or a declaration is then either a statement signified by this tag is stmt, or it's a declaration and the declaration is given by a tight vendor stream. So you introduce a variable name, and you give it a title. That's the idea. So here, I've shown that the declarations and statements are nicely in order in the sense that you first have a bunch of declarations, then a bunch of statements, but actually, they can come into spheres. And the idea is that the declaration takes effect, you know, at the moment that you see it in the sequence. So the declarations are processed one by one sequentially. And as you go through a declaration, you you you introduce a new local name into the scope, when you leave the block, all of these things are left behind, I mean, they are no longer in the scope. They were private things of this inner scope. Okay, then you can do IPS and wires. These are very simple. I'm all here I see this mistake. So that should be statement one and Statement two. And why. And then what is it what is the complete programme, a complete programme is a list of top level declarations. And at the very top level, you can only have two kinds of things. So the top of the Declaration, top level declaration is either a declaration of a variable. So that's like a declaration of a global variable. Or you actually define a function. So the variable declaration is something like also a local variable declaration. So it's a type followed by a variable like indexes x is of type int,

14:08  
but there is also this form where you will say something like, you know, type function, and then at least type in function pairs. So then you this corresponds to giving the formal arguments like t 1x.

14:26  
Through

14:28  
t n, x n, Papa. And then there is the function body, which is just a statement. Yeah, in general would be blocked. But if it's a simple statement, that's also loud, I forgot to close the parentheses. So this is what we can do. Let me illustrate this a bit. So here is an example written up in the abstract syntax looks pretty complicated. We can We can try to process it and see what it means. So don't get some feel for what is going on here. So it's, it's a piece of code, it is actually not a top level, top level programme, it is an expression seen as a statement. Why? Because Because expert is a tag for the data type statement, or the discriminated union type statement for statements takes as an argument and expression. It's just something that tells you here's an expression, but now I want to leave you with the statement. So we've got an expression that we want to view it as a statement, what is the expression? It is?

15:47  
Above all, it's

15:47  
an assignment? Yeah, what's on the left hand side of the assignment. To the left of an assignment, I always need an accessor. There are three kinds. So there are just names, variable edge, there are pointed D references, and there is indexing. So here there is just a name. So in concrete syntax is just written x equals and what does x equal two, it equals to some humongous expression, which is the right hand side of this assignment. So this is an operation times applied to seven. And then what? Ah, another assignment. So they are the argument two up to two times is the second argument of times is an assignment. So we've got something of this form now.

16:36  
What do we assign to what? So here is the left hand side of the assignment? Here's the right hand side, both are complicated. Now, the left hand side of the assignment is something more complicated than what we saw before. It's an indexing thing

16:56  
that uses on one hand, the name a, okay. Okay. And then some expression, which is the expression for the index. And what is that? It says we want to add together a variable and it's on the right hand side, so we have to convert it from an access or to an expression, so it's access

17:19  
back for I okay. I plus five. So we are assigning something we suppose in an array A to the position i plus five? And what is that?

17:37  
This one is also a complicated thing. So it's an expression in particular, it is an access are seen as an expression because the first case of expressions, we say here, any accessor is an expression. And what is that it's a dereference of something plus something. So it should be a dereference of and then plus access to a name. Why? In what way, this is actually also an expression here, we are using this construct, so we access y in this way. 10% y plus three. Now see gets as complicated as this. Now, maybe let me put some more space. And let's try to read it. So what is happening? The whole big thing is in assignment, which is both an expression and the statement, but we want to see it as a statement already. So what does it do? It assigns to x the multiply the result of multiplying by seven a thing? And what's that thing,

18:44  
that thing you fundamentally get by using y Well, if you apply y ampersand to y, this means y must have been a pointer.

19:00  
And I'm not interested at the value in the pointer, I'm interested in the address of the pointer. Because I really want to increment the address by three and the reference there, so I'm not looking up on there why, but I'm consulting the error. So why and then I go to the right three positions in the store to different address, and I look up the value there. This value is something that on one hand, I want to multiply with seven and assign the result 2x. But on the other hand, even before I get there, I also want to assign this result to a particular element in the array. So I'm going to update the array not everywhere, but at the position i plus phi where i is some name that hopefully was declared as an integer so that I can actually carry this thing up here. Okay. That is complicated right. Now, if you're a real c programmer, you use this mechanism, quite A lot for data structures, but maybe not for writing very obscene things unless you really try to write off escaping c four, to 20. with other people, which people sometimes do for fun, you can really write very unreadable things in theory. Okay, now, now we go to the memory model. So there is this two level structure. We do have environments, which map names to addresses fundamentally. Nope. Yes, but this is defined as a polymorphic type. So in principle, an environment is implemented via a list and we could, we could associate to a string, which is an identifier, any sort of data typically, we'll put addresses here, which are represented here as integers. And this is the usual definition of the environment. So, yes, which we hear used to associate overseas to name. But then there are environments, there will be different kinds of things around. So on one hand, we will have, we will use this type for local environments, we use the same type also for a global environment. More specifically, a local environment is an environment over ins. So here you associate two names, addresses, as I just said, but it's paired together with another int, and in a local environment, so there is both the dictionary and the specific constant, not constant, but the specific single integer that you use as you need to remember which is the next free place in the memory. So this is the next free address that you can use in allocation. Global environments, our pairs are similar, but there we do not keep this. Next, we address information. So there is an association of addresses to global names, this is the intent video guy. Plus there is also a function environment, a function environment is maybe a bit more specific. So a function environment also uses the type and we're so it associates to name something. But here to every name to every function name, we assign on associate on the one hand, the list of parameter declarations, which is just a list of type and variable name pairs corresponding to the formal parameters and their types. And then also to every function name, you have to associate the statement which is the functions body. Okay. So this is how the hell this envier is used here in multiple ways. The string is always some sort of names, identifiers, but the data are different depending on what exactly we want. Okay, what is the store, the store here is, is implemented like we did for imp just for the change with maps rather than lists, but it's a very similar thing. So we map addresses to integer values. So you could also implement it if you wanted with an environment that doesn't map

23:56  
identifiers to addresses but rather maps addresses to two data values which here are only integers. And we have some interface to it so we can create the empty store we can change the value in a store this actually doesn't change anything, it just gives us a new store that can look up value in a store based on an address using some functions that are provided

24:28  
with this type map Okay. Here's another little primitive that we use. For arrays, we need to do the thing that when arrays created just just for keenness, we also need to initialise it, but with some error values. So what then happens is,

24:53  
we need this helper function image store, which does the following thing. It takes some store that He's already given, it takes some particular address, and it puts an initial value, it puts in it, it puts n initial values to the store and all these initial values are minus 999. So if there is any new venues to put into the store, we just returned the old store. Otherwise, we say, where we actually set the store at the given location locked to minus 999. And then we recursively call it store, we say now there is one less item to initialise or one less address to initialise. And actually, we start with the next location. Altogether, we, we initialise end location, so lock itself lock plus one lock plus two etc anti lock plus and minus one. Then, as I said, and these are maybe already the last infrastructure things, but they are the more complicated ones. We need some combine the environment and store operations because if I've got, say a name that denotes an address and that address, there is a value How do I reach that, first I have to find the address that then that is associated to the name, then I have to go to the address and fetch the value there. And also, actually when I want to? Well, I've just created a new variable and I want to place it somewhere in the store, then I have to associate an address to it and I also need to put the value there in the store. So there are a few operations like this. So let me explain them bind var is the following thing. It takes a name it takes the value, it takes the current version of the local environment, which then associates values to address data values to addresses. The local environment also knows the next free location and then we take

27:24  
the store current version of the store buying var What does it do? It does the following thing. On one hand, it extends the environment it says we build the new environment which consists of the old one, but we add

27:44  
the Association of the name x to the next three location that was provided to us. And then what we return is a pair of a new local environment and the store which are they the new local environment is the is the newly created version of the environment, you know the extended environment. But also we increment the the next lock. So I mean, we return not net lock, but next lock plus one. And we return a store that is obtained by this one by updating it at this address, which we just reserved for the for the new variable. And there we store the value v. So we did two things at once, we added an association of the variable to some location for which we took the next three location. Then of course, the new next three location is something else. And then at the same time, we also update the store so we return both the new local environment, the extended local environment and the new updated store. Sometimes you need to bind a whole bunch of variables to a whole bunch of variables at once. And you can do it by just recursively calling bind var on these pairs of variables and data values from here. I won't explain this.

29:17  
So I'm almost done with these infrastructural things. I have to explain one more thing. So when we declare name, which can then be a name for an integer, a name for a pointer, a name for an array.

29:45  
So, the declaration gives us a name paired together with a type which is one of these things. Then, when we process such a thing, we have to do allocation

29:58  
How is that done? In the following way, fundamentally we use bind var, that I just introduced, but we need to do a little more in the case.

30:12  
We're actually allocating memory for an array. So let me explain this. So what comes in? Yeah, something from a declaration. So a pair of a name and the type, local environment store. And what really turn is a new version of the local environment, and also an updated store.

30:33  
How do we do this? Well, first we do some analysis based on what what what, what type tipis Yes, and it can either be an array type or it can be a pointer type or an integer type

30:52  
or a character type. If tip is not an array type, then I define certain things, I say, let next lock prime be just next lock, let some value be just one. So this will actually be the initial value for the thing for which we are allocating a memory but not initialising it yet. And let a new store be the given one, store zero here. So basically, we just use next lock as zero. But as we take minus one. When we see that our type is actually something else, the type is an array of G's, so an array of intz, or an array of other arrays on array or have references. And possibly very is given with a length. So if the array is given with a length, we do this thing, if the array is given with without a pre specified length, then we don't do any allocation at the moment, when we process the declaration of an array, an array gives a location, if the array is given with with a length indication, then we need to do something else. Namely, we don't pass out from here next lock. But next lock up plus i which means that when we process, an array declaration, we will reserve I addresses, at least well, there'll be one more that comes from bind verb, but we'll see later.

32:39  
The

32:39  
value that we want to return is next lock. And the point is when we declare an array, an array becomes a pointer, which is actually initialised to the beginning of the array. So this is this next clock here. So the other guys don't get initialised. It's just minus one, here's an S clock. And then actually, we initialise it many elements

33:12  
of

33:15  
the store. Right? Then, what do we do with all these things, so we return these stuff. And then what remains is we actually want to say we want to bind the name that was declared to the value v that we invented here. And we do this in this newly created store store prime that comes back from here, so in its store, actually gives us the new store that has all these new values for the elements of the array. In other cases, it's just the initial store. Yes, and then also what we say the local environment will be it doesn't change a lot before we start finding the variable. It's the given one, but we already had to say that the next free location is not the original one. But is is whatever comes back from from here. So next look prime is either this or the original one depending on if we processed an array declaration or not. That is tough. But But what it says is when you process a declaration if it's not a declaration of an array of a predefined length, then you don't at this point allocate for initialise any memory except Whatever binds var does and bind var always allocates one address namely for the name itself. Yeah. And in the case of the array, it allocates memory for the pointer to the array, but not to the array itself. Yeah, that is done in this clause if the array has a predefined length, and in this clause, if it is type PE t none.

35:27  
Okay, one final infrastructural thing. When we have our top level declarations, among which there are then declarations of the global variables and global functions, among which there should be the function main,

35:52  
then this is processed in the following way. So, the topic declarations come in. And what we produce is

35:59  
a local environment to start with, which won't contain a lot the function environment and the store and the local environment is called the local environment here, but it's actually consists of the you know the environment for the global variables plus the plus the next free location. So, how is this done, we actually

36:30  
use

36:33  
a helper that just goes through the declarations one by one. And it uses some accumulators. So, we start off by saying we start off with the empty store empty environment of functions and also empty environment of global variables and also the the next free address is zero. At the beginning, all addresses are free. Yeah, we start from this, if we reach the end of the declarations, then we return the current value of the values of the accumulator. So this is what comes back here is good. Otherwise, we are processing either one variable declaration followed recursively by the rest or one function declaration followed recursively by the rest. So what needs to be done when you process a variable declaration,

37:34  
then this is given by a pair of a type and the name, you just allocate memory for the variable using the given look and then store and what come back is a new version of the local environment, the new version of the store,

37:57  
and then you recursively carry on with these new versions. You don't touch the function environments. Maybe it's a function environment, it's the other story. So you process the function declaration, which is given by the type of the function that you don't look at here at all. This will actually have to change when we properly process the return statement, which we don't do here yet. Then there is a function name function for more parameters and the body. And we just call the helper recursively on exactly the same local environmental on exactly the same storage, we don't update them. But to the function environment, we add the pair which is basically essentially just a closure and there is no environmental remember in the closure here. Specifically, we only have top level functions and the global environment will be visible to the functions is always the same. So it's pairs of functions and function names are associated to pairs of parameters and the body okay down here this was complicated, but the good thing is now we can write an evaluator and that is not after all, so complicated. So the top level functions are what on one hand? Well, there are quite a few the main ones are, I need to be able to evaluate expressions I need to be able to evaluate statements which are also called execution. Specifically, we want maybe to evaluate top level declaration. So the main programme, so to say and among the expressions, there is a special case of accessors for which there is also a separate function. All of these are declared in a mutual recursive so it's a big Let's rec with with a bunch of ends. So several things done simultaneously. So when you evaluate an expression, what happens, you take in an expression, local environment, global environment, some store, and what comes back is the value of the expression and the updated store. And I'll explain the functions. Access is similar to what comes in is an accessor. local environment, global environment storage, what can what is returned is an integer, but this time not an integer for a data value, but an integer for an address. And then an updated store. Because accesses can have side effects, for example, you're doing array indexing, and the index expression contains an assignment. So why do you index into an array, you actually change the store evals. It's just a helper for the case when I have a list of expressions, which is used in some place, but nothing interesting is happening here. It's just basically mapping eval over all expressions here, but not quite, because you have to thread through the store. So when you process the first expressions, the store is changed somehow, the next expression will already work with the updated or the new store. There's also a little helper for calling functions, which is one special case of evaluation. And then there is the other type of, of main function here, which is execution of statements. That's very similar to evaluation of expressions. But that difference on the level of pipes is you don't return any data value. So you're taking a local environment global environment store, what comes back is an updated store the new store, but no value is returned. So once we're done with this, we also have to be able to process statements or declarations, statements are processed by executing declarations are processed by a location. I'll explain this once we get there. And finally, the main thing is top declarations for so this corresponding function here is called run. And it takes in a programme, so list of top level declarations, and a number of values. And these are the values that we're passing into the main function. So in the case of a C programme, if you run a compile c programme from say the command line, then you can actually apply on the command line, you can provide arguments to your to your main programme. So let's go through these one by one. expressions, I'll start with the simple ones that we've seen before, so they don't look so difficult perhaps and then we get to the more and more complex

42:58  
ones.

43:00  
So let's start here. When you evaluate the numeral, you don't have to care about the local environment global environment store. Because you don't really depend on them well on the environments Not at all. To return the value of a numeral you just have to return that same number. I have to return the new store. And for that I need to know the old store because evaluating a number doesn't change the store at all. When I have you unary operation applied to an expression what do I need to do evaluate the expression what come back are the value of the expression and then update its store. Now depending on what the operation is, I may need to return a different result from the operation. But the new updated store I return is the one that comes from here. So the an operation itself doesn't change the store anymore. But evaluating you one which may for example be an assignment does change the store. So we return rest and store prime. So what is rest, rest depends on actually what the operation is. So if the operation is bang, which actually stands for negation, when it's just this thing, so when when the value from the expression was false, then you return true which is represented by one otherwise false. So you negate but we also have print things as print operations as unary operations here. So all you need to do is you print the integer value or the character turned into sorry, what did I say? Yes, we either print the integer or the character that is also represented as an integer, but that you want to print it as a character, but you use it in computations you return still the integer two characters are internally represented as integers everything is integers. And this is then what the result is. So, either the result of negating the given expression if this was a negation or otherwise just the given integer or character that you want to print represented in any case as an integer operations are very similar. So, you evaluate both operations sorry, both both expressions both arguments to the operation, the first one you evaluate in the given store, this gives a new store and data value, the second one evaluating the new store which gives a yet newer store and another data value and then you return the newest store. And the result which is given by you know, based on the operation you do something with the values of the arguments. Okay. And, and or are similar except that you're lazier you first only evaluate.

46:29  
First only evaluate the first argument. So this will be a pair of a value, or more or a boolean value together with an update possibly update store. Which we collectively call rest. If before and so the value is true. And then we have to check the other argument. In the new updated store, and whatever pair comes back, this is what we returned. Otherwise, we already returned the given pair. And the or case is true. So if the first guy is true, here, we can already just return the pair that was returned. Otherwise, we need to evaluate the second guy and then whatever its result is determines the whole thing. So function calls are expressed through a special function here. That could have also been inlined. Here Actually, there is no special reason to keep it separate. Okay, now let's go to more complicated things. An expression can either be an accessor seen as an expression, or it can be ampersand applied to an accessor. If it's an ampersand applied to an accessor, all I need to do is I need to apply access to the accessor local environment global environment and store. This will give me back an intern the store and the input is the address and here in this case, we're interested only in that address. So that's in the case of ampersand but if an accessory is used without an ampersand, it means we're not interested in the address we're actually interested in the value at that address though, so then we have to look deeper. So, we do exactly the same we use the function access on ACC the given accessor this one gives us back a location and the new store because accessing can modify the store and then I have to go to this new store. And I have to look up a value that at the given location that I just found or that I just found by you know, evaluating access. And then the store that I returned was the store that I got from here there is no further changes to the store. So So anorak does look up on one level, just look up the address in the store, um but if EQ is an accessor is used as an expression directly without an ampersand you have to do two lookups. So first, you have to understand which ad address the access or which which store address the accessor corresponds to. And then you need to actually go to the store and then fetch the value at that address. Okay. assignments, assignments are interesting. So assignments have an accessor on the left And an expression on the right. So this accessor. Here, when you apply the function access, it denotes a location. So when you, when you process it with access, you get back an address, and also a new updated store. When you evaluate the right hand side, you do get back a data value. And the yet newer store, what you need to return is whatever comes back from the right hand side. But you also have to return a yet newer store that you get by setting in the store that you later Scott. The value add lock to this data value rests here. Yeah.

50:48  
Okay, we're done with this access. And then maybe 10 more minutes, this is really quite involved.

50:58  
Access. Access source, there are three kinds. So what do I need to do, I'm given some access for a local environment, global environment, global environment, you don't really need here unless you make a function call in the array indexing expression, which can also happen and the store why you do access, you need to produce an address. So this is what is returned from an access and an updated store. So if the accessor is a variable name, then what you need to do is you go to the local environment, which is a pair or an environment plus then the next three location, we just we just look up the local environment. Sorry, we take the local environment from there and we look up x there, we get an address. And we are interested in this address. So this address is what we return, and the store doesn't change at all, in this exercise. When we dereference an expression, then the idea is this expression, it should be one that actually has an L value. So it should give us an address, so I just evaluate the expression, back comes an integer, but it's a specific integer that I can use this an address together with an updated store. So what comes back here is an integer and this store.

52:39  
Finally, if this is indexing, then what do I have indexing is given by a pair of an accessor and an indexing expression,

52:46  
what do we need to do? You have to approach this act with access this gives you an address and an updated store then you have to go to the store.

53:01  
So this address Yeah, arrays are pointers to get an address, you actually need to go to get to the store and get to know where the Get to know where the where the actual array elements are, which is another address this is this a Val here another address, then what do I need to do? I need to evaluate the index expression already in this modified storage, what I get back is is an integer and then the yet newer storage and then the address where you actually need to look up the array element or the others that we return here. At this point, we don't get to the lookup we just return an address is the address of the first element of the array of the array plus the correct offset given by the you know, indexing expression. So, maybe the array was the array the first element is at position 17 maybe after the fourth element, so I is four. So then I have to go what I need to return is dadra 17 plus four. Finally, are almost finally calls to functions. What happens so there is this function name is are the actual arguments. local environment global amount of given store. This should be the return value from the function if it returns anything

54:37  
and then a new store What do we need to do? The first thing we need to do is

54:45  
we look up the next fee address in the local environment or we don't even look at that I mean we just we see the local environment as a pair and the second component in the pair is the next location in the global environment. We get sorry, we just pattern match the global environment. And we find out which of the global variables, which are the global functions, then we look up F in the function environment, this gives us the declarations of its parameters and the function body.

55:26  
Now we've done all the lookups, we need here to do some work.

55:41  
What's that, I need to evaluate all the actual arguments. And I use this helper function eval, yes, that will just start with this local around global environment and store, work through these and possibly update the store. And it gives me a bunch of values, I mean, after producing each value, it may have updated the store with the story threaded through here, I get the final modified store, then we use this storage to do what, then we bind all of the parameters of the function to the actual values that we get back from from here. So the second components from the parameter x, which are not the parameter types, but they are the parameter names, we

56:30  
bind them to the, to the values, this will actually assign addresses to all these things. And in I initialise them in the store to minus one or maybe if it's a raised to two more things,

56:46  
and yes, this is done with these data, the variable environment and the next lock where the variable environment was the global variables that already given and the next lock. So these are these are the variables that are already there, they are the global variables, next lock was them. next location that is there. And, and with all this, and what comes back is some new storage. And the function body environment. And then finally, which is which is yet the different local environment that has the old local environment, plus all of the all of the local variables that come from parameters,

57:36  
you know, the local variables from the parameters, and then we execute the function body,

57:42  
which of course, can yet grow the local environment, because the function body may have its own local variables, etc. But whatever, when we execute the function body, then what comes back is the storage. And here since we didn't implement return, actually, we return nothing from the function, we just returned the final store. So we will have to treat the return statement separately. And Jen, this is not yet done in this file at all. You will actually see here the return statement is says not yet. Done with this, the final bits, how do we execute the statement? But maybe it's the least interesting thing. So local environment, global environment store come in, and you produce a new store, what do you do you look at your statement, if it's an expression seen as a statement, then you just evaluate it, what comes back is the return value in the store, you update it store, you ignore the value, you just return the store. The return statement is not implemented. If I've got a whole bunch of statements,

58:55  
which actually statements of statements or declarations, I should say, then what do we do, we loop through them starting with a given local environment and store. And in each one of them,

59:18  
we

59:20  
we just process the statement or declaration with respect to the local environment. The current one the store the current one, these ones keep changing the global environment doesn't change in this course, because we don't have we don't have any local functions we only have functions. For if the nails, evaluate the guard, you get a value and an updated store. Then depending on if the value is true or false, you execute one statement or another in the new store. If it's a wine It is very similar but you need to recurse so we need to use a helper function loop that uses the givens store as the initial accumulator and then the accumulator keeps changing the store is updated with every iteration of the loop and at the beginning of every new iteration you check, whether the value of the guard which in turn can change the store by the way is true or not. And you then run the current iteration from the store that you'll be well aware that the current evaluation produced no block produces these statements or declarations each one of them is either a statement which you just produce by executing the statement and not changing the local environment, if you process the declaration, then you need to allocate memory for x given type in this local environment that is provided to you with a store that is provided to you and come back in your local environment and store. So both the local environment and the store may be updated. Finally, for the top level programme, what do I need to do that's the very last bit how to run a programme. A programme is a bunch of top level declarations and then input values which are the actual arguments which are integers to the function may so we initialise an environment and a store based on the top level declarations. So, this will give us a store an environment for variables the next three location and the function environment, then the main thing or not the main thing, one of the things I then need to do is I actually need to get going so this initialises the environment and the store

1:01:57  
with everything, so with the global variables and the functions and the functions are only global, then I need to look up the function main in the function environment, then I get the main parameters and main body, what I then need to do is I have to proceed from the store that I obtained by initialising the environment and the store, I also need to produce from the variables that I got there, the next three locations, these are the global variables. And I need to bind all the parameters of Maine to the values that are given here as input, these are the values come from the command line. This actually gives me it's actually gives me a local environment where what all these findings are done properly, and then updated store and then finally, we just have to execute main body here. So where exactly do we execute it we executed in the function environmental variable environment that we got by processing the top level declarations and the local environment that we got by binding finding the the argument right is from the command line to the to the to the parameters. And that is it is a complicated piece of programme. There are examples here, I think I will visit them a bit on Thursday. But for today, I'd like to stop here. So what happened, we went through the syntax of micro C, the important bits are there is a distinction between any old expressions that do denote some data values, but are not necessarily stored in an address. So the only denote our values POS perhaps. And then there are accessors that truly are somewhere in the store. So to every search expression corresponds both an address in the store, and the actual data value, which is at that address in the store. So accessors are a special important case. And then there are statements. Statements contain things like ifs and Wiles, every expression counts. There's one particular view assignment which are expressions is a statement. There should be a return for returning from a function that one was not implemented. So although we could declare the types of functions, so the functions return something or interest, really at the moment, we don't return anything. And no type checking is happening. And then I explained how how everything works. I think there was one place where I jumped over. That was a mistake.

1:05:00  
When we talk about the function declaration, then it looks like this. But I forgot to say, for the function type,

1:05:07  
the function type cannot just only be integer or character or array or a pointer, the function type can also be void. And that void can never be an argument type. So therefore, we represent the function type here by tip options. So this means a functions return type is either just T for some regular type T, or none and the none stands for,

1:05:31  
for void.

1:05:32  
But in practice so far, we're only playing with void functions are functions that are declared to return something but really only return some sort of an error value which was minus 111. So that is it for today. I thank you for your attention. And I stopped sharing here. I also stopped the

1:05:56  
video

1:05:58  
and see you another time.

Transcribed by https://otter.ai
0:18  
Right, so I'll tell you

0:22  
something about lists, which is the first data type we consider.

0:31  
Also known, or you speak about these things in F sharp as discriminated unions. So lists are a data type or a recursive discriminated union type. And then in that connection, I'll also tell you a bit more about higher order ness and polymorphic functions. Because both phenomena are very common when you're when you programme with lists, let me share my screen.

1:06  
Yes.

1:09  
I'll also show you another thing related to the F sharp interpreter. So last time,

1:15  
we typed the things into the interpreter directory still.

1:22  
Which were things of two kinds, either expressions to evaluate for then definitions of new names with the previous lab definitions without an import.

1:34  
Now, let me show you something different. So of course, when we've got more code, you want to pre prepare it you want to load files is the way you work, maybe a

1:45  
whole host of files that you want to work with.

1:50  
So here is my module, F sharp Part Two and a file, that's also called F sharp Part Two Fs, I can load the file with a directive called load.

2:03  
So this one will produce some output on the screen. The first part here is some warnings. These are warnings about very weak things. So some of my pattern matches are incomplete, that is completely normal. And then we'll see all these names that were defined in the in the file.

2:22  
But they're in the modules. So to bring the module to the top level, I need to open the module for that I can use the command open, F sharp, part two, we already saw open system.

2:33  
So I do that as well.

2:37  
Right. So what are lists, lists are a data type.

2:44  
That's the word that you would use in so many languages, F sharp people like to talk about discriminated union types. So it's types that mix together values of a priori different types, discriminated by tags, and this one in particular is recursive.

3:01  
So, there is also polymorphism. In here in that you can define lists over various types of values. So what is a list a list is a sequence of elements

3:12  
of the same type of any finite length.

3:18  
list in some sense, are pretty similar to tuples. But there are two very important differences. Namely, in a list, you can only put elements of the same type,

3:31  
that length can be arbitrary, the length is not constrained by the type.

3:37  
In a tuple, things are exactly the other way around. You can combine together values of different types. In general, of course, they can happen to be the same, but in principle, at every tuple position, you can have a value of a different type, which is then also registered in the type of tuple as such,

3:58  
and the length is fixed. So lists the same type, any length tuple.

4:05  
In general, different types, fixed length.

4:10  
How's the type of lists over a given type Digi note, it's written as t list.

4:18  
So let's do a few lists. So such a thing, for example, is a list.

4:40  
Oh, sorry, single column, of course, single semicolon. So that's the thing, of course, is a list.

4:47  
So it's a list of three elements 123. They are all of the same type their values of the same type. So therefore it's a list of integers.

4:56  
I can also make a list maybe true false.

5:03  
So that is a list of two elements, of course, elements can be repeated, there is no problem, I can make a list of three tools, for what but it's possible, I can also do things like, Hello,

5:16  
world, here

5:20  
I

5:22  
come.

5:26  
And you can already see I'm making mistakes.

5:29  
So in so many languages, you do list with a comma, but in F sharp is semicolon. So that is a list of strings. And you might you can make lists of anything, you can also make lists of

5:44  
functions, if you wish functions of a specific type, you can also make lists of tuples, there's various things that you can make.

5:52  
What you're not allowed to do is to meet together at present origin. So I can't say for example, and one and two

6:00  
would be a list.

6:02  
So, so here look at the narrow right. Why is this list problematic? Because

6:15  
the first element is an integer. So therefore, the system already has the expectation that the whole list would be a list of integers. But then the second element is both now this one is complained about the both the second element.

6:29  
This is how this looked like they are finite sequences. But actually, this is, in some ways.

6:40  
Just the appearance, the surface appearance of things. Internally, lists are made with two different data constructors are in F sharp, we also say tax,

6:53  
which correspond to two basic ways of constructing lists. So there is the data constructor,

7:01  
empty brackets that corresponds to the empty list, it's a perfectly valid list. And then there is the tag or data constructor, double colon, which you can use to prepend a new element the new value to any list that you've already constructed.

7:21  
Let me illustrate this. So here I'm defining a particular list actually is already in the scope, but I can

7:28  
redefine this name in this scope.

7:34  
So, this is a good list is called x is one

7:37  
I could test if by any chance this is equal to this thing.

7:47  
And actually, these so this is really shows also through your what it is internally, it is seven prepended to the list, which is 913. mp, from where the visualise the rise, it arose from prepending, nine to

8:04  
the list consisting of 13 only. And that list in its oltre was made by prepending 13 to the empty list. So any list arises by starting with the empty list and prepending it means to say, putting

8:20  
individual elements in front of you know, the empty list.

8:25  
Now the test to succeed so that the two lists really are the same thing. What you here see is, is sort of nicely formatted representation of a list. This is what it is internally. And that is actually used

8:40  
a lot because you define functions on list by pattern matching.

8:45  
And it's important to distinguish two cases of lists, the empty list and cons lists. So the data constructor double colon is called cons for constructing. And any list is either a cons list or the entity

9:05  
doesn't make sense.

9:07  
And once again,

9:10  
lists can contain elements of any time provided, all elements are all the same type. So in particular, I can also have lists of lists. So for example, this thing would be valid.

9:24  
Sorry.

9:32  
So it is a list of list of integers. More rarely think parentheses are here, but they don't need to be written.

9:42  
So the outer list is this whole thing it can contains two elements. This is the first one it happens to be a list. This is the second one, it happens to be a list.

9:52  
And these lists in turn are lists of numbers and they happen to be of different lengths. For example, the first one is of length two, which is

10:00  
Second one is of length three, but that doesn't matter both are valid lists. Both are lists of integers. So therefore, they are the same type. Therefore, the whole thing is a list of a list of lists of integers.

10:10  
I should be careful with this. So, literally, if I want to have lists of lists, then I have to have lists of lists. For example, this one is not okay.

10:20  
Because the two first elements are lists of integers. But the last one is a single integer. So this one is not good. But of course,

10:33  
I could do this thing.

10:45  
In particular, of course, lists can also be

10:49  
a list of tuples.

10:51  
So very typical, are lists of pairs, way to think of the two components of the pair as corresponding to a key and the value in a kind of a dictionary, like, data structure. So for example, I might want, perhaps, to define this dictionary for reading out numbers in English or something. So I could say, one is one.

11:18  
And

11:20  
two is,

11:24  
and

11:26  
three is three. Do you see I already made a mistake here.

11:33  
So strings have to be in quotes. Otherwise, they're just names. So that is a good dictionary.

11:42  
Unless I managed to put some wrong sign here, this one is wrong. tuples with commas, lists with semi colons.

11:53  
And you can see it's a list of pairs of integers and streams,

11:58  
which is good. I should also tell you another thing. So which is maybe also good to know. So when you form a tuple

12:07  
unless this is required for 4444 presidents reasons, there is no need actually to put parentheses around 2%. And this is sometimes quite useful, you can avoid,

12:21  
you can avoid noise clutter.

12:24  
So you could also write this list of tuples. In this way, it's exactly the same,

12:30  
and maybe a bit better. So comma for tuples, semicolon for lists.

12:37  
And that's the dictionary.

12:41  
Let's talk a bit about how you could use lists,

12:46  
well, values of any type you use them by, you know, to process them with functions. So if I've got a list of numbers, I might for example, be interested in finding out what the sum of these numbers these are maybe what the product of these numbers is. And here are some first examples of doing this thing.

13:05  
Where we show that you know the process elicits you don't know the length of the list

13:12  
in a functional sorry, in an imperative language, you would perhaps use a loop

13:17  
in functional programming loops are not directly available to us such I mean there is no for loop construct or a while loop construct as such.

13:26  
But you can use direct recursion and you use you can use recursion with accumulators

13:33  
to programme things. And recursion with accumulators is already very close to loops. Essentially is, is a form of loop of loops.

13:45  
Let's write things directly by recursion. And this is to teach you how you have to think really don't think loops, if you can, it's always a good idea to see if you can

13:59  
think of math of functions mathematically. And then a function on a data type is really defined by case distinction. And recursion. recursion means

14:13  
I find function is defined in terms of itself. In the case of a data type, the very common pattern is you define what the function is

14:26  
on a value in the data type, in terms of what the function is on structurally smaller values on the data type. So basically, you decompose the given value in the data type into smaller and smaller parts, until you reach the bare bones. So to say in the in the list case, the empty list.

14:46  
And thereby you've fully defined the function. So let me let me show you here.

14:52  
So in the case of

14:55  
summation, so what's the idea I want to add together so this is already in this

15:00  
Nope, I can use it, I want to add together the elements in my list. So maybe like these elements,

15:08  
it should be three plus three plus four plus five, which would be 15.

15:15  
So how was this defined, the code is here.

15:20  
I'm recursively defining. So it's left and not only left, but like wreck the function some axes is my parameter. It's very common among functional programmers to denote.

15:33  
It uses names for lists.

15:37  
Things of the form x's, y's and M's, what s kind of indicates plural. So it's multiple axes. It's just a mnemonic is really good style to do it like this.

15:51  
So x is a list. Maybe if you've got a list of lists, then you would call it axes, like axes in clora. x.

16:00  
So I match axes. And I consider two cases. If the list is empty, well, then we should know what the sum is. If there is no elements to add together, it should be the unit of the addition, which is zero.

16:14  
Any other list is a cons list. So there is the head of the list, and that is the tail. what I call the head is the first element, what I call the tail is all over the rest, right? These are standard names.

16:25  
In this case, I could say the sum is this. I mean, mathematically, it makes sense. And then you should think why why it also makes sense, like programmatically,

16:36  
really,

16:38  
the some must go in there must contain the must contain the head element.

16:45  
And then what do I need to add it together with? Well, if I've already or if someone has already added together all the rest of the elements, for me, all that remains to do is to add together x and the sum of all the rest.

17:00  
Now, the idea with recursion is x is smaller structurally than x cons axes.

17:08  
We think that we've reduced the bigger problem to a smaller problem, and then we let the smaller problem take care of itself. So to say, the idea is, when I want to calculate the sum of 12345, I say, well, it's one plus the sum of the rest, then when when I tried to calculate the sum of the rest exists, well, it's the sum of two. And then what then remains, which is the sum of 3454345, I do exactly the same, I say, well, this sum is three plus the sum of the rest, etc, until you reach the base case, which is zero.

17:44  
Do you see this, maybe for one session break this

17:50  
just to explain.

17:53  
So this thing simplifies to

17:59  
just by definition, since this is a cons list, it will be at one plus sum of 2345.

18:08  
But that in turn, is one plus.

18:13  
Let me put parentheses to be very clear here. Some are 345,

18:20  
which in turn is one plus two plus three plus sum of

18:29  
five.

18:31  
The computer is quicker at this than I am.

18:41  
Took a list that was too big for plus sum of five.

18:50  
And what is that

18:53  
there is a few steps still to make.

19:02  
Well, that one is five plus some of the empty list.

19:12  
And this one is zero.

19:16  
And actually, now we can calculate.

19:24  
Let me just put the fatter arrow to signify that this happens now in multiple steps.

19:29  
There is something that may be slightly unsatisfactory here, which is that addition cannot start before I've reached the base case. So just accumulate numbers. So this can be counteracted.

19:42  
But it's really not important. It doesn't we know so much in inefficiency, another point we can discuss this. Great. So this is summation

19:52  
Murrell here, think reusing a bigger problem to a smaller problem and the idea is that you

20:00  
If you read repeat this reduction, which is what recursion does, then at the end, the problem should become very small and just go away. So to say, and this is what is happening here.

20:11  
Let's do another example product. So maybe I don't care so much about the sum of all these elements, but I want to multiply them together, which actually corresponds to factorial is, in the case, if the list is like, like this one here, so it's this particular interval from one to five.

20:35  
It is the same thing. So we have to think what is the product of the MPLS, it should be the unit of multiplication, which is one, I mean, one is the number such that if you multiply it with anything else, then you'll get the same number. Zero is a very bad idea, because if you start multiplying stuff with zero, then you never get off the ground, you will always have zero,

20:59  
but one is good. And then in the case, if I have a conflict, all I have to say is well, to,

21:09  
to,

21:11  
to find the product of a list that consists of a head and tail, I have to multiply the head with a product of the thing.

21:19  
And here it is distinct, it's the factorial of five in this particular case, but of course, my list could be completely arbitrary, I might be interested in multiplying together 17 and 42.

21:31  
or something else.

21:34  
I should maybe point out one thing here.

21:39  
Let's think about the scope of names here.

21:44  
For a moment, prod is something that I define is a name that I'm defining in this in this in this module. So when I load the module, it will be available is defined.

21:57  
Also.

21:59  
Now x is x is is a parameter, it is used here, the scope of the parameter is just this particular definition.

22:06  
But now something interesting happens. So I do pattern matching. When here, I introduce any names. These are again, an inner scope. So I've written axes here, that is not the same axis as this, because x is cannot possibly equal.

22:25  
x ex cons itself? No, it's another axis. It's the kind of inner axes, which is the one that I use here. So this axis is the homeless. That is the Taylor.

22:36  
Maybe it would have been clear if I wrote this.

22:41  
But you if you're sufficiently used to it, you don't really need to do this thing at all right? You can be used.

22:48  
Yeah.

22:50  
Keep the planet green.

22:54  
I should also say one thing. Last time, when I introduced definitions directly in the,

23:04  
in the interpreter, piping them at the prompt, I had to put the semicolon at the end of everything. So this was to signify I now want the process. You don't need to do this in a file.

23:15  
In a file, you can't ask the system to evaluate anything. So these things I just put here as comments, these are the kinds of things that you can try out at the interpreter prompt, I can introduce all these definitions, but there is no need for me to put the semicolon at the end here. I made the week.

23:32  
But there is no need to do it. And it's actually much less noise if you don't put any of these things in here.

23:44  
Let me introduce you a few more things that are interesting here. So these patterns,

23:53  
they can be nasty.

23:57  
What does this mean? It means that in the case of at least, sometimes it's useful not only to distinguish the cases where I've got the empty list versus I've got a conflict to a list of at least one element which is what constitutes these sometimes the the the the case distinction structure has to be different. So for example, it makes sense to distinguish the empty list

24:22  
a list that is Singleton

24:27  
which I could actually write different.

24:31  
also write

24:37  
double colon empty, but we can also use this syntactic sugar that we have for lists. So this is this is the sequence of one elements we can directly write with. Okay, so I want to distinguish, empty list one element lists and lists of at least two elements. So lists of at least two elements case, x semicolon, sorry, x double colon, y, double colon, something

25:00  
Girls,

25:03  
and hit I'm doing this so x, y.

25:08  
But then I also may want to give a name not to the,

25:13  
to the, to the remainder of the list after the second element, I may perhaps want to give a name to all of the pay. And then I can use this pattern,

25:22  
which includes the as keyword. So this is not as, as something as something else. And the idea here is, I may want to eat my cake and have it too. So I may want to break the tail of the given list into two parts, the head

25:42  
of the tail and the tail of the tail. But they may also want to keep it as the whole. Namely, I want to use the tail as the whole. And I want to name it axes. So these axes here is the name of the tail of the total list. Whereas the tail of the time, since I don't need it, as such, I've just written underscore here.

26:03  
What's the whole function doing? So this wants to do the following thing.

26:10  
The idea is I have a list of integers.

26:15  
And I just want to find the differences between consecutive pairs of elements. So let me do something like this.

26:28  
I'm after seeing that the difference of one and three is to the difference of three and five is to the difference of five and seven is to the difference of seven and 33. And the difference of 10 and 15. Is 50.

26:40  
Yeah,

26:42  
this is what I see 22235.

26:47  
Yeah, I've already implemented this, but what's the trick them? So what do I want to see if the list is empty? There aren't any differences. So I should get back the empty list. This is signified by this sort of clause here, what I'm saying this is how I treat the empty case. If the argument is empty, what comes back is the empty list. If the argument is just a singleton list, only one element then of course, I cannot also take any difference.

27:13  
There is no pair of elements to talk the difference of then I say, okay, no difference is here.

27:19  
As soon as the list is at least two elements, I can form a new list whose head

27:28  
is that is the difference of of the first two elements. And here's the interesting thing.

27:38  
So what are the rest of the differences?

27:41  
It would be bad to say that I apply diffs to the tail of the tail, because then I only get the difference of their first and second, third, and fourth, fifth and sixth elements. But that's what I want, I want to have all the differences first and second, second, and third, third and fourth. So really,

28:02  
at the point, when I've decided I want in the list that I produce, I want to return the first difference, I should say the remaining differences will come from the tail. So including also the second element of the of the global list.

28:18  
This is nested patterns.

28:22  
Let's do some more functions on lists. The lists that we saw so far are the list functions that we saw so far. They operated in integers, they were specifically integers.

28:37  
Well, module overloading because

28:41  
plus is also defined on floats. So actually, I can define type the function sum, not only as going from list of integers to an integer, but also List of floats to a float.

28:54  
That also works.

28:57  
This just uses overloading, but it's nothing that would work for any type in general.

29:05  
Did I? Did I declare it to be an integer?

29:16  
Oh, yeah, maybe it's already in the context like this, because there's somewhere indicated to type but but in principle, I could do it for floats.

29:24  
by just saying that I intend to type float here.

29:29  
He specifically the arguments, say axes

29:34  
or maybe the return type is is the flow. No, no, no, no, I see where the where the issue is. So of course, this is not polymorphic even even even by reaching the floats, because I should be careful here. To start to get to produce floats. I would need 0.000 sorry, so I was wrong here.

29:57  
This would work polymorphically because

30:00  
minus is overloaded, it also works on floats. And in the base case that don't mention any particular number

30:08  
was all correct.

30:14  
Still not, then I don't know why.

30:17  
Maybe,

30:19  
maybe I've still somewhere indicated that I mean that time.

30:26  
But now we want to do properly University polymorphic functions.

30:35  
So one of the things that you might want to do is to calculate the length of a list. There is actually a library functions for this. So such trivial things, you don't need to implement yourself. So we could very well say that I want to

30:50  
have this length.

30:54  
But it's true.

30:56  
But suppose I wanted to implement it on my own. And right now, I haven't opened the module list. So it's not in scope, I can't use it as such, I need to use a with a fully qualified name list dot length. So I'm free to implement my own thing. And I've already done this. So let's see how this would be done.

31:13  
It's the same idea.

31:16  
You'll have to

31:31  
you have to consider cases. So what are our cases? I've got the empty list. Well, the length of the empty list is zero. What is the length of any cons list? Well, it's just one plus the length of the tail Isn't that obvious, right. And then when we're given a big list of five elements, then for example, you say, Ah, that contains a head, therefore, it's at least one, then you look deeper, you see, there is also in the remainder has a head, so it's at least two, then you keep adding, and you get this thing. So in particular length of this thing

32:01  
is three, and length, this thing is four.

32:08  
And this function is properly polymorphic. In that what we return are integers or floats, I mean, we work with zero, which is an integer and plus some integers.

32:18  
But really nothing here needs to look at the actual elements. I could even emphasise this by putting an underscore here, like x is not used, the tail is used. But only even in the tail, I don't recursively look into any elements, I'm just calculating the same function length, and again, doing this pattern match where I never look at any real element. So therefore, length works, at least of any time.

32:42  
This, this apostrophe ad here is, is a

32:48  
is a type variable suite, which signifies this thing works for any type, as many.

32:55  
So here are two other functions that are very useful.

32:59  
head and tail. So we've already seen how to extract

33:04  
head and pain for use in a function by pattern matching. But actually, I could also define these functions head and tail as such, using exactly the same pattern matching mechanism. And it's very similar to how the first and second before so I could define heads like this.

33:24  
I say if I see a cause list, I just extract its head, I could define tail like this. I say if I see a conflict, I extract its tail.

33:34  
These functions are particular, in that they are not well defined on the empty list.

33:43  
Yeah.

33:45  
There is no case for the empty list. So this sounds dangerous. And that's actually what the warnings were about when I loaded the code.

33:55  
So

33:57  
for programmers convenience, I mean, this design could have been decided differently. But here's decided like this for programmers convenience, incomplete patterns are allowed, you're warned about them. So you have to use them with care. Because if of course you apply a function to an inappropriate arguments like here to add to the empty list, you will get a runtime error and runtime errors is something that you don't want. The idea of a strongly typed

34:25  
programme is that all type errors should be caught

34:32  
before running the code. And this should almost qualify as a type error because the thing is not defined on our list. It's only defined on a part of the data pipe.

34:43  
But But you do allow it, you don't specifically treat the sub case of non emphasis, or subtyping.

34:51  
So let's see applications of this. So if we take care of this

34:57  
surely it should be seven

35:00  
The tail is not seven, it's nine in Turkey.

35:06  
But if I do something bad,

35:09  
like take the tail of the empty list, then it loudly complaints

35:16  
actually here for the wrong reason, namely that in the first place, it doesn't know which type, the empty list is over, it could be the empty list of integers, empty list of

35:28  
floats or whatever. But I can be specific, I can say that this is a list of integers.

35:34  
You don't see

35:36  
I can pretend it is and then there is another problem arises, namely that

35:44  
namely, that you can't take time. Now it says, Stop due to error. There is lots of complaints. But but that But the main point is here, the match cases are incomplete. Yeah.

36:01  
The first case, I got this different error, which I have to explain On another occasion, simply for the case that there was not enough type information around. So this happens when you call tail on and on the emptiness like this on the top level. But if it's already an empty list of a specific type, you will get this error.

36:22  
One very typical thing that you want to do with list is to put together two lists, simply by concatenating, the two lists, which means

36:33  
take the two sequences, which lists are and just put them one immediately after the other.

36:41  
For your convenience, this is actually

36:45  
defined not in the list module, but in the bases environment. So this is you can think of it as a module that is always loaded. So these are some standard functions that are always there, you can use them.

36:57  
The names like this, you don't need to open the module, or you don't need me to use the fully qualified name. So append or concatenation.

37:07  
These are synonyms,

37:10  
takes two lists and make a new list.

37:14  
It's usually used in an infix notation. So therefore, when I define it, I should use it with parentheses. Now, I can't define it myself. Or I could, and then it would just shut out the one that is given by the best is environment. But but but morally, the definition is this, your pattern match

37:34  
the first of the two lists,

37:37  
the first list is empty,

37:40  
then you just return the second list.

37:43  
However, if the first list is cons, something to something, so there is head and tail,

37:52  
then you can reduce the big problem you have, which is to cons sorry, which is to append x cons, X's to y's

38:01  
to a smaller problem. Namely, what is this concatenation gonna be? Well, its head is clearly just

38:10  
x. And the rest you get by concatenating. Together the tail, and all the y's, the tape is already a smaller list than the original list. I mean, this is the original list, this is the tail of it by pattern matching. So we reduce the bigger problem to a smaller problem.

38:34  
And

38:36  
here's one application.

38:40  
Of course, the correct things happens. And you should also notice that here,

38:45  
well, differently from the case of length, where I didn't look at elements of lists at all, here we do, but still is a polymorphic function, because I'm only sort of,

38:57  
you know, I'm only

39:01  
I'm only passing around elements of my two lists, but I never properly look at them. So here I see a pattern match against x and I use x directly, not asking, you know, can you take the square root of this xR, can you add five to it? Well, the first thing would specialise it to a float and the second one would force it to be an integer, nothing like this. So x can be anything because I'm only passing it around not applying any specific,

39:27  
you know, a type specific function to it.

39:33  
Let's do another

39:38  
example of a polymorphic function.

39:42  
So very typical thing you want to do is

39:51  
use lists as kind of poorman array. In an array you want to have access to an element at a given position.

40:00  
given by a number. So I might, I might want to be interested in the NF element of the list where the first element comes is zero to zero with the second is really the first etc. As you start numbering from zero, this is the convention,

40:15  
you can define such a function, it's actually also defined in the last module. So you can use list item directly. When I can do something like

40:27  
list item, the first element in two 350.

40:34  
That is three because numbering starts from zero, that's the zeros. That's the first the second element.

40:42  
So I could use the library function by by which I can use it by using the fully qualified name or I could open the module list and then just use item. But I can use also use write my own item, which is what I've done here.

40:56  
And this is maybe a first example to show you

41:01  
that if you define that list function, you don't always necessarily pattern match on a list.

41:09  
You may, for example, want to pattern match to something else, because this one is a morally, a two plays function. So it takes

41:19  
it takes two arguments in a sequence in a curried way. First, the list and an integer.

41:29  
And one we pattern match on is actually the pair

41:34  
of the index and the

41:37  
other list Why?

41:41  
Well, let's see why.

41:45  
The real pattern match, I would say, in some sense,

41:49  
is on the number. Or there are different ways to look at it. But but this is one way to think about it. So it is very clear what to do. In the case, when I want the zeroeth element, then I should just extract the head of the list. So this is a very good situation. So if I'm interested in the zeroeth element, and the list actually is a cons list,

42:18  
then it suffices to extract the head, right?

42:22  
Make sense? Now, for any other number, remember, pattern matching goes from top to bottom. So first, we try the first pattern, if it doesn't match, then the second so if you reach here, you can be sure it is not zero, otherwise, you would have used this. So for any other i what i do is

42:41  
we should think that this is a positive number. So for example, if it's true, if I need the second element in the list, well, then surely the list also has to be a cons list. And the problem reduces not to finding the second, but the first.

42:56  
So the one one less position element,

43:00  
not in the given list, but in the tail. So whenever the number is greater than zero, which I'm not explicitly asking here, but I just don't care,

43:09  
at least I know is not zero, then then we make a recursive call on a number one smaller and on the table.

43:21  
And that should be fine. But now there are several things to notice. One thing to notice is that I'm not pattern matching just axes

43:31  
using some specific forms expected can take, neither am I doing it just alone on what and I I'm doing it at both at once, I could actually have a nested pattern match where I first pattern match an eye and then inside a pattern match on x's. But this is just too complicated. It's not necessary here. Also notice these are pairs.

43:51  
So I don't write the parentheses around because he's not needed, but they are pairs.

43:57  
Also note that this pattern match is is again incomplete. So there are cases where looking up an item phase.

44:07  
What is the base case of failure? Well, the base case of failure should be when I want to look up the first element, but the list doesn't contain anything. So for example, zero and empty is missing.

44:18  
But actually the same problem arises when I look at the bigger number still, of course from the empty list, you can't extract anything.

44:26  
So in general, what will happen is, if you now say want to look up as the seventh element in the list

44:35  
that doesn't have eight elements. Remember numbering starts at zero

44:41  
which is shorter then then you do get the pattern match error runtime which is maybe a bad idea. So maybe you would like to build some Exception Handling or some type safety here this can be done but this will be the topic

44:56  
of of next week.

44:59  
But for the most

45:00  
quantities like this. Also, you should pay attention to, to what actually happens if I happen to give a negative number, what do you think.

45:10  
So if I start with minus one, if I'm looking at the minus first element in a list, this is reduced to looking up the minus second element of the list provided the list is accomplished,

45:23  
then minus 30, then minus four, etc. So if you start with a negative number, you will actually loop forever,

45:31  
forever, maybe you have to take with a pinch of salt. Because actually,

45:36  
you, you get growth of,

45:41  
of the frame stack. And at one point, perhaps you get Stack Overflow. But But ideally, if your computer had infinite memory, you would run forever.

45:52  
So let's experiment a bit with this. So let me show it to you. So when I want to take the

46:04  
the fifth element in the list of one to 10,

46:10  
then it's actually six yet I'm showing you something else. So there are some, some shortcut mechanisms for writing down

46:18  
lists that go with a fixed step. So if I want to have the list 11231234, up to 10, I can just write this thing. That's the list. And the fifth element there, since I start numbering from zero is actually six. But now if I want to look up the 10th,

46:36  
sorry, V.

46:39  
What do I want? If I want to look up the 11th element here?

46:44  
What do I get? I get stopped, stopped you to era. Why?

46:49  
Because the elements are numbered from zero to nine here. So 11 is too big.

46:57  
Yes, in particular, you also get an error when you try to extract any element from the empty.

47:07  
Okay, let's do a bit more.

47:10  
Now, I want to show you something else. So you've seen quite a bit of Lisp programming already using recursion.

47:22  
Right now like to do a bit of another abstraction. So in functional programming languages, like ml type languages, also, Haskell polymorphism, is all over the place, and you try to exploit it to the degree that you can, it's really great if you don't have to write a special function, somehow, especially using representations of particular types, for every type that your function could potentially work on. I mean, if a function should uniformly work at any type, then you should be able to write down just just one function that that that can treat any type, which we've now done on multiple occasions here.

48:03  
Similarly, if

48:07  
it's in function inside functions, there are repeated patterns, then you might be able to group a bunch of functions together into a simple function. And that is the phenomenon of higher order functions. So you make functions take other functions as arguments. The definition of what a higher order function is, is it's a function that takes a function as an argument.

48:33  
We saw that you do two plus functions, you can do them in curried form, which means you do get functions that produce other functions as as returned values.

48:43  
That's one way in which it manifests itself that functions are first class.

48:48  
But that's not what I'm talking about here. More interesting is when a function takes another function not as an argument. So the argument type is a function type.

48:59  
We saw one little example of this before when I programmed the function twice, that took any old function, and was then ready to apply it

49:09  
to a given argument twice.

49:14  
So this was the sole example of a hardware function we've seen so far. But now you'll see a bunch.

49:25  
So one very typical thing that you may want to do with lists is you want to transform a list

49:34  
of some type into a list of some other type or even potentially the same time, as especially case by applying some given function to every argument. Like you've got some list of numbers.

49:49  
But perhaps you want to multiply all these

49:52  
elements but by to

49:56  
know intuitively how to programme this. It should go by recursion

50:00  
You should say, you know, in the case of the empty list, I just return the empty list. If it's a cons list, I take the head multiplied by two.

50:09  
And then I recurse on the tail.

50:13  
Yeah, that's perfect. You could write such a thing by hand. And it would be a pretty specialistic function, because it just works for multiplying by two. Okay, maybe you might want to generalise it to me to say, multiply with any fixed number.

50:28  
But suppose I don't want to multiply, maybe I want to add, maybe I want to use the mapping function just to to,

50:37  
to do something else, maybe I, for example, want to compare

50:45  
my list elements to some fixed threshold number.

50:50  
And I want to get back a list of truth values, like these numbers were, were bigger than the given number of these ones were smaller. So accordingly, I want to see true or false in the list.

51:01  
And I don't want to write all of these things separately by hand, I want to capture the common pattern, which is here, which is do the same thing to every element of a list. So what do I need, then, I define this to place function map in the curried form that takes a list of A's

51:21  
produces a list of bees.

51:24  
But before it takes, whatever I want to do with every given elements, so it takes a function sending these two B's.

51:33  
How's this divine, it's a recursive function. map is a recursive functions defined by left rec. So here are the two parameters given

51:46  
given one after another. So it's curried form. It can be partially applied.

51:57  
And then defined, well, it's defined by pattern matching on axes.

52:02  
If the given list is empty, I return the empty list. If the given list is of the form header, then x followed by axes, I apply F to x. And I recursively call the same thing on the tail. So I've reduced my bigger problem

52:17  
of transforming my whole list to the problem of transforming just the tail of it. And then I say, Okay, if I already mysteriously via recursion, no, the result of that, all that remains to be done is to also prepend, the transformed hedaan.

52:35  
So here are some examples. I can use map together with a multiplication function, multiply x,

52:51  
get the list of floats, which has numbers that are twice bigger,

52:57  
I can define a function is large x, I can consider all numbers lands that are strictly greater than 10 as a float,

53:05  
then I can do this,

53:08  
implement this function that goes from a list of floats to a list of Boolean

53:15  
that can apply to this particular list.

53:21  
And indeed, you get the list of billions, right. But map is large, alone, partially applied is what

53:31  
we call is a function that takes a list of floats to a list of Boolean.

53:39  
So

53:46  
here, I introduced names for the functions that I want to map.

53:54  
But also, this is one great place where you could actually just use anonymous functions. Because if the only place where you want to use your his Lodge is actually in the argument of your map, there is no need to invent the name for it.

54:07  
So let's see some examples of this. So

54:12  
shall we say, I want to do something else to this list of mine. Maybe I want

54:19  
actually, to subtract

54:25  
the element

54:31  
from any given missed element, then only all I need to do is I have to say, I apply this following function which takes which takes x as a parameter

54:44  
and returns x minus 2.0.

54:48  
This is a function. I didn't introduce a name for it because I only need it once just to show it to you.

54:55  
And this is my corresponding map thing even if I apply that here.

55:00  
is the result.

55:01  
That's great.

55:04  
Maybe I wanted to do the opposite thing.

55:08  
Maybe I wanted to subtract

55:12  
X from two,

55:15  
then I can also do that,

55:18  
like this.

55:21  
So I say, I apply the map to the following function, which has x as a parameter. And the The result is defined by the expression 2.0 minus x. We do that as well. And this is the result. Now it's different, right? For example, to minus 89 is minus 87.

55:43  
This is also the place to demonstrate to you that that partially applied functions are useful. Remember, mine is is just a function that is actually defined in curried form. Well, it's an operation, but minus in parentheses, I can see is a function in curried form. And here, I just want to fix the first argument to be 2.0. And the second argument is whatever then comes in afterwards, I have a shorthand notation for this

56:10  
just by using minus two as a curried function applied to only one argument, then it is a function that will need another argument x.

56:22  
What I've done here is I've written this above thing in a

56:27  
in a more concise form contains means shorter, and the result is exactly the same. So this C

56:34  
minus is a curried function.

56:37  
curried functions have a preference for specialising on the first argument. So So here, I wanted to fix the first argument to 2.0 that I can implement by just partial application. So I just choose to give only the first argument to minus the result is a function that the cap applied to whatever, in particular, two numbers four, or 589.

56:59  
If I want to specialise for the second argument,

57:03  
partial application doesn't help me, I really need to write an anonymous function, or there are other means also, but this is the most basic one. So I really want to say is the first argument that that I want to vary. But the second one, I want to fix the two points here. So overall, what I'm interested in is are these differences, where I say x is my parameter of this expression. So expression is a function.

57:36  
Now, there are some interesting things. So for example, we had the function length,

57:42  
which we defined by recursion, but you could actually get it

57:46  
if you want, also by

57:50  
by using map and some in combination, how could you do it? Well, given any list, you could do the following just replace any element with one and then some, the resulting list with a list of ones and if some will exactly be the length of the list. So that could be written as follows then, so we redefined length, like this.

58:17  
It's, it's,

58:19  
it has the correct time. So it takes at least over any type A into an integer

58:25  
defined like this. And then when I calculate the length

58:29  
of some list, like I want to say, let's take the list from five to seven, it should be a list of length three.

58:38  
Let me just does it

58:41  
But the trick is, you're in the middle, right? So let's just see. So what is the map of this thing to

58:49  
five to seven.

58:52  
So this is the intermediate results, it's a list of free ones. And the reason why we've got the length was three was that the summation over this list is three.

59:11  
So here is a yet different way of writing length, which you may perhaps want to use.

59:24  
Sometimes, very often in functional programming, you just compose functions to length is basically just a composition of of map and some

59:34  
Yeah, one after another. I could I could make explicit by using this piping notation, which just says you know,

59:42  
I make a long pipe, like like in the Unix shell if you know whether these are Linux shell if you wish, by just

59:53  
sending the results of certain commands as input to other commands

59:59  
in a second

1:00:00  
So here the result of map becomes the input to some and the result of the whole thing. The result of that is this notation for this for composing rules, or so that's also a definition that works.

1:00:22  
What if I want to compose in the other way, then I could just,

1:00:26  
I mean, both.

1:00:27  
Some people may want to write composition from the left to right, someone from the right to left. So this is also possible to write does exactly the same thing.

1:00:41  
So maybe one more example

1:00:46  
of a higher

1:00:49  
order function.

1:00:59  
Are there sorry, on a polymorphic function I wanted to say.

1:01:03  
So So here, we saw the following thing when we defined length, I said, just I want to replace every element

1:01:12  
of the list by one, so use this function that takes in anything and replaces and returns one. So it's a constant one function.

1:01:22  
And I may gave a name to such things that produce me constants. So let me define constancy.

1:01:30  
applied to whatever is just as a constant.

1:01:33  
This defines me so if you applied partially whenever you actually write, okay, let me define it.

1:01:42  
When I've defined this, then I've got the function for every possible constant that I want. So maybe I'm interested in the function constant 70.

1:01:53  
Such

1:01:56  
What did I do wrong?

1:02:03  
Okay, this is also a bit silly. Now, again, I need to do that type. It doesn't know.

1:02:11  
So this is about value restriction, which I promised I will explain at one point, this is a bit complicated. So a constant 17 is perfectly good.

1:02:20  
But the reason why I cannot type it is it doesn't know what the next time periods.

1:02:26  
But if applied constant 17, which is a function to an argument,

1:02:30  
which may be say, takes a string, then everything is good. Yeah, so I string came in, but I didn't care about it, I just returned constant 70. So in this notation, I could write the function length even more concisely as the pipe of map constant one

1:02:52  
with some, so in the pipe, the first thing that is applied to any given argument x is, is

1:03:02  
replace any, any elements with one This is done using the function constant one, and then finally, the sun.

1:03:28  
Here's something more complicated.

1:03:32  
This is an important higher order function, it's called fold

1:03:37  
in many functional languages is called fold l here, it's called fold.

1:03:43  
And this is basically

1:03:46  
a function

1:03:49  
to do loops.

1:03:55  
Well, in an imperative language, when you write the loop, you need the loop control variable. So this is the the variable whose value will vary with say changes in the loop. And then when you want to exit the loop is controlled by that variable, you you say, you know, I run until the variable obtains a certain value or until it satisfies a certain condition. So this the difference between four and one loops, here use an accumulator. and ignore really plays the same role as a loop control variable, except everything is still immutable. So there's never the case that

1:04:30  
that an actual Val variable would change its value, but we make new recursive calls with new or new values of the accumulator.

1:04:41  
So in each call,

1:04:45  
the actual argument is different than that then kind of models this idea of a changing or, or an immutable, low control variable.

1:04:57  
Fold has a very complicated type

1:05:00  
But the idea is, it is three plays curried function. So first comes in a function then comes in an element of type B, then comes in a list over type A.

1:05:11  
And what you're interested is a result of type B. So basically, you want to send the list into a value

1:05:19  
listo, raising the value of IP.

1:05:26  
And you do produce the final thing as, as the result, sorry, as the value of the accumulator by the time you traverse the list and reach the variant.

1:05:40  
So what are the two other arguments? AK, when you make a call to fold is what you should think of as the accumulator currently. So to say,

1:05:53  
f is

1:05:57  
kind of the loop body, if you so wish. So what to do with every particular iteration of the loop.

1:06:03  
And it says,

1:06:06  
given the accumulator value I'm given now

1:06:13  
given

1:06:15  
the head

1:06:18  
of the list that I'm seeing currently, or say, I walked down the list from the beginning toward the end by basically chopping off the head at every step. So that's the current head or the current element that I'm looking at. And this is the new value of the accumulator, that a recursive call will be made, then the definition is followed is defined recursively. These are the three parameters.

1:06:42  
F is the given function for the loop body, or

1:06:46  
x is the name for the accumulator x is the given list. How does it work?

1:06:55  
It's controlled by the list shapes that we match on the list.

1:07:00  
If I'm already at the end, all that I need to do is to return the current value of the accumulator.

1:07:07  
If I'm still seeing a head and a tail, so I maybe have some global list, I keep chopping off the heads and looking at the tape.

1:07:15  
So then I do the following.

1:07:28  
I carry on,

1:07:31  
I carry on with a tail.

1:07:34  
So I moved my focus to the from the current element to the you know, to the rest of the list, starting to look at the next head. So to say,

1:07:42  
I carry on and keep calm and carry on. My looper is still the same, but I work with a new accumulator value. So the next recursive call is made with the different accumulator value. And what is that

1:07:55  
it's obtained by using the current accumulator value,

1:07:59  
the one that was provided at this call, so to say,

1:08:03  
the current head element, the element I'm looking at, and then the loop body applied to those two things. So something happens in this particular iteration, while I go, you know, from the given element to the next.

1:08:20  
Let me explain this.

1:08:23  
Maybe easiest is to look at the sum function implemented in that way.

1:08:28  
So the idea here is to produce a number

1:08:33  
by walking over the list from the from the left or the right from the head, through all the elements until you reach the empty list at the end. So

1:08:43  
the initial value of your accumulator is zero.

1:08:48  
At every stage of the watch, and this is described here by this loop body thinking,

1:08:55  
you're given the accumulator, that's the accumulator at this particular recursive call.

1:09:01  
You're given that the element, the head element, that you're looking at this, this x here,

1:09:07  
all you need to do is to carry on with a new accumulator. So there is no kind of destructive imperative update of the of the current accumulated rather, you'll make a new recursive call with a different accumulator.

1:09:22  
Which is

1:09:24  
fold on these things is defined as fold on these things. We go now to the recursive call with x plus x is the value of accumulator. So that's this point here.

1:09:36  
The same for product

1:09:38  
for length is also the same. So you, you keep the kind of running length, walking down the list, initially zero. So whatever length you already add, so this is the length accumulated so far. When you see an element, you just ignore the element. You just take into account the fact that you do CNN and you just add one to that

1:10:01  
To The number you have, and you use it as the accumulator for the next

1:10:08  
disappear,

1:10:10  
this will mean a lot of exercise to actually get a feel for it.

1:10:14  
But this literally implements

1:10:19  
implement implements loops.

1:10:39  
accumulator plays the role

1:10:43  
of the loop control variable,

1:10:54  
or all the imperative programming missions.

1:11:01  
Now there is a different one, which is called fold back in F sharp, it's called

1:11:08  
fold are in so many other functional languages. And in some ways, the F sharp naming convention is really confusing. But I suppose it was done to to, to appeal to people that are more used to imperative programming So, so fold corresponds to loop and maybe in some senses is kind of more more intuitive.

1:11:28  
For an imperative programming background. They're also efficiency trade offs that I need to discuss in a bind. Because it's pretty, pretty subtle.

1:11:38  
But anyway, so there is another one called fold back, where kind of you go from the back of the list to the front of the list to the word back is, is appropriate. But it's really not loops, it's it kind of encompasses direct recursion.

1:11:56  
So whether they find a function by two cases, basically, you say,

1:12:01  
the value of the finish line or directly, there is no accumulation. and the value on a cause list is for me, given by the value of the T. Three is the value of the function on the tail, which is just assumed the recursion works out for me. And then I use it in some way combining with the value of the head element.

1:12:23  
So here is if

1:12:27  
the argument is also given in a different order. This is to give some intuition for some people. But here is the list over type A, and I want to transform it into a value of type B.

1:12:41  
This parameter here corresponds or these argument here corresponds to whatever I want to return in the base case of the empty list. And this corresponds to what happens in the state case, which here is the cons list of case.

1:13:05  
Here's the definition of fallback.

1:13:09  
Think of F as the step case, C is the base case, x is the list that you want to fall back on.

1:13:16  
So definition goes by cases.

1:13:25  
In the case of the empty list, you just return whatever was specified here.

1:13:32  
In the case of the

1:13:35  
columns, we say, we use exactly the same step case and base case

1:13:42  
for working out the value of the function on the tail. But then we also take into account the head.

1:13:50  
And yeah, we combine the head element and the recursive call results together in some way.

1:14:00  
Sort of the paradigmatic example of a function that you want to define by falls back, rather than fold is concatenation, or append that we saw before, which is really best defined by direct direct recursion on the first of the given list.

1:14:18  
So here's the definition.

1:14:34  
There is one argument missing

1:14:38  
should be the emptiness

1:14:42  
so I want to use fall back on on axes.

1:14:49  
Yeah, the base case is empty list.

1:14:56  
No, no, no, it was all correct. I said it's wrong.

1:15:00  
Everything was correct the base cases. So if, if the first test is already empty as the base case, I need to use the second list, right. So the second list is what you want to return if if the first list is empty, because you're only putting together the empty list and the second list. And of course, the concatenation is just secondaries.

1:15:18  
But what you do need to do in the staircase in the step case, you are, you can assume you're provided

1:15:28  
the result of the recursive call. So this is the result of putting together the tail of the first list. And the second list, you're also given the list the head of the first test, all that remains to be done is to actually just columns, the given element together with a result of the recursive call and that is the definition.

1:15:51  
So we can do this

1:15:53  
is full back into complex right now yesterday's because I defined it, so that is the definition.

1:16:01  
And then I should be able to just apply it, right. So I should be able to do 12345

1:16:16  
sure, everything good. Yes. So this is what we get by putting them together.

1:16:25  
It's really a pant, and it is polymorphic. But I've also worked with strings or anything.

1:16:32  
And let me show you also that you can make it even more cryptic, because

1:16:38  
I know you can't, unfortunately, now Yeah, not not we have to stop here.

1:16:44  
So you could do it with fallback.

1:16:49  
I wanted to say that you can do it a bit more cryptic by just using comes as a curried function. But you can't really because tags are treated somewhat differently. So otherwise, it would be so nice to say that this fallback just applied to double colon, and x's and y's doesn't quite work.

1:17:17  
Combination can also be defined with fold. But let me jump over it and maybe comment on it next time, because it's pretty subtle. Many a time, you may want to use a pole to define a function, and you can achieve some efficiency with it in the sense that you accumulate the function result directly as you go over the function.

1:17:40  
This corresponds to looping or also paid recursion, if you wish.

1:17:56  
Whereas fold is kind of direct recursion callbacks where it's kind of direct recursion.

1:18:02  
So recursion can be more efficient. But there are cases where where third recursion doesn't help you and

1:18:10  
is more complicated organise the thing in a recursive form. And if you do it carelessly, you just get something more inefficient. And append is one example of this. But this is pretty subtle level, discuss it another time.

1:18:23  
Let me finish with one other thing, which is one last

1:18:29  
function that is very useful

1:18:32  
as a higher order function in so many applications, so ever. So often, when you have a list, you only want to keep some elements of the list that you consider good. And the goodness is fixed by some predicate. Now, I might want to write a specific function that takes a list of numbers and keeps only the positive ones. Or maybe something that takes

1:18:54  
a list of strings and takes only those that are made of letters only or something like this.

1:19:01  
But in general,

1:19:03  
I could use this harder function filter that can use any test

1:19:09  
on on the given type of elements. So given a list or type A if I know how to determine the goodness, it's fixed by a function that returns a Boolean for every element, I can

1:19:23  
I can

1:19:26  
I can do this with filter. The filter you can do directly by recursion like this. And since it's direct recursion, you can call the call the double fullback. And again there is a slightly more involved thing that happens if you try to do it with fold for accumulators,

1:19:41  
then you have to be much more careful to keep the same efficiency, although in many other cases, directly more efficient.

1:19:50  
So filter is defined by recursion it takes in a function P that I'd like to call a predicate because it takes a value into a boolean value and then it takes

1:20:01  
In turn, I mean, what were the returns in turn pegs to list. How is it defined just the recursion on the list. So we reduce computing the function on the list to computing the function on the tail with the idea that the tail is smaller than the given this. So in the empty case, I only keep the good elements, but there are no elements. So it's just the empty list.

1:20:25  
If it's a cons list, I need to do the following.

1:20:32  
I test the head.

1:20:35  
If the head is good, then the result is the head comes together with the rest of the list with the tail of the filter.

1:20:44  
So this is the case where I keep the element. That's what I returned, if the test is negative, if the test is false, so then in this case, x is dropped, it's not returned in the result.

1:20:58  
And I only need to resolve return whatever comes back from filtering.

1:21:04  
Yeah,

1:21:06  
that's a direct definition. And if you look at the two cases, they directly give you the two arguments for four fold back. So the base case, for fallback, a defining filtering by fold back over axes comes as a second argument, the base case is empty.

1:21:24  
And here is what happens in the step case. So the step case looks at the head, it looks at the recursive result, which here is filtered p axes, but we just treat it as a parameter set. And what we do is this, we test the element. If the result is true, then we just conduct with whatever comes back from the recursion.

1:21:48  
In the other case, if the test is false, if the test fails, we just only use whatever comes back from the recursion.

1:21:57  
So this is it for now. I'll go deeper into it with you in a live session and they explain things and I'm happy to answer questions and then we also go on to further material. But there are a lot of sort of subtle details here. It is important to you to understand how polymorphism and higher order functions work. So

1:22:21  
I'll be more than happy to comment on the these things deeper.

1:22:26  
For now I stop sharing

1:22:29  
and I also stopped this session here.

Transcribed by https://otter.ai
3:46  
Right So okay, I think we're good to go. Can you hear me?

3:54  
Yes. Very good is the sound at a reasonable level?

4:02  
Well I'm good. Yeah, thanks.

4:05  
Very good. So I'm sorry for for this little delay.

4:10  
First don't didn't want to record that all just hung trying to connect to the cloud server.

4:18  
But now it should be good.

4:21  
Another thing that is not perfectly good is that there is sun on my screen but I can't do much about it but I hopefully it will change in five or 10 minutes.

4:31  
Okay.

4:34  
So let's talk more about the imperative programming today I introduced this little c like language

4:40  
to illustrate programming, among other things with pointers, that is to say indirect Association and and also pointer arithmetic and the race. And this was to illustrate sort of typical things that you do in an imperative language you perhaps

5:00  
Want to have a better control over the memory? We're not that fully there will be on Thursday. And next week in one of the last lectures, you know, we'll also look at manual memory management like it happens in, in a language like C. But But first, we are in this micro c kind of language where there is no user location of memory or no no user the allocation of memory. So let me share a bit and I'll recap where we were, and what we will do.

5:35  
But the main thing today is I'll show you a little abstract stack machine

5:41  
into which you can compile C code. And then I'll tell you a few ideas about how these kind of stack machines are built.

5:51  
For

5:52  
for a non trivial imperative language, in particular, I'll tell you about this idea of frames on the stack. And then I'll show a bit of compilation. And we'll continue on Thursday, and look at more examples. But just to sort of get going and to get a feel for what this kind of machine could be like because it's not.

6:18  
It's not entirely simple at first. Okay, let me share my screen.

6:24  
I'll share this screen actually share.

6:29  
Yes, I want you small here in the corner.

6:35  
So we looked at this C like language before, where

6:41  
you could write simpler imperative programmes, things like these.

6:49  
Assignments assignment if,

6:51  
if then else's while loops, blocks, and also top level functions, no, no nested functions.

7:00  
But the particularity of this was that you had this idea of also pointers. So we could for example, say that I don't know that they want to assign

7:12  
star p where p was a pointer and star was dereference a pointer so a pointer

7:20  
primarily designates an address in the memory here stack. And under that address, you will find a value. So these addresses are also called l values. The actual data values of interest are called our values l for the left hand side of assignment are for right hand side.

7:45  
The point was that to the left of an assignment, you can't write anything. So of course, you can't write things like assign X to five, this just doesn't make sense. You can write assign five to x, this is good because x is an expression that among other things, also has an L value. So if x is declared as an integer, which means

8:10  
that it gets assigned to it an address or associated with an address.

8:16  
And when I write stuff like assign five to x, the idea is the value of five will be stored at this address. Yeah, whereas when I write things like five, five is just the numeral and there is no notion of like some set address where five would be stored. No, I mean, five need not be stored anywhere is just the numeral. So these kind of things are called general expressions, they have right values, data values, some expressions have left values, they can be understood as addresses, and only those can be used on the on the left, and then we said okay, a name can serve as an address, but also things like

9:01  
array access. So if a is an array declared as an array, then perhaps I can assign something to the fourth position of an Array.

9:11  
Likewise, if p is a pointer,

9:15  
so P is something that already denotes an address, I can say okay.

9:25  
To this place, I want to assign three. So the point is, P is a pointer. So to pee we have associated an address, but under this address, another address is stored.

9:38  
I could go there. I could pick up this address, and then I could store the value of three there. This is called pointer dereference. We talked about these things.

9:48  
And what was in this language.

9:53  
This was the full fee, the abstract syntax, we were able to write simple things such as you

10:00  
merles operations unary operations apply to an argument binary operations, specific lazy operations where they do not necessarily evaluate both arguments like and Endor. And then function calls.

10:14  
And

10:16  
they're especially kinds of expressions called accessors.

10:20  
Here, any accessor is an expression, but also the address of an accessor, denoted ampersand a was an expression. Also, you can write assignments, they are treated as expressions. The idea here is compute the R value of E, compute the L value of A, which is an address and put this value at this address. Now what we're accessors There are three types in this little language names.

10:50  
Start p, where p is an expression that

10:58  
that happens to serve the role of a pointer. So then you can dereference it a where a is an accessor. So in general, it could be

11:08  
for example, an array but could also be a pointer. And you can write this thing a E,

11:15  
which means

11:19  
evaluate IE, you will find an offset, you will find an integer value and then you just go to the right from the address of a

11:27  
Imani or evaluate many positions. So for example, if thing is if this thing here is something like

11:37  
a five,

11:39  
a denotes an address, but actually, we're not interested in that address, we're interested in the address that address plus five, because we want the fifth element in the array.

11:52  
See, doesn't really care. So you can actually write the same thing, for example, like this works just as well, because

12:04  
if a is being declared as an array,

12:09  
it is formulas, there's a pointer, so it points to an address. And you can you can look at the offset five, and the reference there gives you exactly the same thing as eight.

12:23  
Okay, and then what were the statements in this language, any expression was a statement, you're allowed to return from functions, if then else is a statement, while is a statement. And then we could form blocks.

12:40  
The blocks were all lists of statements of declarations. Normally, you first put the bunch of declarations like you say,

12:48  
I don't know, x is an integer, P is a pointer to an integer is an array. And then the whole sequence of statements, we saw examples of those that don't, yes, the declaration looks something like give a type Give a name, and declared the declaration brings the name into a scope and you treat it as a new entity. And this is the intended type that is not really checked here.

13:17  
Yeah, and another form of a statement, or a declaration is just an ordinary statement.

13:22  
And then finally, a complete programme was what

13:29  
this is here, the programme just is a list of top level declarations and you can declare two kinds of things on the top level, you can define a whole bunch of global variables. So these are these guys. And then in C you're also allowed to have top level functions. So a bunch of function declarations basically, you're introducing a whole bunch of names you say what the parameters are, these are your functions. You say what the type of the function is, if it is none, it means it's a void function. If you have a bunch of parameters, these have types

14:03  
there is a whole list of them and then there is a statement which is the functions body. So this is the abstract syntax, but really write something like this

14:14  
you're interested using a function of type T these are the formula parameters x one through XM are with types T one through the end and the body is just taken

14:26  
okay. And among them you expect there is something called main

14:31  
which has type void and that is normally and that is the function that you want to run. And then we looked at examples of those and I showed how this complicated game with ampersand for looking up an address of a thing or star which means you know, indirect other station dereference a pointer how these work.

14:56  
Today we are going to look into a machine

15:01  
Which is described in chapter eight, and illustrates how this type of languages are combined to a stack machine, rather than interpreted. And then

15:13  
running the stack machine

15:16  
is,

15:18  
if you do it well is far more efficient than just interpreting,

15:23  
especially if you also apply optimizations to the code.

15:29  
But even so,

15:34  
okay, so we will look at their little abstract machine that has a whole lot of commands, and I'll comment what those are.

15:42  
But they'll first tell you what this abstract machine works on.

15:48  
And it's the following thing.

15:53  
So this paragraph here is important. This is what the abstract machine works with.

16:00  
So already, when we looked at the expression language at the beginning of the course, we had a very simple machine. Now this one is going to be more complicated. That only worked with two things. It, it had a sequence of instructions, which were the instructions to execute, there was no notion of jumping in the code. So you basically consumed the instructions, one by one, the instruction sequence for the list. And the machine works by sort of executing instructions, one by one never going back. Here, we also have a list or an array of instructions, which is the programme is actually implemented really as an array of instructions, you can index into the array of instructions, I can ask what is my fifth instruction, or what is my seventh instruction just by re indexing

16:54  
in implementation,

17:00  
then,

17:02  
when you run your piece of code, then you're somewhere in the middle of the instructions. The idea is,

17:11  
a piece of code is a sequence of instructions, you start, of course with the first and you work your way down the list of or the array of instructions. But then there are a jump or go to commands in this list of instructions. So you actually have to keep track of where you are in this instruction is not the case that you just consume the instructions one by one, you can you can throw away the instructions, you voted the execute, it is no longer the case is here, you may need to jump back. So what we have is an array of instructions.

17:40  
And then we have

17:43  
an index a definite index into the array that we call the programme counter. This says where I am currently in my programme, PC is the name for it. There's a very standard sort of mnemonic PC for programme counter. And it says, which is the next instruction that I'm going to execute. Normally, when you run the programme, you just increment the PC by one or two, depending on if the instructions are one or two words. But if

18:14  
you jump, then of course, the next instruction can be anywhere in the array of instructions specified by the jump instruction.

18:23  
Then, what else do we have, like we had with this very simple naive

18:29  
stack machine before we have this stack itself, so to say.

18:36  
So you could implement it as a list. Here, it's implemented as an array.

18:43  
And you should really understand it as a tower of integers. So these are the sort of intermediate values that you work with, they are kept on the stack. Here also it will be addresses.

18:57  
But the whole thing is implemented via an array, I'll show you on the picture how. So actually, you should think that your stack is also an array.

19:07  
The stack bottom is at the very beginning of the array at position zero.

19:13  
And when you grow the stack, it means that more and more of the array is actually in use.

19:20  
You want to know where the top of the stack is. And for that you actually needed again, a designate index into the array that you call the stack pointer SP for stack pointer that points to the top of the stack.

19:36  
So if you actually pop something, or sorry, push something onto the stack.

19:43  
Then SP is incremented. And

19:50  
and

19:52  
you actually put the value at what was currently SP

19:57  
so SP always points to nothing.

20:00  
strictly to the top of the stack, but sort of to the element.

20:07  
Further up, I mean unused, or for the purpose of current computation, unused position in the array, I'll show you on the picture.

20:17  
And then there is a final element that is also important. That is called a base pointer.

20:23  
The idea is your stack will really not be sort of flat.

20:29  
But it consists of fragments that are called frames or records activation records.

20:37  
And the base pointer, then doesn't point to the top of the stack. But it's related to,

20:46  
to the place where the current current frame starts. And but but it's, but it's a bit more specific events. So so I'll really need to show you

20:55  
want a picture. But that's then the idea. And then the whole point is to translate your programme, written in micro C, into a programme for the state machine. So think like this, which is an array of instructions. So really, it could look something like this perhaps in the end.

21:15  
But that's not the level on which we want to work with this. So here first, actually, we produce a list of,

21:23  
of sort of

21:25  
human readable machine code, which maybe looks something like this.

21:33  
So this is a very

21:37  
basic

21:42  
piece of code, which says load the top level arguments, print

21:48  
what's on the top of the stack.

21:52  
One, ad go to one. So you keep printing an incrementing.

21:59  
And I'll, I'll illustrate this in quite some detail. But but that's sort of one the level of the idea, you should think we're producing lists like these from micro C code, this is the compiled code. And eventually, it actually just turns into a an array of numbers.

22:23  
Now, let me illustrate the bit. This sort of stack structure that we work with here.

22:35  
This is an important picture.

22:53  
So in general, when you compute with a stack, when the when the stack machine computes with the stack, the stack has no it's not a flat thing, it is represented as a flat thing, it is an array. But in this arrays, actually, you should think of it as consisting of chunks.

23:15  
So different things are stored in the stack. And let's think what they should be.

23:22  
So here, there are two pictures that are sort of useful to keep in mind this is like like a general scheme of how things might be. This is what might happen when you run a programme, or that programme written in micro c computing the factorial of a given number.

23:43  
So

23:46  
what does the compiled code do? It first

23:51  
pushes

23:52  
onto the stack your global variables?

23:56  
Why does it be pointing in the wrong place? That's very bad. Okay, I'll just use this, it pushes onto the stack your global variables, there will be a section of those, and then the rest of the very sorry, then the rest of the stack is always consists of frames. So there is a bunch of frames on the stack already. And then there is the current one that we're working with.

24:20  
And What's the idea? The idea is for example, that if you work with factorial, this is a recursive function. So, your main programme may be called factorial, but factorial calls itself.

24:36  
The

24:38  
recursive call also calls itself that one calls itself

24:43  
and there are then associated parameter values that are passed into the function plus local variables of the function corresponding to the function calls that need to be stored somewhere and these will be in

25:00  
These frames. So, the idea is when you call the factorial function,

25:08  
you will see this bit on the on the stack, which is corresponds to the,

25:15  
to the first frame, we are making a call to main domain.

25:22  
Yeah,

25:24  
with a certain address, sorry, with a certain command line argument I wanted to say here three.

25:33  
And,

25:35  
but, but then in main we have called factorial.

25:41  
And actually, when we call main with three factorial of three will be called,

25:48  
then what happens is, you will have to have a place in your stack where the actual argument is, so this is this end here, which is three, there will be a place where the result will go.

26:01  
And there is also a variable temp, which is a local

26:06  
local variable in the function. Imagine there could be many local variables of course, there could be multiple parameters as well here there are two

26:14  
and then maybe this one called factorial again, and maybe this call is made with with the

26:21  
with

26:23  
the arguments with the actual parameter two. So, these things all end up on a stack as well. So here are two, for example, you could see, and then maybe one then maybe zero.

26:36  
Now, how is the bookkeeping arranged between those I mean, why doesn't everything get mixed up completely arbitrarily, because things are organised

26:48  
in frames.

26:50  
And these are these sections here. So, corresponding to every function

26:57  
of your programme currently being called, we are in the middle of a whole lot of calls. So, here, at this point, when the stack looks like this, we're in the middle of altogether five calls the top level call

27:11  
the first call to fak, and then all the recursive calls.

27:15  
And then you have this picture

27:19  
that

27:22  
the boundaries between these frames are organised via what are called base pointers. So, in every frame there, apart from the

27:36  
parameter,

27:39  
I mean, apart from space for parameters and local variables, very specific addresses, one is for what is called here the old base pointer. So, this will always be a pointer, not to the very beginning, but sort of to the beginning plus two of the previous frame. So, for example, look here OBP is 16, this 16 is actually this place here. So we referring to the place

28:08  
in the previous frame, that corresponds to the first argument, and then all of the locals. And similarly here, just to the left with one position to the left, there is no a yet older base pointer, which corresponds sort of to the beginning of this frame, except it's not the beginning, but it's kind of beginning plus two again. So it's it says,

28:31  
so here, old base pointer says 11, so we're pointing to this place. Yeah. Which is corresponds to here the,

28:42  
the parameter, the first parameter of the factorial function that's similarly here. So the old base pointer is six points to this place, which is sort of the beginning plus two of this frame. And similarly here, the old base pointer, the one to the left is to point to this place, this is how things are organised.

29:02  
In terms of you know, where are the data of all the calls in the middle of which we are stored, they are all stored on stack here, we do not have any heap allocation, we'll get to this next week. For the moment, it's as simple as this.

29:17  
Now, there is something more here there are also all these positions called the red either that the even further to the left or toward the bottom, the bottom is here, the top is that the bottom is on the left here. The top is on the right here. There are these things called return address. What's this about?

29:35  
There are two kinds of jumps if you wish, in.

29:40  
In stack machine code, as you will see, there are jumps to a specific position in the

29:50  
stack machine code. They're like go to instructions, if you wish go to a certain

29:56  
label in the code, but then there are

30:00  
function calls.

30:02  
And the function can be called from many places. And the idea of a function call is, of course, when you're done with a function, you should return to from where the function was called.

30:14  
And this place is always different. I mean, assumption doesn't know for what it was called, unless this information is somehow passed

30:25  
around, so to say, or if it's passed to the function.

30:29  
And this is what these read addresses here are.

30:35  
So four apparently is the address to which we must return after we finished with me with a with a

30:44  
with a function main, which is the main function. And it's probably an address where we have the whole instruction or so in the code.

30:54  
But then there are

30:57  
all these other return addresses. So where does fac return, so that the first call to fact the main call to fact returns to address 1919 must be a place in the code for factorial, which corresponds to the next instruction after the call of the factorial. So we imagine main is some programme, somebody has a call to factorial and

31:26  
with return address corresponds to the position in that code just immediately after the call.

31:33  
So this much for the first call of factorial.

31:37  
What about all the other calls, while the other calls, they don't return to main their recursive calls, they return back to factorial

31:45  
when the factorial function has exactly one call back, and they must return to the line

31:52  
or to the instruction, if you wish, next after the call, and that would here be for example 79. So

32:01  
yeah.

32:04  
So the whole programme consists of the definition of Global's which here are none.

32:10  
And then

32:12  
I mean, global variables, but then there are the global functions which are main, in fact, and they are somehow laid out in the in the in the compiled code.

32:24  
And then these are the important addresses, they're in the compiled code for 19 and 17. So something like this is what it could be

32:34  
based much on the pictures, but now we have to talk a bit about what the stack machine code is like, or what are the instructions there, so that we can then make sense of, for example, what these programmes could mean when they are compiled.

32:53  
Okay.

32:56  
I want to show you a big table from the book, which I didn't want to copy myself.

33:06  
Yes.

33:08  
Okay. So in the first column here, it's more or less, I think it's the full instruction language actually, of this machine. So, these are all the different possible things that the machine can or instructions that the machine can handle at all.

33:31  
And they are here written in this mnemonic code, I mean instructions that we could read as humans, really they get translated to just bytes numbers,

33:42  
which are actually these numbers. So,

33:45  
for numerical

33:47  
for a numeral we actually get the instructions zero add this called one sub is called to stop is coded as 25

33:56  
as simple as this, and these are arbitrary numbers, if you get some some actual processor instruction set, these could of course be different.

34:06  
But then just to just to illustrate how working with a stack works

34:12  
with more or less seen this part

34:16  
from instructions, zero to 10, because these are very

34:20  
weird things very bad here. These are very similar to what we had in the

34:26  
in the stack machine for expressions.

34:29  
That the more interesting things are those ones that we will see here below

34:36  
which have to do with more complicated that their session mechanism but also control like jumping to a definite address or maybe making calls to functions and returning then from functions, etc.

34:51  
Okay, so let's think.

34:55  
So what is the notation here? So this is actually a very good summary table.

35:00  
What is happening? And then we can think whether it makes sense or how we could combine anything at all?

35:11  
Yes, these bits maybe don't require so much explanation. But anyway, they are given in the table. Also in words, what are the middle columns here, they are kind of, sort of on the fingers explanation of what happens if you execute such an instruction. So from a stack before, after executing your particular instruction, we get to a stack after. And the stack is written here,

35:35  
sort of as a sequence of things, you should think of it as a list. But as a list where the head is not on the left, but on the right, it's written in the same way as on the picture. So the things that the furthest to the right are the topmost things. And sec, like a meta variable for any any stack, so a whole bunch of numbers.

35:56  
When I, when you see things like si One, two, it means we've got a whole bunch of numbers on the stack. And then we've got a one and then on top of that we've got it and I took is it within the top notes thing in the stack.

36:10  
That's the way that you should read. So let's see if we can then make sense of the table. The top part should not contain much surprises, but interesting things should have been here in the lower part.

36:21  
So if you want to push a constant I then you're given a stack.

36:27  
And the new stack state is just the same except you've added one number on the very top, which is the given number I

36:36  
when you want to add two numbers,

36:39  
here with a stack machine, then you expect that the given numbers already on the top of the stack, I want it when they just add them and push the result back on the stack. So you've consumed two numbers, and you produce one new number, pop two numbers, push one number. And the same for every operation.

36:58  
Remember, we didn't have Booleans here, so Boolean are coded as integers. So any nonzero integer is concepts true, zero causes false.

37:12  
So all these are then clear, then there are some special ones hope for some reason is not here.

37:20  
So if you've got

37:24  
a stack as well, V on top, then you can vacate, which just means that the top

37:31  
is copied one more time on the top swap

37:37  
swaps around two topmost elements of the stack keeps the rest of the say.

37:43  
And now comes the interesting bits.

37:50  
The first one is load indirect.

37:54  
And

37:56  
the idea here is on the top of the stack, you've got an integer which this time you don't think of as the data value, but you think of it

38:05  
as an address into the very same stack.

38:10  
So for example, if I zero then you take the bottom most that corresponds to the bottommost element, the bottom element of the stack. And then what you do is you you pop this pop pop this value off from the top of the stack,

38:26  
and you replace it with the value that you have in the stack in this given position.

38:31  
So it's a combination, if you wish, of popping away this I

38:37  
and then kind of a deep duplication, because the value we after is already somewhere in the stack. We keep that copy there. But we we also pull it out and put it on top of the stack.

38:54  
Maybe I should illustrate it. What is my machine fine anyway.

39:07  
So here is the explanation of the machine. But maybe I can right here in the top. So you could imagine that, for example, I don't know if you do

39:16  
know the indirect and your stack looks like maybe 356 17 and two,

39:25  
then the point is,

39:28  
this is the given stack three at the bottom two at the top, and two here is an address into the very same stack. And these things are numbered zero was first second. So we're actually interested in in this element here number six. So in one step, then this transforms into

39:49  
this because six was in the second position and we kicked out this tool.

39:55  
So that's called load indirect because I'm not loading from the heap or from some different store

40:00  
But I'm loading from the same stack.

40:04  
And indirect because I'm given the address, right?

40:12  
There is a similar thing called store in direct. Haha. So this one, use these two elements on the top of the stack, the top thing you think of as a data value, although everything is integers here, this is just, you know, the tuition. And the next guy you think of as an address into the stack.

40:33  
And then what you do, you basically update the stack, such that at the if position, you put V,

40:40  
and then you return this thing.

40:42  
So the value is still on the top of the stack. It's not

40:47  
sort of completely popped off. But you've, you've thrown away this address from here.

40:54  
Yep.

40:59  
Now, every now and then you want to go back somewhere in the stack, but they don't know exactly where. So then you have to have these instructions called get BP and get SB.

41:10  
So these things, what do they do, they just take

41:15  
the base pointer of the old base pointer about the current base pointer, and they put them on top of the stack. So this is something that you need in a function call, when you create the new frame, and your current base pointer will be an old base pointer.

41:31  
Similarly, it's important to be able to load sometimes

41:37  
the stack pointer itself on top of the stack. So just to remember how high the stack was, at some point in computation, that's really what it does.

41:54  
Then there are these things called

41:58  
Oh, then is this thing sorry, called increment stack pointer.

42:06  
And where M is a given numeral integer

42:11  
can be positive or negative, and therefore there are two cases here.

42:15  
So corresponding to a non negative m, we grow stack or actually, if m is zero, nothing happens. And corresponding to negative m is shrink stack, what happens here,

42:26  
shrink stack is maybe kind of a natural thing. And actually shrinking by one is exactly pop, which was not explicitly here.

42:35  
So the idea is, you're given this stack that has a key m elements

42:43  
on top of the stack,

42:49  
and then these are kicked out.

42:52  
So you're popping MLM ants at once.

42:59  
Really, in the implementation, it means you don't do anything, I mean, your your your stack is in array, all you do is you actually literally, in this case, increment the stack pointer by a negative number, which really means decrement it. So just move the stack pointer to the left, which means these old values are even there, but they become garbage in the array in the sense that they are not thought of as part of the stack. But they're still there. Nobody bothers to write them with anything specific.

43:33  
Ink CSP is something that looks like a bit bogus. Because what are we doing? So, there is and there is a purpose for it as we will see that but for now. So we were given a stack, which really means there is this array corresponding to the stack, and that is a pointer to a place and then we move the pointer to the right, the stack pointer, thereby all of a sudden n new elements appear in the stack. And they are alleged to care they are just complete garbage. They are Whatever happened to be in the array in the array to the right of the stack pointer.

44:11  
But of course, if you've set up things properly, then you know what is there? I mean, it's not like random garbage.

44:19  
Okay, done with this. Is this

44:23  
reasonable? If there are questions, please do shout because I don't need to see this chat or I don't see your faces now. But that's maybe a place that is really complicated. These these from 11 to 15. The rest are

44:38  
in part, again, easier, at least 16 to 18.

44:49  
Okay, let me continue with this and then we can take a short break and then I'll show you more. So

44:58  
some more instructions.

45:00  
There are the jump instructions, they are either to a definite address or then they are related to functions, which means calling, which just means going to someplace in the code, but then you have to remember where you want to come back because the function itself knows nothing about it.

45:15  
And then the last ones are really simple. Okay?

45:19  
Go to a has to be a specific number, that here corresponds to a position in the code in the, you know, in the sequence of instructions.

45:30  
So, for example, when I say go to zero, it really means I'm going to the zeroeth instruction, remember, my piece of code is is an array of instructions literally Indian.

45:40  
So jumping really means that my PC, my programme counter is changes, but the in terms of the stack, nothing changes. So from the stack, I go to a new stack, but the PC

45:53  
differently from the usual situation here, which is that it typically increments by one, if there is an additional argument, this has to be somewhere in the instructions like this MRI here, then you it goes up by two here.

46:08  
I don't go to

46:10  
to the next instruction, which actually only stores the instruction position where I need to go.

46:17  
But we really go to the beginning of

46:21  
sorry, to the appropriate position in the, in the piece of code.

46:27  
If 01 if, if n zero are similar to go to accept, these are conditional jumps. So what happens is very some data value on top of the stack, and you just check if it's zero, or maybe if it's not zero.

46:43  
And if the instruction is if zero and the value is zero, then you do jump to position a

46:53  
among instructions, which means that the programme counter is

46:59  
is set to a for the next instruction. If the condition is not true, then the programme counter is simply here incremented by two

47:08  
to go to the next instruction, you'll see this in detail as well.

47:13  
If not zero is very similar then call and read and tail call we will ignore Until

47:22  
next week, I think

47:26  
call is a bit similar to go to but there is things to be done

47:41  
at a place when a function is called the idea is that the arguments have already been computed. I mean, this is how compilation is done.

47:50  
And if the

47:54  
n m here means that the function has m arguments actually.

48:00  
So at this place,

48:02  
you expect that there are n data values already prepared at the top of the stack, which are the values of the arguments they are readily available, they're

48:12  
a means that

48:18  
the function itself it's code in the compiled code,

48:24  
which is an array of instructions is in position a. So the function is at location A in the code.

48:32  
So what do we need to do then?

48:37  
Well, it's like a jump instruction. So, we really need to keep the arguments on top of the stack, there is no question about it, but we actually need to create

48:48  
a frame now

48:53  
because we will enter a new function.

48:56  
So then what we need to do

49:00  
what is currently the base pointer that knows who called us

49:08  
becomes an old base pointer for the function to know who called the function. So, we need to put the base pointer also in the stack.

49:17  
And then also we need to put the return address which is actually calculated in the course of the compilation

49:28  
into the stack. So, this is this art here

49:33  
are here should actually be what are should be

49:38  
the position of this instruction itself

49:43  
plus three,

49:45  
because if call is at some position in the code and m is in the next one is in the next one. So call itself has two arguments which altogether consumes three words. But then after that is the others are two code

50:00  
And that is the place where we should jump back after calling.

50:08  
So call really handles, maybe I should show the picture, again, handles handles this mechanism here. So we are, we are making a new call, this means.

50:20  
So maybe from here, we're making a new call to fac we currently have

50:30  
you know, the current base pointer, and we also know what is the next instruction or really strictly speaking next plus three. So, we put this the new instruction at risk here, we put the current PP here it becomes an old BP

50:46  
then we create place for the parameters. And a new BP is also produced. So after leaving propriate place for the local variables, and you'll see this in the compilation function how this works exactly.

51:02  
So, but but calling a function creates in your frame, now, when you return a function, then you're basically prepared the result from the function

51:15  
and the rest of the frame is is already used as you throw it away the only piece of info meishan that you need to know from there is

51:26  
is the is the return address

51:31  
and then the continued control continues from there. So I can also show this here. So, return

51:41  
what is that here

51:43  
rep M.

51:48  
Let us see.

51:52  
So, we are we are coming back from a function

51:59  
at this point, coming back from a function call. So we are in the middle of a function call, we are executing direct instruction. At this place, the stack should look like this. Since the return

52:15  
command in in micro C, it uses an expression as an argument, when you compile an expression, it produces a value on the top of the stack. So this really here in the given stack on the top is the function we want sorry, is the value that we want to return from the function. So that's an important piece to keep. What is the rest here in the stack state? Well, this is stack before we entered the call, or is the return address that's important. So this is where we should go after the call B is the

52:52  
old base pointer, so to say, which is sort of the next free thing.

52:59  
Or so it points to position after the top of the stack.

53:05  
The next three address so to say,

53:08  
and these buddies was the old base pointer here.

53:12  
And then there are the values of the the arguments with which the function call worked.

53:19  
So this is called by value, it was literally the the values that were passed

53:25  
or the adversities to them, if we had passed references,

53:31  
I mean, if we, if the types of

53:36  
parameters of the or the parameters of the function were

53:42  
were pointers.

53:45  
So all of this gets kicked out, we only keep this part of the stack. So all previous frames, plus the value produced, which is the only interesting thing that we want to know from the current column a function that we're finishing. But of course, there are other important things to do. So how do I use the return address, so after read control doesn't go to the next or the one after the next address because you know after read the results of this m which is a word, but actually control goes through our so the current PC now becomes our

54:19  
and then the new base pointer is

54:25  
B

54:28  
which is actually what so just just look what B is here. So b is the position right after the return address, the return address itself is replaced with V.

54:42  
So the BB points to sort of position that the next element would occupy if I was to push a further element on top of the stack and that's exactly the good value for for the current base pointer. Yeah.

54:58  
So the base point there always should point

55:00  
To the address in the array that corresponds to the position,

55:03  
you know, one up from the top of the stack.

55:06  
That's good.

55:09  
And then there is very little as to say, we've got, we've got an instruction for printing an integer, for printing a character, these assume that the value is already prepared on top of the stack, and that one is printed, either. So the integer is printed either as an integer or converted to a character and printed, the value is kept on top of the stack, there is a command lit arcs

55:33  
that gets the arguments for the function main from the command line. So these are the arguments for actually made.

55:46  
And then those are just put them on top of the stack. And then finally stop is it's just an instruction that signals the machine to stop.

55:57  
So whatever state stuck state you finish, then you can then discard because

56:04  
you fulfilled your mission unless Maine returns.

56:09  
Okay, so this is a big picture. And I've now spent quite a bit of time explaining this

56:18  
will now

56:20  
in the second half, discuss a bit of how you should, how you should organise compilation, what's your compilation amount, two, first four expressions, then four statements.

56:33  
And then a bit about the overall structure of the compiler. But the important bit is to to understand what these instructions are supposed to do. And then we can also play with with with examples

56:49  
about them.

56:52  
Okay,

57:09  
for sharing

57:14  
any questions about

57:16  
this part? Or

57:22  
not?

57:28  
If there are questions, please do jump. Otherwise, I would

57:33  
suggest the break

57:36  
maybe on 1017 to

57:40  
25. And then we can go for another half an hour. And I'll explain how this machine is supposed to

57:51  
work. Not so much how it's supposed to work, but how we're supposed to produce code for this machine from Microsoft and then later we'll see how also this machine interprets and we get the full cycle. So we instead of interpreting micro C we can compile to micro C and then interpreter. Sorry, instead of interpreting micro C, we can compile micro C to machine code and then run the machine rather.

58:23  
Okay, if there are no questions, then I'll suggest we just meet in

58:28  
intelligence in eight minutes. So 1525

1:06:49  
Okay, let's, let's continue.

1:06:52  
So I'll show you the machine. And I'll show you a bit of compilation. And we'll have to continue on Thursday looking at sort of deeper issues and also a whole bunch of examples because it's complicated thing. And it also illustrates a number of things at once that are sort of difficult to disentangle. But it's, it's inherent to the,

1:07:15  
the problem or to the situation.

1:07:19  
Let me share again.

1:07:32  
Okay.

1:07:34  
So first thing to explain that there is two ways

1:07:38  
in which I can talk about the machine code, right? So, so one is this a human readable mnemonic version, where you actually talk about

1:07:49  
jumping to a particular label.

1:07:53  
So what you can do is, is the following, so we can have a type of instructions. And the instructions are always things that you saw in the table, like all of those, but there is also like a pseudo instruction called label that actually takes one argument label, which is just a string.

1:08:14  
So this is for us to be able to jump not to some specific,

1:08:20  
you know, positioning an array, which is,

1:08:25  
which is the final list of instructions, but we could sort of manually indicate, you know, put cookies,

1:08:33  
somewhere in the code, these are the places that we want to jump to and give them names. And then later, we can get rid of these names. That is sort of the reasonable way to go about compilation, because if in compilation, you have to know ahead of time, at which place

1:08:50  
something will be in the final code in terms of an absolute address. This is kind of complicated, and also unnecessary. So we could agree that the instructions are these ones, like the real instructions, some of them take arguments, like Inc, SP x or Inc, SP Inc, stack pointer takes one integer argument, we saw others that take more

1:09:13  
like cold pigs to one for the number of arguments of the function and one for the return address,

1:09:21  
which is here formalised as a label.

1:09:24  
So these are all there. And then you could say that the piece of code is a list of these things.

1:09:33  
But an actual piece of code is really given in terms of of numbers only. And then we could say, okay, we code up all our instructions as numbers between zero and 25, like in this table.

1:09:48  
And then when I want to see some code

1:09:51  
as actually a sequence of numbers, then I need to get rid of these labels and replace them with actual

1:09:59  
positions.

1:10:00  
In the code, so let me let me illustrate this.

1:10:09  
So really, we want to convert a list of instructions into an array into an array.

1:10:18  
And the way that we do it is

1:10:23  
we,

1:10:25  
we produce what we hear call a label environment. So

1:10:32  
we remember which label was actually in which address

1:10:37  
in the instruction code. And then it works like this. So when you go through your, so this here is is like

1:10:47  
taking your machine code in this mnemonic form and change it into a byte code. So that is to say an array of numbers, it goes into policies. In the first one, we remember, for every label and integer address in this final version of the machine code, which is the bytecode.

1:11:09  
And we just do it by going through the list of instructions, and remembering at which address everything Finally, will be.

1:11:20  
So it's done like this.

1:11:23  
So we use this,

1:11:26  
this helper function make label and that fundamentally takes an instruction. And it also works with an accumulator. It knows which is the next free address. So an an instruction address to which we haven't yet associated an instruction, and then an environment of labels, so it knows which labels were mapped to which instruction addresses. And then it's used for walking through a list of instructions. And this function only deals with a single instruction is a helper function. And the global function will then take a whole list of instructions and use this helper in a big recursion.

1:12:08  
So when you go through a label instruction, this is a pewter instruction, it won't show up in the final pipe code. So we we don't change the accumulator for the next three instruction address. But we remember that the label is going to correspond to the next three instruction address.

1:12:30  
So we we we extend the label environment by this pair of label lab.

1:12:37  
And the current next three instruction address that for every other instruction that we go through, we just assign an instruction address. We don't modify the environment of labels at all, but we have to remember which is the next three instruction address and this depends on the nature of the instruction. So, if the instruction doesn't take any arguments, the next instruction goes into the next

1:13:05  
word or bytes in the bytecode.

1:13:07  
But if something takes an argument, the argument is the next word. So therefore, the next instruction is not that as your plus one is after plus two.

1:13:17  
Similarly, if something takes two arguments like call

1:13:21  
then at the next address goes the first argument then at yet the next one goes the next argument and the next instruction goes under the last three

1:13:31  
and that is all this function does. So,

1:13:35  
we we walk through a given list of instructions,

1:13:41  
we have a in a list of instructions and we tell kind of fix an absolute position which this instruction is going to take in the in the bicycle.

1:13:55  
Now here what is the actual

1:14:03  
actual bytecode emission?

1:14:09  
Let's jump over one function here.

1:14:17  
Okay, let's look at the

1:14:22  
sort of complete code here. So what comes in is a list of instructions. So, this is the minimalistic instructions and what what comes out is a bytecode is a list of integers the finally we will actually see as an array.

1:14:37  
And in the first pass, what we do is this very same helper, make label environment is called in on the given code

1:14:48  
and what he produces

1:14:57  
is

1:15:02  
is a label environment plus the next free label.

1:15:08  
So we go through the code and that every instruction is done by phone at every instruction, we, we apply one of these steps above here.

1:15:17  
And the base case is we start with the next three labels zero.

1:15:23  
And the the, the the label environment initially is empty. So we start with the next

1:15:31  
free labels zero, and the label environment empty and we gradually add stuff there based on this code above. In the end, we don't care which is the next final free label because we don't have any further labels. But we're interested in the final lab environment

1:15:48  
and then with another fold, we basically emit the byte code. So, this is now done with fallback.

1:16:00  
So, we use the original code again,

1:16:03  
we use the empty list as a seed value for this list of instructions that we produce.

1:16:13  
And

1:16:15  
the the function that we apply at every step of this fallback is this emit events that really use these get lab for

1:16:26  
looking up addresses at labels. So, basically, we go through

1:16:35  
our code

1:16:39  
all of the code has been remembered in some label environment,

1:16:44  
which is this lab end of here and all we need to do at this stage is basically

1:16:50  
replace them pneumonic

1:16:54  
addresses with with numeric addresses, so cspi for example, will get replaced by zero and then the argument and then these ins are

1:17:09  
are the given

1:17:12  
accumulator here

1:17:14  
and similarly for all other instructions, so, so, here for example, the ones that have two arguments, so call gets replaced by the code for call, which is 19

1:17:25  
and then the three arguments

1:17:27  
and then again, the list. So, this is how I mean, it is used by this list for back. So this may be written a tiny bit too, too, too concise to be sort of

1:17:40  
immediately graspable. So maybe I should rewrite it in smaller steps, but But anyway, this is what that or what happens. So do these two policies First you go over the code and you produce this

1:17:53  
label environment.

1:17:56  
And then in the second phase,

1:17:59  
you go on one hand over your label environment,

1:18:03  
which to get ins can do, but on the other hand, you go over your code, right, you extract instructions from there, and based on the get lab information, you can

1:18:15  
make the correct integers okay.

1:18:21  
So given given machine code, we can in mnemonic form, we can go to the real machine code, which is which is bytecode. But now about compilation itself, there is a difference. So, this was the file machine Fs, that introduces the machine instructions syntax introduces the code corresponding to these

1:18:42  
mnemonic instructions. And it has this function for going from a list of mnemonic instructions to, to to bytecode or, you know the actual code.

1:18:55  
There is a different find comp Fs that I attached to the scope,

1:19:01  
which is the actual compiler.

1:19:04  
It takes in

1:19:07  
a piece of micro C code. So, on the top level, it's the top level programme consisting of statements or declarations and then is able to handle both these top level statements and declarations and all the little things statements, expressions, etc.

1:19:23  
I can only do a little bit today and then I'll continue with examples and more

1:19:30  
on Thursday,

1:19:32  
let's deal with expressions and statements because they are the relatively easier

1:19:40  
cases.

1:19:43  
And they are also similar to what we saw before and then I can revisit and then we can read the rate and think again.

1:19:56  
Then we can revisit and and look at

1:20:00  
These things also an action on smaller pieces of code when we have everything ready.

1:20:06  
So what is this?

1:20:10  
So there is a whole bunch of simultaneously defined functions called things like c x square, C statement, C statement of declaration siac, for compiling expressions statements accessors, in particular.

1:20:25  
And then the more top level things, but all of them fundamentally try to do a similar thing. They try to take a micro c construct, so, in the case of expression is an expression and turn it into a list of instructions in this men monic form.

1:20:44  
And they follow a certain code of conduct, so to say, for a certain protocol. So, what do you expect, for example, from an expression is that whatever this instruction sequence that is produced has its task, take whatever stack is given and produce the expressions value as the new added top element on the stack.

1:21:11  
So, when the original piece of code is an expression and if interpreted, it gives you a value in the correct variable environment and function environment.

1:21:22  
With the compiled code does, it emits a piece of code, which if you were to run it, if you were to run it on this abstract machine, then whatever stack is given as the spec To start with, it does some work.

1:21:39  
And it leaves this stack untouched. I mean, it can consult it, but it doesn't destroy it in any way. But it adds to the top of the stack one extra elements, which is the value of the expression.

1:21:54  
This is done by this piece of code here that I can go through

1:21:59  
with you to the screen.

1:22:01  
And the easier parts are things like numerals and operations and and also the hardware parts are things like accesses address, which is the ampersand thing. And the assignments were actually something important or new happens compared to the little expression language that we already saw. So here are the things that maybe don't surprise you.

1:22:24  
So what is what is compiled code corresponding to an expression which is just the numeral?

1:22:30  
Well, my task is to write a piece of code that

1:22:35  
given the stack

1:22:38  
is able to

1:22:41  
do it so that the value of this expression appears on the top of the stack and the rest of the stack is unchanged. Well, what is this piece of code? Well, it suffices to just load the particular numeral on the stack and this is like a primitive instruction here. So the whole sequence of instructions that we get is just a singleton list low this numeral nothing else. And that is because it was a particularly simple

1:23:09  
instruction. Now unary and binary operations they are similar, like if you are to

1:23:19  
combine

1:23:21  
into machine code, this expression, a unary operation applied to an operand sorry,

1:23:30  
a unary operation applied to an operand D one

1:23:34  
then what happens we allow unary operations in this language are only indication printing an integer or printing a character.

1:23:42  
And the compilation scheme is the same. So you produce your code will be the following. So first, you need to produce the code by recursive call to the very same function c expert in the middle of which we are,

1:23:55  
that will actually translate each one into a piece of code that puts the value of each one on the top of the stack.

1:24:04  
And then, to this code, we have to append a further bit of code, which now depends on the operation.

1:24:13  
So if the operation is negation,

1:24:16  
then all I need to do is here's a piece of code, I just need to attend at its very end and not the instruction why because not is the perfect thing. I mean, given a value where we is on the top of the stack, I just got the negated value on the top of the stack. And the rest of the stack is not changed.

1:24:35  
Similar for print integer, a print character which are not supposed to remove the value from the stack, but just to print it. So I can just emit the corresponding command because that's the meaning of micro see print die, micro see print, it takes an expression, it prints the expressions value but it also returns the expressions very similar for print character,

1:24:57  
which is the same in all aspects except

1:25:00  
takes an integer, but it prints it out as if it were a character. Because here, on the level of pipes, we do have characters, but they are represented as integers. Everything internally is integers the moment that you need a character be converted back into work.

1:25:19  
And then absolutely the same happens with with binary operations. It's not complicated.

1:25:26  
So if I were to

1:25:32  
compile a piece of code, which is of this form, so some operation binary operation, and two operands, which are expressions, what do I need to do, I need to produce this piece of code. And it's very similar to what we had in the expression language, we had really, I mean, there's no difference,

1:25:53  
I first need to produce the code for the first expression, we know that this code when run will produce the value of the first instruction, or the value of the first expression on top of the stack.

1:26:06  
Then, we append to it the code

1:26:10  
for the second expression, the second operand. So when you run this piece of code, it takes whatever stack state and it adds the value of expression two on top of the stack. So now,

1:26:22  
this piece of code altogether is a piece of code that takes a stack and puts two values on top of the stack, the first value corresponding to the first expression, the second to the second expression.

1:26:36  
And then

1:26:39  
all of these

1:26:42  
operate operators here are implemented in terms of these

1:26:47  
machine code instructions. Some of them are not primitive for the machine, but we can implement them through a sequence of instructions like we've got here. EQ that compares for equality with we don't have negation of equality. But surely, you can just apply EQ, which takes the topmost element or, sorry, the two topmost elements of the stack, and returns a Boolean on the top of the stack, corresponding to whether the two things were equal. If you don't want equal, if you want not equal or unequal, you take this value from the top of the stack again, and you negate it. And this is the piece of code.

1:27:22  
So similarly, for example, for you can implement su less than, say, his private primitive here.

1:27:30  
Greater than isn't, but you can implement it in via swap, and less than or

1:27:39  
then there are other combinations, right?

1:27:47  
Okay. But now to the to the Okay, there were two more so. And also and orals are important.

1:27:57  
And also is important.

1:28:00  
And it's supposed to be

1:28:04  
lazy. So, if the first expression gives me two, I should already be happy with the result. And I shouldn't go and evaluate the second one. So we shouldn't do it by the same strategy. So the code here would be more complicated. So how do we do it?

1:28:21  
So we first generate two fresh labels,

1:28:26  
which are just some strings. The new label is a is a little function that whenever you call it gives you a new string.

1:28:35  
It uses a mutable, record the insider reference.

1:28:39  
Okay, then what should what should the code be that we generate the generated code is here.

1:28:47  
So what does it consist of?

1:28:49  
It says, Well, here's the code for each one, the first operand,

1:28:56  
which is a sequence of instructions, we don't know what it is recursion gives it to us. Then, after that, what we need to do? Well, we should check if the first

1:29:07  
argument is true or false.

1:29:13  
In particular, if it's false, false is represented with zeros, so we could say it is zero.

1:29:18  
Now the value of E one is on top of the stack, if it's zero. Let's pop it and let's go to the label lamp false. So this is here at the very end.

1:29:30  
If it's not false, we go to the next instructions which are here. And these are the ones that corresponds to evaluating the second

1:29:45  
operand the second argument.

1:29:50  
So this guy produces the value of the second argument the second conjunct on top of the stack. And if we're in the false case, then the value of the second argument decides the value of the whole conjunction

1:30:00  
Right, you agree. So the value of the whole conjunction here is just whatever value we produce here. So then it's good maybe to, to emit the instruction go to the label for the end,

1:30:11  
which we put here.

1:30:14  
But then in between, we put this label false, which we had generated. And then we say, okay, in case

1:30:26  
the first label was false,

1:30:29  
then we just return zero. Yeah, because we already have zero, but it was popped off the stack. But now we really want to return it, we have to load zero on the stack. Again, you can also write it differently with token swap. But we didn't do it here, or else is very similar.

1:30:46  
Now these are nice.

1:30:48  
I can do these, and I can do call. And then the rest we have to leave for Thursday.

1:30:58  
So what other things did we have,

1:31:04  
we had accesses any access counts as an expression. So for example, names and array indexing and pointer dereferences. But also any accessor when I put an ampersand in front of it also is a valid expression. assignments are valid expressions. And then finally, function calls are valid expressions. So these are the remaining cases, 234 accesses, I should tell you what the protocol about accesses so access is another see access is another function defined by mutual recursion here. And it is for compiling accesses to machine code.

1:31:44  
These compilation, things work exactly the same way as copulation of expressions, except it's not the data value of the expression, the right value that is returned on top of the stack. But it is

1:31:58  
an address, it's the left value of an accessor, that is returned on top of the stack. So So see, access produces you a piece of machine code that returns

1:32:13  
the address.

1:32:21  
Okay.

1:32:23  
If it if this is how CSS behaves, I can only promise now because I won't have time to show it today. then surely, ampersand act I mean, this, this clause here corresponds to this kind of syntax in in concrete syntax in Microsoft, Microsoft, right. So if we're just after the address, then the code produced by the for ACC, by C access is already the correct state machine code, there is nothing else to do.

1:32:50  
But if I don't actually mean the L value of address, if I mean the R value, or if I don't mean the L value of the accessor. Sorry, if I mean the R value,

1:33:07  
then the code is a bit different, I have to do the same as before As for other, so I have to compile the accessor as code for the left value of it, and B produces me, not the value, not the right value of the accessor. But the left value of the assessor, which is just an address for that value.

1:33:28  
But I don't want the address, I want the data value. So then to access that one, what I can use is my ldi. So ldi is the one that given an address is able to look up the value at that address in the stack.

1:33:43  
So we produce all this code, but the at the end, we put one extra injection, which is called ldi. And ldi does what it replaces I on the top of the stack with the action value that I

1:33:58  
as an address historie in the stack.

1:34:02  
Good. So when we understand that then assignment is not much more difficult. The sign takes two arguments accessor and an expression. So this is the concrete syntax, maybe I should just repeat again. So this is how it looks in in actual micro C and what was the idea? The idea was to on the level of interpretation, so what does an assignment mean?

1:34:27  
It means we have to find the value of the accessor the L value, which is some address, we have to find the R value of IE, an expression, which is some data value, and then we had to put the data value at that address. Okay, can we do this? Well, yes, because I can produce the following code and now see how things nicely line up. I produce the code corresponding to the accessor that only is the code for computing the L value for only computing the address.

1:35:00  
But not the value at that, at that address. So this thing by this code here is is produced on the top of the stack when you run this code. So after you run the CSS, you've got an address on top of the stack,

1:35:17  
then this code is appended together with the following piece of code, which is the compiled form on the right hand side of the assignment. So that one produces a data value and our value corresponding three on the top of the stack.

1:35:34  
So now I'm in a position where actually it would be a great idea to next just put the instruction STI for storing indirect because what the store in direct use, storing the direct takes a stack

1:35:48  
with lots of stuff, but on the top, I've got an instruction. And on top of that, I've got the data value, sorry, not an instruction and address. And on top of that, I've got a data value. And what storing direct does is it keeps the value on the top of the stack, which is exactly what we want. Because the sign itself is not only a statement, it's an expression, I mean, the value of it should not only be stored in it should also be returned to keeps me on the top of the stack. But now it goes deep inside the stack, and actually updates the stack. So that at position I in the stack, and position is the address that we produced here. Yeah, which one here

1:36:30  
is the correct value v. So this is exactly the right code for an assignment. And then finally, we have the function call.

1:36:41  
A function call is a specific thing.

1:36:44  
So function call is really further to a special function called fun, which produces code for the function. It needs the function name, it needs the parameter names, it needs the current

1:37:03  
local variable environment, and it needs the current function environment that they hadn't explained in detail what these are, I mean, they used all over the place here. They're just passed down in recursions. We never actually touched them properly yet.

1:37:20  
But maybe a more important thing is

1:37:24  
so call is implemented by call phone, and I can't explain it right now, this is complicated. But maybe I should explain the very first case of accessoire, because access is the one that produces code for accessors. And we just in all of these cases, we assumed that we knew what happened to accessor. So maybe we should at least maybe look at the very simplest case of the accessor, where the accessory is just the name, the name here can only be a local variable or a global variable.

1:38:01  
Okay.

1:38:03  
And what then happens is,

1:38:06  
the code corresponding to accessing a variable is done like this.

1:38:13  
So we look up x in the environment for variables, this one will know, in particular, whether the

1:38:24  
variable is a global variable at a certain address or a local variable at a certain address.

1:38:31  
And the second component is here, the next three others four variables, you don't need to care about that at this point. Now, if we need a global variable,

1:38:41  
then its address is obtained by

1:38:46  
putting this given address here at the top of the stack. So we just

1:38:54  
i is given to us from the environment, a compile time environment, we know what we were we allocated the global variable, it's somewhere towards the bottom of the stack, and we just load

1:39:07  
indirect from that address.

1:39:14  
Sorry, what did I say? We load from that address and we look we

1:39:20  
don't load that address, we just put that address on top of the stack.

1:39:25  
Load indirect comes when

1:39:29  
there was a

1:39:36  
load indirect comes when we actually want the right value. But if we just only want the address, we just put the address on top of the stack. That's what I wanted to say.

1:39:47  
If it's a local variable, it's more complicated because a local variable say we've got recursive functions like factorial. So the same variable name can come from, say multiple invocations

1:40:00  
The same function or of course, there can be, I can be in the middle of multiple function calls, and they all have their own parameters and local variables, then it goes differently. We actually know, in this particular case of a local variable, we know its relative address in any given frame for that particular function.

1:40:24  
And then what we need to do is we get the base pointer

1:40:39  
for which we have an instruction. And then we load the address corresponding to that variable. And then we add these together and we get the new address at the top of the stack, which is basically the absolute address made of

1:40:56  
the base pointer. And then the the sort of local offset within the frame added to the base pointer. And this gives us the absolute address that then we may interested in as such, if we're working with ampersand this accessor. Or if we don't have ampersand, if we have the, you know, the the real access, like, like maybe here,

1:41:18  
if we want the R value, then we then we then we can just load from that address. Okay, so this is sort of a peek into the,

1:41:28  
into the compilation thing here. I can't explain all functions. I'll explain a bit more next time. But I also want to show examples of compilation and example of what sort of what happens with with compiled code on small examples. Next time?

1:41:46  
How is this? Are there questions

1:41:53  
about this part?

1:42:07  
Okay, if there are none, there are none. So next time, I still continue in chapter eight, because it's,

1:42:14  
it is maybe the toughest of the chapters that we that we cover here.

1:42:20  
And we can't go deep into combination, but it's important to understand these ideas of like,

1:42:27  
you know, stack allocation of memory, and working with with these frames corresponding to different functions in which in the middle of which we are, you know, if you're inside a run of a programme execution of,

1:42:41  
of a high level programmer, also the compiled code, of course.

1:42:46  
And then this idea that you work with, on one hand, sort of absolute jumps, and then on the other hand, calls in low level, in which case you you have to remember the return address, which then becomes part of information on the free.

1:43:08  
Okay, so and then, in the last lectures, the last two, we'll also look at

1:43:14  
heap allocation and, and automatic, sorry, yeah, automatic and manual memory management.

1:43:25  
This is in the next week, and then the

1:43:29  
Yeah, and then there's these different. Okay.

1:43:33  
Then, I think I'll stop here.

Transcribed by https://otter.ai
7:54  
Okay

7:56  
Hello, today Can you hear me? Yeah, well, I hope so, let us continue on where we finished last time I was discussing the stack machine for micro c What was that? So, we saw an interpreter for C. But then I also introduced this stack machine which is like a lower level virtual machine based on some simple instruction set to which we could compile Microsoft programmes. And this example is intended to serve sort of as a general introduction into how imperative programmes could be compiled into a lower level language. One of the main things here being that since we have functions and also recursive functions in particular, but already functions that can call each other one has to work with something that is called the frame stack. frames in the stack. Frames are also called activation records. The idea is when the main function calls a function that function calls another function. This one calls yet another. In general in a computation, we can be in the middle of a lot of things, there is a lot of things that are not yet finished. At one point we will return from the function where we are to the function that called us from there eventually hopefully, we will return to the function that called that one from there eventually hopefully we will we will return to the main function at every stage So we have to work with the actual arguments, and also the local variables of every particular function. And they have to be somewhere during the, during the execution of the programme. So what we can do is that the stack machine can handle all of all of these frames on the stack, including allocating all the data on the stack. Next time, we will also start to look at heap allocation. And the stack looks like this, let me share my screen.

10:48  
The stack looks in general, when you're in the middle of the execution, something like this picture from the textbook, which I explained last time, let me quickly remind you, and then we go on to where we left off. The idea then was that, in general, your computation will be in states that are given by you know, your programme that you're running, which is a list or maybe in a more serious implementation and array of instructions together with a pointer to this array, which is where you currently are in the programme called PC, the programme counter. And then the other part of your state is state is the current stack, what is on the stack? Well, you have to have some positions in the stack where you keep the values of your global variables. And then on top of that, this is at the very bottom of the stack. So this stack is often pictured sort of vertically, and the top is at the top and the bottom is at the bottom, here, it's written from the left to the right, like also in the code that we have. So the bottom is to the left, and the top is to the right. At the bottom, we have the global variables. And then on top of that we have all these frames every frame corresponds to a function call that we're currently in the middle of and what is the information that needs to be recorded there in general is is the following things we need to know when we leave the function the place from where we were called in the programme, so there has to be a return address. So, this is a this is an address in the programme, repositioning the programme to which we will go once we're done with this function here then there is this thing called Old BP. So at the very beginning, they say some special value or now, but at every next in every next frame, this is a pointer to a definite position in the previous frame, which is actually not the zeros not the first but the second position, which is the position from where on in the frame, you have your your your all your audio local variables including the what the arguments that have been passed to the parameters plus the locally declared variables. So, these are here together with any possible temporary things you may have like intermediate results of computations. And then there is the next frame and next frame, next frame etc. and here was an example in the case of factorial for example, and I pointed that out to you that the old base pointer thing always points to the correct place back in the stack. So here for example, in this frame corresponding to not the main not to the main call of fact, but to the first recur recursive call of fact, the old base pointer, which is hearing position 10 in the stack, holds value six and this six here is nothing else than the position. The correct position identifying the previous frame. Well, the frames are not necessarily all have equal length, I mean here they happen to be because these are all calls to pack. But But corresponding to different functions, we might have frames that have a different number of of parameters and local variables. So these things are generally the frames can be a very different lengths. But then this BP allows us to, you know, navigate from one frame to another and land at the correct place. That's what we talked about. I also mentioned sorry,

14:46  
let me show it here

14:50  
was then the global sort of state of execution of the abstract machine involves five components. So as we said, the really big ones here are this array or list of instructions, and an array or list of integers, which is the stack. But then we also have three sort of top level pointers to these things. So we need to know, designated position in the programme, which is where we currently are in the programme. So it's, it's a position in this array of instructions, it's called the programme counter PC. When you know, the PC, you know, this is the instruction is points to the instruction you have to execute next. And for the, for the stack, if it's implemented as an array. Well, we've allocated some stack a huge thing, then we know that the bottom is at position zero, we don't know where the top is, unless we specifically remember it. And here, we remember it in this in this in this pointer SP, so that points to the stack, top actually, it points to the position next to the stack top, so it points to the next three position. So if you were to push something, next, it would go to that position. Okay. And then there is the base pointer. So we have these old VPS everywhere in the picture that pointed to, to the to the basis of all the previous frames, but we also need to know the base pointer for the current frame. And this is then held in this base pointer,

16:27  
b, p.

16:30  
Okay, that's what we discussed. And then I was in the middle of explaining you a bit of the compiler. So what is our cost here, we've got these different micro C, syntactic constructs like expressions or which the special case are accessors, statements, declarations, and they are somehow put together into into the top level programme, how each of these are translated into stack machine code. Yeah. So this goes by, by different functions, all defined by mutual recursion that produced this code. So we looked in particular at one that was called C expert for compiling expressions, what comes in is an expression, what comes out is a list of instructions. But there are similar ones for the other construct like four statements, that's the one that we didn't consider last time see statement takes the statement produced is also a list of instructions. And both of these guys, they use some variable environment and function environment that are sort of the key information about how we did allocation of variables and functions. So in particular, I already mentioned that for global variables, you have to remember their absolute addresses in the stack. This is what var n knows, for local variables. Since you may have several incarnations of say, the same function around like your effect was the picture when it's wise to keep actually not the absolute addresses, but but the local addresses of these variables, which are kind of offsets from the base of a particular frame, like here four factorial and is at address six, but this is obtained by taking the base which is six plus zero because n is you know, at the very beginning of of this, this part of the frame here, but as rest would be six plus one. So the base pointer value is six, and the corresponding offset that is recorded in the variable environment would be that rest is at one. So n zero rest at one. In this particular example, in general, local variables are given relative overseas. Okay, I didn't get very far with this. I didn't formally show your foreign or foreign funding or anything like this. But we'll see a bit of these today. Okay. Then, what else did I say about expressions and accessors that we looked at was that when you produce this compiled code, you follow a certain protocol or agreement with yourself regarding to how each of these compiled pieces of code treat the stack. And what is an expression supposed to do? The code for an expression machine code for an expression is allowed to consult the stack. But it can't change the stack. Other than that, eventually it will add one element at the top of the stack and that is the value of the expression. This is how we express sorry, how code for an expression works. So the idea is that Use the stack. By looking up things there, we had instructions for this

20:09  
load indirect and what they were. And then Indian producer value accessors are similar, but they put not the data value but an address

20:25  
at the top of the stack, so they add one value to the stack and move the stack pointer up, of course, statements are different statements can consult a stack. But in the end, they don't contribute anything new to the stack in terms of the length of the stack at all, right. But, of course, we can save some values in the sense that we also have the store in direct instruction. So why do we do not put the new value on the stack, we may actually in the course of executing a statement, change something inside you already provided height of the stack or length of the stack. So for example, when I when I calculate the factorial, in the end, I may change these rests, positions here in the stack, in the course of execution. Okay, so where did we leave off? I explained expressions fully, starting from operations numerals, but then also like, what do you do if you already have an accessor compiled and then you want to do assignment. And I started with accessors, which I only touched very briefly, I'll continue a bit on those. And then I go to statements. So one thing, maybe, since I already brought it up to mention in connection to assignment was, this is one of the places where you do not add a new element or a new value on top of the stack, but you change something deep inside the stack. So an accessor. That, that compiled code for an accessory, the the accessor denotes an address that is produced by the compiled code for the accessor on the top of the stack. But this address is actually used to modify something deep inside the stack. Right. So this is one of the places where you don't change the height of the stack, but something inside the stack changes. Let me remind you what storing direct was to get us back on the top, you've got an eye for an address and V for a data value. And then what is returned is s but it's not the same as is an updated this. And the value is kept on the top top but is dropped. But instead what has happened is this S is really not the same as here, maybe it should have been written as S prime, it is a modified stack where at the highest position we put the value. So in the in the pre state, the interesting data value is only at the top of the stack. In the post date or after the instruction the value is in two places on the top of the stack. Where do we keep it because assignment wants to return a value, but also the same value is duplicated somewhere else deeper in the stack. And it has overwritten some other value that was previously there because it's a destructive update this okay. So I mentioned accessors and I finished off commenting on this clause. Let me let me now also comment on the remaining cases here. And let's repeat that far. So what was it? So if you have to find out an address for a variable, what do you do? We'll address these are invented for variables and we haven't yet talked about how exactly exactly happens in the code produced for declarations the code produced for declarations. Why do we produce it we build the var environment and also the function environment and in this environment we remember which variable is placed where the global variables in this var n are put at some absolute address. Whereas local variables in this var n are associated to their relative address. Because the same variable especially like in recursive calls can be in use in multiple places and for each time. It has a different Absolute address, but it always has the same relative address. So here we had multiple occurrences of frames of fact, around all came with variables and address, in each case at the same offset zero and one at the same offset zero and one, but from a different base.

25:20  
Okay, when you need to find them the address or produce the code for looking up the address of x, then for a global variable, all we need to do is we push the address that the environment knows on top of the stack. So that is the address that we want to see on the top of the stack. cspi, remember is push a constant for a local variable, this is not the correct constant to put address that we get from the environment is not the correct constant to put in the environment. But we have to put the base point there plus this relative address or the offset. So for that, we need to produce the following code which is the sequence of three instructions. So first get the P. So this pushes the base pointer on top of the stack, then we push the address that the environment knows on top of the stack, now we've got two, two addresses on top of the stack. And then we pop off them both and we add them together and then we push the result back. This is what add that. So in the end, the absolute address has been made out of the relative address and then pushed on the stack

26:51  
akdy Rafi. So here, the idea is that he is an expression that has an L value, and we're just interested in the L value of it, but he is an expression.

27:08  
And we can we can compile it. This produces something that pushes what normally looks like a data value on the top of the stack. But here this data value is treated as an address. But you know, we really don't make any difference, real difference between instructions and sorry, between data values and addresses. They're both integers. So it's an integer. Anyway, this integer is what is pushed on top of the stack. So it's something that was made as a data value but a which you think of as an address. Yeah. And then finally, access index. So this is for the case when we want to do array indexing. So we want to know, the address corresponding to a particular index into an array. What do we need to do then? Well, we have to compile the accessor. This produces a code, this produces a piece of code that loads the address corresponding to this accessor on top of the stack. Okay, but we're not interested in that address, we're actually interested again, in an address that we get by on one hand, taking the given address to the array, for example, and then adding the correct offset to it, which is given by the index. So what do we need to do, then it's good if this thing is on top of the stack, but then also we should.

28:57  
So an array, an array is associated to an address that further associates to the address of the first element or the zeroeth element of it. So So really, we have an address on the top of the stack, but that's not the address of the zeroeth element of the array. That's when we actually get by D referencing this one. So we should also do a load indirect. So we look up under this address, and we put the result on top of the stack. So this is this bit here. We start from here. And we do that. So that but this is still the base address of the array now or the the address of the zeroeth element of the array, but we have to add the correct offset. This we can do by addition, where do we find the correct offset from? Well, we have to evaluate the index expression which is just a normal expression. It produces a value like one or two or five, which appears on top of the stack and this is something that We don't literally treat as a data value, but we think of it as an offset. And then we add them together.

30:08  
Okay.

30:11  
A bit about statements just to give you the feel of it. I won't show everything anyway. So what kinds of statements did we have any expression. Most importantly, any assignment counts as a statement. And the point is, when you want to see an expression as a statement, you don't care about the value, it returns, you only care about the side effect it has, which are the rights it does to the stack. But you don't care about the value that is put to the top of the stack. So really, the compiled code for an expression as a statement is just the compiled code for the expression, but you have to add one more instruction, which is think SP. So increment of the stack pointer by minus one. And this is just a way to say pop, I mean, here, Pop is not the primitive instruction. But Inc, SP minus one is to shrink the stack by one, you don't even delete the value at the top of the stack, but you just move the stack pointer down. So whatever value is, there is no longer considered to be part of the stack. Hmm. Then there are control instructions. So for example, stuff like if and while and also blocks. Locks should in some sense, be more basic, because it's just about sequencing statements together. But since they can also contain declarations leave these just leave this for later. But if the nest for example, and and why? Well, if it's analysis given by two statements for the two branches, and then an expression for the guard. Here's the compiled code, all of it, actually, sorry, one line using all of this. So is a whole bunch of sequences of instructions glued together into one long sequence of instructions. The main parts here are the combined versions of statement one and Statement two. But then I have to arrange some control flow around them. And how is that done? Well, we also use the compiled code for the expression. So this is compiled code that produces the value of the guard at the top of the on the top of the stack, the next instruction should pop this value check if it's zero, not because we're testing if the guard is true or false. So this reduces to finding if it's zero or not. If it is zero, then we should jump to the second brands. So invent that we invented a label called label for the else branch, and then we just put the jump to that branch. If the guard is not false, then we don't jump, then we just go on to succeeding code, which is the first branch the true branch. But then I shouldn't be so naive as to just put the first branch here, and then the label and then the second branch. Because then if I'm done with the first branch, I will still do the second branch. And that's wrong. So after the first rounds, I better insert the go to to the very end. So I also need to invent another label for the very end of this compiled code for if then else. And then after the first branch, I jumped again. So there's two jumps involved right? After the first branch, I unconditionally jump into the very end. And between the guard and the first statement, I conditionally jump to the second branch, which means if the condition of being equal to zero doesn't hold so that the guard is true, then I don't jump and i i got too much. And why you can imagine you can you can do in exactly the same way. So I just have to organise the control flow somehow. Okay, let's see why. So what do we need to do for Why? For while we need to, I have to use the compiled code for the whole statement, of course, and compiled code for the guard expression. And here a while is typically combined like this, you invent two labels for the beginning and for the test.

34:59  
So The test label we put in the middle, and the beginning label we put here. And then what happens. So first we happen. First we jump to test unconditionally. So we jump over this place. And over this place, we jump here, and we just do the expression, the guard. So when you execute this piece of the code, the first thing you do is you jump, then you execute the guard, and then you check if the guard is not zero or not. So if it's not zero, which means the guardian to then we jump to begin, and we actually do the body, then we go through this label, nothing happens. And then we're back at the guard again, and then we look around, but as soon as the guard, so as soon as the value on top is zero, which means the guard is false, then we just fall out of the loop. So we complete the loop. So this is the piece of code that is generated includes two labels that we need targets of jumps, then at the beginning, we put them on conditional jump. And somewhere in the middle, we have the sorry, at the end, we have a condition. Okay.

36:34  
return is an important type of an expression. And we've got two kinds of return here. So for the functions that have type void, when we return, we return nothing. For functions of type, some other non void type, we actually return. And we'd have to provide some expression in the micro C code. Each of those is compiled using grep, which is the machine instruction for returning to the place indicated by the old base pointer. So the current base pointer is set back to the to the old base pointer. And the PC is set to well to the address where you have to return. But you have to make sure that you remove the current frame from the top of the stack. So all of this stuff has to go. Yeah. And in the end, you only want to return the value of interest. And now here there is some sort of pointer arithmetic making sure that all this happens.

38:04  
So let us see how this goes. So if the function actually returns something, so this is given by an expression, then of course, the compiled code should contain the compiled code for the expression, this compiled code produces the value of the expression on top of the stack. But then a way to take care of also this value being made known to the function that called us and getting rid of the current frame for the function from which we're just returning, so we were no longer in the middle of that function. That's done by this command ret. And the important point is to figure out what is the correct argument to keep the wreck in, in these two cases, this is the general case this is somehow a special case. So here to read, we give a number and the number is actually stored in the variable environment, I didn't fully tell you what the variable environment contains the environment. The variable environment consists of two parts. The first is a dictionary associating to every variable, either its absolute address if the variable is global, or an offset if the variable is local. So that's the dictionary part, but there is also a second component which is just a number and that is what is used here. And that precisely knows how many parameters the function has. And the point is, we want to tell this, this instruction read, how much stuff it should delete, from the stack. And here all of this has to go on. Right. So if, for example, the function has zero parameters, but it returns something, then all these things have to go away. There is also the case when the function returns nothing, and then more things will have to go. And that's captured by putting minus one here. So it's a function in particular has zero parameters. And it also returns nothing, then this thing is minus one. And that turns out to do the right thing in this particular case, because then in some sense, you also want to get rid of this V here.

40:46  
Okay. And that may feel unintuitive. But if you do the arithmetic, and you figure out, then you see that this is, this is what happens. So is that in the book, this is even calculated for you. But I don't want to go too deep into this, because it's really kind of a corner case. And then what else should be explained? I don't want to now explain the full detail of everything. There is especially a case where you have to work with a list of expressions that has to do with functions, calls where a function call has a number of arguments, all of them are expressions. So these have to be dealt with, with using this function. That rather than compiling a single expression, compiles a list of expressions. But this is really mapping, compilation of a single expression over to a list of expressions, there is nothing specific happening here. More interesting is function calls, which I jumped over the last time. So let's look at this. So we said the function call is an expression, but it's treated with its compilation is treated with a special function called fun. So call fun, then should be compiled code for a function call. And according to the protocol, this compiled code should leave the value returned from the function on the top of the stack. So it's important to ensure that this happens. So let's look at how call one works. So cofund gets from cx for these two pieces of data, the function name and the expressions which are the arguments, the actual parameters together with a variable environment and functional. So here's generating code for a function call, when the function environment based on the function name knows a whole lot of stuff about the function.

43:19  
So it knows in particular, the parameter declarations it knows the label that we associate to the function and in the generated code, so this one has been invented. And add this label is the code of the whole function. And that's maybe what is important for us here with the tie up thing is not

43:47  
even used.

43:50  
Then what do we do? It's important first of all, to ensure that the function is called with the right number of arguments. So So here we've got a call the arguments are these expressions, yes, but they we have to match them up with with the parameters from the function declaration and they these parameter declarations are here. So these are both lists, and they have to be of equal length. So this is something that we check. And then if this is the case, then we can combine each of their arguments separately. So this is this map, apply to the compilation function for individual expressions. And then at the end, we have to put the call instruction and let's see why it does the right thing. If the number arguments provided is wrong or we just say there is a parameter or argument number mismatch, I mean there is no pipe checking there is only the checking that the number is correct. So, why is the call the right thing to the well, it is because in this language in this machine instruction language call is actually a primitive instruction. So, this is supported by the machine directly but of course, it's not like a it has a different meaning than than a function call in the in our high level language namely myocracy it is it is kind of a go to so, where we go to a certain place, which is this lab F in the in the machine code and we have to correctly return and now let's look at what are the arguments to call the arguments to call our number which is the number of arguments here and the label which is this ad here. So, we are calling a function that this address we really jumping to this address so, called functional a what it does is that the the PC now will become a spelled out here exactly that are explicitly but this is what happens, but something goes happens on the top of the stack So, namely there is a certain manipulation here. So, the function arguments are expected prepare then here we did prepare them as values on top of the stack So, they are here already on the top of the stack prepared by the compiled code for the expressions that are the arguments but this bit is manipulated a bit so it's turned into a proper frame. So, here they're like intermediate values on the stack, but now we organise them into a frame how So, we put the return address and we also put So, what is the return address the return address at this point should be the current PC plus two because it has two arguments. So, our here looks like something out of the blue but it's not. So, this is where we want to return and BEP is is the current base pointer which now becomes the old base pointer at this place. Yeah, so, these are all the side effects here. But this is what a call to a function that and now have more or less explained you how everything in the programme works except perhaps for for declarations that are involved and then how allocation on the stack happens. So, what is the best place to look for this? So, there are two places where we see declarations. So, there are top level declarations of the Global's and functions for example, but there are also local declarations in sequences. So a block consists of either statements or declarations. And, and, yeah, maybe to see how this is processed that let's look at the case for block for statements and then I finish here today actually.

48:50  
Now, we are back at compiling code for statements. The block I said was a bit more complicated because it also involves declarations. But what are what was the state? what it was a list of statements anyway? or What sorry? What was an argument block Anyway, it was a list of statements or declarations. It's called statements here but everything here is either a statement or a declaration. So what do we do? So basically this thing is processed with a little helper called loop. So statements are produced with loop and this guy uses as an accumulator both statements which will start to shrink and will be processed statements one by one and remove them from the list. So to say and the variable environment that keeps changing because we learn information about the variables and we put this information environment prime. So when all this is produced, two things are returned a piece of code that is what we actually return

50:01  
And also a number called f steps. And then what is the final code produced is the following. So, we meet all the code that was produced by the individual statements or declarations. But at the end, we put this ink CSP thing, which was increment of stack pointer that will either grow or shrink the stack. And here what we use is well, the second component of the given var and which we modify by the F steps that is calculated in the in this loop, and then we get the numbers. So let me try to motivate let me get here, after we process this part. So what happens

51:01  
if that is important to keep, because we have to know how many variables are allocated as we process a statement, right. So what happens if we're at the end of our list of statements or declarations, then we don't produce any new code at all. And we remember as the number to return the accumulator value here, or sorry, the return value here. This second of our and otherwise, if I've got the statement or declaration followed by the rest, what do I do, I process the statement or declaration in the given variable environment of functional and functional environment, this good produces a piece of code. And it may change the variable environment which happens in the case, we are actually processing a declaration rather than statement because this will add one new variable to the environment together with its offset. And then I continue

52:21  
with

52:31  
with a loop, and now with the rest of the statements and declarations, with a variable environment just produced so that one is threaded through and that produce more code. So this is the code for the first statement for declaration. This is recursively the code for all of the rest of the statements or declarations, and that is what is returned. And the final number that is returned is this f depth here, F for function depth, well, it doesn't need to be longer, maybe we should call it block depth

53:03  
here. And the point is this many new variables to get allocated on the stack. So in the end, I need to increment or I have to say that the stack pointer now is is a bit higher. So differently from the other imperative features that we have in the statement, I mean, nothing here grew the stack in height. When all all statements that don't don't contain declarations, they leave the stack quite the same, they can change something inside the stack, here the stack grows. But of course, the growth is not this final thing after here the growth is the difference between what we had as the depth before and what is the depth now. So that's thing increased, or increase in height or depth, how confident and then we have to correct the value of the of the stack pointer here. Actually, these inks p in CSP, we could also have done at the end of every particular declaration that contributed by one so that's another possibility not putting qsp by a big number here but in qsp by one at the end of every single declaration.

54:24  
So how is how is processing a declaration going? Well, a declaration is given by a type and the variable name and all what we do here is we allocate a local variable with a given type and this name in the given variable environment this activity will actually return us a new variable environment and the compiled code for this location. So the variable environment is something that we use during the combination in the end is thrown away when the company is finished. It's just our own sort of note on the back of an envelope, what have I put where the compiled code in the end needs to know nothing about it. This is for me to do the bookkeeping during compilation, but then instruction list is what is produced. So it's allocate lockwise. And then how should the allocation happen? Well, it depends on the type now. So if the variable is is an int, or a car, or a pointer, then we just allocate one position in the stack, if it and the same, if it's an array with an unspecified length, if it's an array with a predefined length, then we allocate both space for the for the address of the array as such, but then also, which is a pointer to a further place. But then also, we actually allocate the space for a whole array as well. Which is similar to how we did in in the interpreter, but I'll point you to this. It's here. So that's the function allocate that was called during the compilation of the Declaration, so what information did it take and what was it promised to return it's exactly those that are given here. And so first, it takes something that is called the claim, which is just an indication of whether it's a global or local. But it's more detail than so but let's let's ignore for now, then type the variable name, the given variable environment, what it produces a whole is a whole bunch of instructions that will make the space as we sort of say, as we as one actually executes the machine code. So this is this corresponding code with var n with our new variable environment. So this is the updated dictionary, where we are remembered the offset for the new variable that we just processed. Okay, so what do we do, we pattern match var n, we split it into the environment proper, which is the dictionary associating addresses or offsets to variables and F depth,

57:43  
which is, which is a number of current variables in the current frame. And then we can This is the real application, then it depends on the type.

58:08  
So, first of all, just to make things simpler, we forbid nested arrays, we don't allow arrays of arrays, so, something of the form where the type where the type itself is actually tip A, which to pay always has to take two arguments, one is the type the other one is the optional length. If the type is is tip a, again, this is forbidden, because it would be an array of arrays, we don't allow it. And then the two other cases are either an array with a pre specified length something of the form tip A t where t is a type and some I which means that we have an actual integer here giving the length then we do one thing. The default case accounting for characters integers, arrays with no pre specified length, and pointers is this one, this is kind of the main situation. And arrays with a pre specified length are then a bit more of a complication.

59:20  
So so here's location for for this default case. So what we need to do is we insert

59:54  
to the environment, which is a dictionary, a new entry which just says x. We have A new variable x of the given type tip, which is most often not used here, because we have very lexical pipes, but some functions to look at it. And then, the other thing that we have to associate here is, is, is a is a client. Now, so they have to tell you what what kind is officially. So it takes an integer, which is here, this f type thing and it gives you a variable. As you're sure what the variable, you'll see what the variable is, but it's the knowledge of whether it's local and global plus a bit more, then the real thing here is that the counter is increased by one. And in the code, this is also reflected by and by incrementing, the stack pointer by one. And then what we return is we return the new environment thereby produced. And this little piece of code here, which was actually very little, it was one single instruction.

1:01:23  
In the case of an array, it is a bit more complicated. because on one hand, we increment the stack pointer by the whole length of the array. So that's what we do here.

1:01:46  
And then, what do we do, then we have to actually put on the stack, which will be the value of the pointer corresponding to the array the the correct thing. So which then is okay, we incremented the stack pointer by this much already. But now let's put on the top of the stack the pointer to where we were before. So that's like, get the get the get the stack pointer and subtract what we just added, we get the old number. And this is what we put on the top of the stack. Actually, it could be written in a different order. But then we would need to do swapping, so I could remember the stack pointer before, then I could increment, then I could do a swap, deeper swap. And, yeah, and we would also be fine. But this is one way to do it. Now we have to look at kind

1:02:55  
Oh, sorry, I want to say I'm curious just just just here name that assigns a variable to an integer, which is the steps part but I wanted to say we have to look at the definition of var. So variable really is is one of two things is either an integer tagged as a global variable. And this pretends to be then an absolute address in the stack. Or it's an integer tag with lock var that pretends to be then an address relative to the bottom of the current frame or, or an offset with respect to the base pointer for that frame. Base pointer into that tree. So here, coin is passed down to, to, to allocate from. From the compile function, in our case, state c statement for the case of Roxette state statements and declarations, we know it's local, so kinda is just the function lock, which is the tag turning an integer into a variable. So basically, at this place here, I'm instituting sorry better to talk about this one, this place here on instituting a new variable I'm saying so if my current current counter of the depth is F, that's, then I'm saying in the dictionary x is associated to, you know, local of that depth. And if the same function were called from the processing function, for main, it will be global of that depth, but here it was, local. So all that happens at this place is we increment the counter by one into the dictionary, we put the Association of the variable name x to the type of it, and to the address that we just made with a tag that this is meant to be a local variable, which means you should treat the address as,

1:05:16  
as an offset.

1:05:19  
Yang, the real code is is is only this. Okay, and this is all for that part. Now, I think that I wanted to say there is more that could be said about me. I actually want to stop here today and finish earlier. I will continue by showing little examples of this in action on small programmes and the combined code that has come out. And then we can think how this code gets executed. I mean, what does the abstract machine to using sort of this, this cheat sheet in action, but this was the story of how the compiler more or less is built. So things you have to know is, expressions are supposed to put the value on top of the stack, ie the value on top of the stack, the same for accessors, except they leave the address statements leave nothing on top of the stack, all of these things can change some values in the stack without changing the height the such. So, this corresponds, this has to do with the fact that this is an imperative language. So, variables values do change, but they're all stuck located. So we change things deep in the stack, using the story in direct. And when we want to, you know, recall that the value of anything was in this in the event, it's also in the stacks, we have to go deep into the stack and look there, Lodi, so then there is always bookkeeping about how high we call, we want to consider the stack to be. So the stack is implemented as an array. So you work with an explicit stack pointer. So when you make the stack higher by one, then you should also increment the stack pointer.

1:07:25  
Unless this is done, so unless this is sort of part of the instruction. So obviously, this one will increment the stack pointer by one. But then when we sort of want to artificially increment the stack pointer, so So here, for example, we've produced some things on top of the stack using some sort of ad hoc mechanism. But now we want to say, okay, the whole extended thing here now wants to be considered as the new state of the stack, then I have to manually increment the stack pointer. And similarly when I want to shrink the stack, so I really want to pop, this is what we do. So this increment here is like an anti pop. We don't explicitly say what we want to put on the top of the stack, but these things are have already been pre prepared there. And we'll just use them. And that is it. Why don't we combine we keep the sort of compile time dictionaries, which are the var and when finance in the compiled code in the final compiled code, they don't show that we just have a list of instructions. But as we combine, this is where we keep track of the decisions we've made. And that is more or less. Hey,

1:08:42  
how about the questions? Okay, there is no two lectures left. One next Tuesday, but I'll still talk about technical material. And then one

1:09:16  
after these the break on Thursday, which will be kind of a recap thing as well. So I try not to leave too much for it. Rather than I can perhaps go through again, a few things and maybe comment on last year's exam. You'll get the solutions for that one, which I think are not in my school. I'll post them in Canvas. And that should be it for the lab parts because of the rise in the COVID cases. The last lab, which is after this the break these will have to be online as well all of them. But we will keep in touch and I'll inform you about developments before. And certainly before the Easter you should get the grades for the other scores for the third assignment. And I'll also publish the solutions. Maybe today. Okay, I'll stop the recording here.

Transcribed by https://otter.ai
6:21  
Hello let me today tell you about one last thing related to imperative programming that we didn't touch upon so far. So, we have looked at two simple imperative languages one was called imp which was a very simple imperative language that just has global names and a bit of control flow but nothing like pointers then we looked at micro C, which was the more serious language that on one hand had pointers even to the degree of pointer arithmetic like in like an actual c See also arrays and also this fact that you can use pointers for arrays in the race for pointers like C like in C and that also have functions. And we

7:25  
looked

7:27  
at some of the relevant concepts and principles in particular, we looked at how the interpretation of these languages could go and how compilation could go. And the compilation went with an abstract machine that was based on a stack, specifically a stack that we call the frame stack because for every function call that is currently active, there are some data on the stack that on one hand have to do with computations namely for the arguments for the locals for temporaries resulting from expression evaluation, but then other sort of infrastructure management things having to do with the fact that multiple calls are active at the same time, at one point we will return from the call then we have to return to the to the correct place and we have to discard the data values that were local to the function we just left. So, explain this, these kind of abstract machines are actually very common in the implementation of of languages. So, the the the Microsoft stack machine was the most serious one that we looked in this course it is it is customary these days that for interoperability, you actually define compilers into intermediate languages that could then be virtual machine languages. This is done on one hand both with Java and on the other hand. So the J is the Java Virtual Machine JVM, which is not the physical computer architecture is really an abstract machine for compiling Java, but also other languages too. And a similar infrastructure is is available from Microsoft having to do with the dotnet. It's called the common language infrastructure. And the specific thing is called the Common Language Runtime. So this is all nice. And I advise that you check this chapter nine in the textbook that is specifically dedicated to virtual machines. I won't go through it and I won't explain it in a lecture. It is Sort of a survey like material, it doesn't go into anything in any technical depth, but to know, you know, what different languages used and what technology is available, when it became available, what are the important similarities and differences, this is a very good survey chapter I want to discuss a bit something different now having to do with with data structures that don't have statically fixed size.

10:35  
Like,

10:36  
perhaps linked lists or doubly linked list are three three like data structures that you may want to work with in an imperative language like C. And you do so we only looked at integers, characters, pointers, and well essentially arrays of fixed length, we also have a razor and no pre specified length, but they don't come with any allocation mechanisms. So, these were really essentially you had a possibility to introduce names for arrays, but but not to claim space for there are these data data structures whose size you cannot predict that you want to dynamically allocate space for these are present in C, and in C, you do manual allocation of of space for these things, and manual D allocation.

11:34  
And these

11:35  
data are not stored in the stack, they are stored in another runtime data structure that is called the heap. The heap here is not in the sense of algorithms. But it's in the sense of of programming languages. And it means it's kind of antonym if you wish, to the stack, when the stack is an ordinary thing,

12:00  
you you put

12:02  
things in in a certain order, and you expect them to collect them in in the exact opposite order. So whatever went in last, you can pop first hips are are in contrast to those in that they are a flat, this orderly structure is just some space in memory that is available for you to get to the place data structures in but you manipulate it in a in a fairly free way. And at any stage of your computation, you have some part of the heap used, and the rest are not used, but which parts are used and which are not used. This keeps changing. So let's discuss this topic. So I'll just do a quick overview of the chapter and you can read more details yourself. So I'll share my screen. So we're talking about chapter 10, that talks about heap allocation and and manual heap management versus garbage collection, which means the freeing of the space is done behind your back for you. Okay, so, stack allocation is nice, and you use it for for data with predictable lifetime. And on the other hand, whatever you put on stack, in some sense has has a predictable lifetime, right? Because Surely, things closer to the bottom of the stack have a longer lifetime and things closer to the top have shorter lifetime and if you look at the particular stack position, you can be sure that this stack position doesn't survive longer than the stack the positions beneath it are closer to the bottom of the stack.

14:13  
So, stack is good for predictable lifetimes. So we we work with simple data values of fixed size we can allocate put them on the stack.

14:27  
And we do this as we enter functions and really functions accordingly these things are put on the stack and and discarded. So, in micro C we could use this cell cycle location because several good things work in our favour. But if you have a larger and less disciplined language, all these goodies go away. So so for example, in Microsoft we have the static scope rule. So when you see variable in the programme text. So, the interesting question is always a free variable in the body of a function, then just looking at the programme text, you can figure out where where this variable belongs or you know, which is the associated declaration of the variable. So, for functions, it will always be the declaration from the definition site. And this is a very static notion. So, in contrast with dynamic scope rule, you determine the, the meaning of the free variables in in the functions body based on the function called site and one of the same function can be called from very different places in the programme, and you cannot tell statically this is to say, you know, prior loading the programme to the interpreter or, or prior or during the compilation, you can tell this, right. So, it is we also first order in the sense that we don't allow functions to be returned from functions. And the main thing is Microsoft, sorry, micro c doesn't have these dynamic data structures that are immutable, and whose size you can change during updates to a data structure. So, for example, you've got a list you can you can build a new list by by cleansing cells to the front of it this these are all beta structures with with no static fixed size. Right. So, this is all very good. And micro see in that sense is a discipline language, although, we should say that already in micro C, you can do bad things. So,

16:56  
he,

16:57  
the data are allocated on stack, but because we have this function because the sorry, his language construct called ampersand that returns the address of an of a data value, the address of a location, you can actually already do 30 things there. So, this is mentioned here in this paragraph. So, in micro C, which of course, then happens in accuracy as well, you can write these cool functions that have a local variable, then they declare a local variable, then you obtain an address to that variable. And this will be an address to, you know, to some position in the stack. And then you can, the function can be returning a pointer and in particular, you can return that address to the calling function. Now, when the function returns to the calling function, that frame is discarded. So the position that corresponding to the local variable in particular, is no longer in the stack. I mean, it's in the array that stands for the stack, but it's, but it's, but it's outside, what you actually consider to be the current state of the stack, which are positions between zero and the stack pointer. So then this address is passed out to the calling function, the calling function doesn't know anything, that this corresponded to the address of something that was local to the function that we already left. And then you can do things in the calling function with that pointer. I mean, if the pointer is p, then you can make an assignment to start B, and all of a sudden, you return a value somewhere outside the stack. Okay, this is maybe not so harmful because it's outside the stack. But then you can also read from there and you get, you get garbage values, right? Because the next time the stack grows, who knows which function will write something there, and then you'll just see the value from there. Okay. So already this direct manipulation of pointers, of course, he's dangerous, but it's not the worst thing in Microsoft. But then, most modern programming languages do premier do permit creation of values whose life lifetime you cannot predict. And that is, I mean, it's not tightly title, but it's in particular useful for these dynamically updatable data structures, where you also change the the size and the layout of the data and values with unpredictable lifetime in general and these dynamically sized data in particular, they are stored in this data structure that we call cheap. So for HIPAA look at data, you actually have to reserve space in the heap in the language typically. So here is the syntax for this thing in some languages where this is a thing. So in Pascal, for example, we may want to allocate space for an array of unknown size. Or maybe we want to do allocate space for an array in C or c++. And this goes with typically with malloc, or,

20:37  
or

20:42  
new commands. And here, you actually see that we've allocated some particular amount of space for an array of integers in the case of C and c++. Now in these languages like Pascal and C and c++, when you do not need this dynamically created allocated data structure anymore, then you explicitly have to free the space of it in the heap, you may also not do it, that's always the safe thing to do. But then the danger is your use part of the heap will grow and at one point, you will simply run out of space this is called leaking space. So these languages provide you a command for disposing space in the heap. And these commands are typically called dispose of free. But it is dangerous, because this is a place where a C programmer or a Pascal programmer can very easily slip and this happens very often. Because what you need in deallocation is or freeing space, you need to know the right moment to do it. Okay, so if you never deallocate this is always safe. But this means too much heap space may be used. So that's dangerous in that regard, but it's safe in the regard that you'll never access garbage data by by accident, garbage data arising this way by accident. But otherwise, you may just, you know, deallocate too late, then you're still not using your heap space optimally. And you may run out of the heap space at one point. So that's okay. But what is dangerous is to do okay, too early. So You Think You don't need the data structure anymore. But remember, in these languages, we have pointers. So there is often the phenomenon of aliasing. So P and Q may be aliases, pointers that alias each other, you think you don't need p anymore, because you don't use it in the rest of the programme. But you've created an alias. And this was maybe also with a purpose. And maybe it's called Q and you will later want to dereference q. So now if you free p you also freed Q. And this is this is dangerous. So also all sorts of programming practices that people use to optimise heap usage. But some of them can lead to unexpected side effects if you're not careful. So So this illusion that you manually allocate heap space and you manually deallocate heap space is dangerous, in the sense that allocation is fine. But for the location, on one hand, if you're not aggressive with it, then you're simply leaking speed space, I mean, you're using more space than necessary. But hurrying to the other side, if you if you deallocate too early, this can be really really dangerous. And there is no way for the compiler to find out that what you did was unintended and to warn you I mean, you can write specific special purpose programme analyzers that try to guess your intent based on on certain symptoms and warn you about the overall ideology of course is if, if heap space allocation and de allocation is under programmer control, the programmer is ultimately responsible. So if you've got the freedom, then you also have the responsibility right then And then the possibility to make errors. So a different solution arose actually in the context of functional programming languages, first languages where you may allocate space

25:18  
manually. But collection of space that is actually no longer used is done automatically behind your back. So this, this optimization then of the space used is called garbage collection. So, the idea is data that are there, they perhaps have some meaning, but they're not used in the rest of the computation, they are considered garbage. And the moment that you detect that something has become garbage, you know, the cleaning officer should be able to come and remove the garbage. Now, let's talk about some of these garbage collection techniques. And then I'll show you a particular example of this in action, sort of on a on a on a toy language, which is an extension of this micro C language with with certain features that leads to an extended language that is complicity in the book can then be associated fines that you can

26:23  
play with.

26:24  
Before that, let's talk about garbage collection in general. And then we go to the particular language specification, you have to talk about garbage collection, I have to tell you a bit about the heap. So as I already said, the heap is just an area of memory, some of it is at any given moment of the computation by a programme already in use, or is actively in use. And then there is the rest of the heap that is not currently in use, maybe it was never used, maybe it was taken to use, but then manually do okay. Or maybe that garbage collection, collector feed it again. And now it's free. Yeah, so in the heap, you talk about the use part. And the free part. And there is typically some sort of a data structure for you, there available to talk about which part of the heap is free, because if you look at the heap, then it's just an area of memory. And that every address, there are some values, but you don't know which values are the real data, and which are just some data left there that actually are not currently in use. I mean, you may, of course, want to reserve a bit in every word to tell you whether that piece of data is currently in use or not. This is sometimes done, and it's actually used by some of the garbage collection algorithms as well. But in general, if you just look at a piece of memory, this is Yeah, it's, it's neutral matter. I mean, it's, it's just words, you have no idea what these words stand for. So and then to overcome this, we work with a thing called freeze. Actually, let me introduce some some more terminology before. So typically, when we talk about garbage collection, we have the situation that there is, in some sense two programmes acting at the same time, on the same memory, so there is your programme of interest, a compiled machine code that does some interesting computation. This one is called the mutator. It's, it's, it's the programme that manipulates the stack and it also manipulates that he changes. values there, it allocates space for for new values, updates all values. The programme of interest in this context is often called the new ticker. So if nothing else, then your programme combined. There is then usually another actor in play that is working in parallel to your programme. It's sometimes sometimes sort of busy all of the time, but more More, more typically, it's activated now and then and it's called collector. So this is the garbage collector. It inspects, what the mute mutator is doing. And based on how the heap develops now and then it becomes active and reclaims unused space. Now, the space as I said comes into part that is the use part and the unused part. The unused part is typically kept in some sort of a data structure. The most common One data structure is called the free list. So what is the free list is literally a linked list of all the following things. The free list is a linked list of blocks, chunks of the heap that are not currently in use. So what is an element in such a list? Well, it is really a pair of two things. So you really need to know about you need to work with these blocks, right? Every unused block will will have a header, which is the size of that block. So block knows how big it is. So if you learn that the header of a block, there is the information about how big the block is. And then also, there is a pointer to the next unused

31:09  
block

31:10  
on the free list. So a free list for every block knows the address, the start address of the block. And then the size of the block. And this is how your memory is organised. In the end, all you need to know to know the free list is to have a pointer to the first block on the freeness. So this is some address in the heap. There you also see the size of the block and then the next of the rest of the block is next to it right. Now, this is what a free list is it's just a linked list of blocks and the block is identified by its start address and its size. Now, when you allocate new memory for a new data structure, by your programme, then you need for it a block of a sufficiently big size. And this is done how you just traverse the free list. And you'll find the first block that has the appropriate size, you take that block into the use into use. I mean, you take as much as you need for your data structure, the rest of the block is a smaller free block. And you've just updated your your free list, add that element by sort of changing the size. Now, of course, if you need bigger blocks, then you may need to concatenate several blocks into one. And if your heap has become very discontinuous very discontiguous, then then you may need to merge blocks together. And that's also done. But

33:14  
let me let me not explain this here. Now. I mentioned another thing. So these blocks are the free list approach has the problem that sometimes the first

33:26  
block of large enough size can be much too far down deep in the list. The better approach that is also sometimes used is that you keep a separate with the free list of blocks of different sizes. So maybe, maybe basic blocks are of some size K, but then you have a different list for blocks of size 2k at least then the yet different list for blocks of size 4k at least and yet different list of blocks of size 8k at least. And then depending on in the allocation, how big a block you need, you just extract your go to the appropriate fee list and you take the first block from there, then of course when you when you free blocks, it may happen that that again, you have a bigger block available, I mean, maybe you had a block broken into two where the first part was used. And the second wasn't. Maybe the second one is is reclaimed by the garbage collection, then at this point, you can merge two blocks of half size together into one block of the full size again and put, you know into the right place in this in this organised list of lists. So this much is important for you to know about, about the free list. So it's a way to keep record of which areas of the heap are free. But now, to these garbage collections, garbage collection algorithms per se, there are three classical ones. And it's important that you know, just the principles of each, maybe not the details. So one is called reference counting. And one is called mark and sweep. And yet another one is based on copying half spaces. And I'll explain each of the three. In turn, very often, you use something that is called generational garbage collection, which means that you distinguish between older and newer data in the heap. And the idea being that

36:04  
the data that have been there already for a long time with with high likelihood stay there even longer. And then the data that have been there for a short time. You know, initially, they have a high probability of being short limb that they don't survive for long. And then based on this, you divide data into generations. And you actually use may use different garbage collection methods on different generations. That's also very common. generalisation or sort of strategies, right. Okay. Let me briefly mentioned the ideas of each of the three. And I don't go deep into any of these you just read in the book, that's my recommendation. So the idea of reference counting is that for every piece of data in your heat for every cell, that you you keep track of how many pointers from the stack currently points to it or how many indirect pointing there is from already the stack to the heap and from the heap further to heap so. So you count all references both from the heap of both from the stack and to the heap, for given a cell to a given object on the heap. And, and the mechanism is very simple. So each time an assignment happens, you just you just increment or decrement, the reference count. So whenever an object is created, then nothing refers to it. But then of course, when an object is assigned to a pointer, then then already if a new object is assigned to a pointer, then they count is incremented. To one because there is now one reference to the object. When the mutator performs some, some assignment of the form x equals now. So x pointed to something. But now it is a null pointer to think of x is a pointer, then the reference count of the object previously referred to by x has to be has to be decrement. It I mean, it's it doesn't necessarily become zero, because there can be other pointers to the same object. But but at least it diminishes by one, this is the main mechanism by which these counts, ever go down his assignments, and here's the general assignment where one reference goes up, and then other goes down. So suppose we perform an assignment x equals Oh. So in this case, well, x pointed previously to something, the reference count of that object must be decreased by one, but x now will point to also the reference count of the object, our must increase by one then the idea of reference counting is that whenever the reference count of an object actually reaches zero, then the object may be de allocated, which is to say it can be put on the field list. Moreover, at the moment you do this, you can also Dec decrement, the reference count, so every object that pointed to sorry, so it's always a structured object, like it has fields, so then the counters of the fields must also be decremented. So if ofoh itself points to something like an object points to its fields, then the reference counts of those are of course also decrement. It's basically if you The idea is if you, if you remove a structure thing, like if you remove a list because that has fields hadn t. So if you if you remove this first console, then then surely the reference count of the tail also gets decrement, right. And maybe if that one becomes zero, then you'll remove its tail as well. So this is an algorithm that is sort of intuitive, and it's simply simple to implement. One thing that you notice is that there is some overhead both in space and time, namely, next to every object, you also need memory to hold its reference count.

40:50  
So, an object really becomes what it means some in some sort of a cell. But now, there is an extra extra extra field there, which is the objects reference count. But then also, basically, you have to babysit all of the all of the execution by the programme by the mutator, because at every assignment, you have to do this manipulation of counters, there is a further disadvantage, which is that you may have cyclic data structures like a circular list. And in a circular list, there is always already at one I mean, the reference count in a circular list of every cell is at least one because you know every cell is pointed by pointed to by some other in the circle. So you may have had some pointer to the circular list, maybe this one becomes now. Okay, so then the most that can happen is is that the reference count or what was previously the head decreases from two to one, but it never never decreases to zero. So with reference counting, you will never ever deallocate anything circular. So that's also one of the disadvantage. It's also mentioned here. Another way of doing garbage collection is called market sweep. So the idea here is, is an entirely different strategy. It's not that the collector is busy all of the time and sort of watching, watching by the mutator over its shoulder and each time the mutator does some assignment, you know, some some additional steps are made by that garbage collection, nothing collector, nothing like this. So Mark can sweep, the collection is activated when the programme is almost out of the heap space. So you're close to the situation where you cannot allocate the next data structure, you need to according to the programme, so then computation stops, the garbage collector takes over and carries out this thing called mark and sweep. And it does the following. So basically, you you start from something that is called the root set. I mean, everything that is used in the heap is ultimately via indirection pointing to from the stack. Yeah. So in the stack, you have some pointers to the heap, and then further point, there's within the heap. So what do you do, you start the following kind of a mark procedure, and that also requires that all of your words contain at least you know, one bit, or, in the case of some improvements, further bits, in, in their words reserved for for the for the algorithm to work that you don't use for data that is but it's just used for this bookkeeping. So you so first to make all of the heap cells, sorry, all of the heap. Yeah, all of your heap objects on unmark. Then your, your mark every object in the root set. So these are the objects directly referred to but from the stack, you mark them as in use. It's basically a set Bit to be true, then you look at who they point to recursively and mark those as use when you look at who the next generation points to recursively and set these as used as well. And then hopefully, you'll convert I need to comment on this because it's not trivial. And then everything that is actually in use has been marked as used and then you traverse once this is done. So, this mark, this place is called marking. Once you're done with this, you start another face that is called sweeping you just walk through the heap and for every object that you discover is still marked unused, you reclaim you move it to the free list.

45:51  
Yeah. Now about marking specifically how do you do this, I mean, surely, you can go over the stack and see about the root set that part is clear, but then the rest of the recursion if you do the recursion in a depth first manner, then of course, when you have cycles, then you can just get stuck in the cycle you go round and round and round and you mark the same things over and over and over and over. So that is not a good strategy. A better strategy is you you just traverse the heap once and for every object in the heap, you find you also mark all objects refer to it as used in the first traversal not everything gets marked as used. So if Yeah, if something is used, then whatever is further referred to from a used object to mark is used. So in the first phase, of course, you only capture the second generation, but then if you do it multiple times, then you're basically done mark and sweep in a kind of a breadth first fashion just by just by multiplying multiple times traversing the I mean in this correct way, it is fairly simple to implement.

47:34  
The disadvantage of course, is I mean, this is a cyclic thing, you only do it now and then when the heap is about full use, and then it takes quite a bit of time because you have to sweep potentially the entire heap many times before, before you've marked everything that is used.

47:56  
Okay.

48:04  
And then there is this stop and copy which uses two half spaces or two spaces. So, the idea is you split the actually heap into two parts, or the the the memory of what available for the heap into two parts do exactly the same size halves and then you do something that sort of sounds quite waist full. Namely, only take one half into the use. Yeah, and you work with this one, huh, when this one half is almost full, you have you start this top and copy collection, then the idea is again, you start from the root set, and you just copy over things, the use things from the

49:04  
from the active half space to the other half space. And you do it in the same way by by sort of multiple sweeps. Or you can also do it by recursion now, because whatever you discover, as used you at the same time, move over to the other half space. So the the idea is is a bit like in Mark and sweep but it's not done in place, the moment you you you discover something is used you move it over to the other space and the way that you do it of course then you have to adapt all the references is that the the other space is used contiguously Yeah. And then once you've done that with a copying the the the space was that was currently active, it's called the from space. This becomes the passive I have space that is then called the to space and tools and what was previously the to space becomes the from space. And this is a nice algorithm, but but again the you know, the disadvantages are sort of similar to market sweep. So, it takes time and advantages that you do compaction. So, you do not get unused unused blocks between the use blocks. So, this this is a systematic way of avoiding fragmentation and also why you do this you already fixed you know the point there. So, they point to the right place kind of in a in a systematic way. So, there is no additional overhead from that. The one is what are the disadvantages, one big one is you can only use half of your available memory space for life data.

51:12  
And this, one thing that gets especially critical also is there is this copying involved that suppose you work such that you have before a lot of time, almost all of the space used. So, because you're you're you're close to the half space being full, you copy things over many and many times to do very little compaction, perhaps, but but you just copy over the whole thing. Okay, so these were the three main and these are sort of important to remember, on the conceptual level, read here in the book, look at the figures make it very clear to yourself.

52:07  
Now,

52:08  
let me finish with what is also done here. There is an explanation of how to do this for for in our C like setting. And this is done on a on a simple extension to the micro C language that gets nowhere close to full C. But at least it's something right. And it illustrates a real garbage collection in action. This is the nice piece about it. So let's see what it does. It gives you essentially the infrastructure for doing singly linked lists. But you can also use it for W linked lists, trees, other kind of dynamic, dynamically sized data structures. So essentially, we can allocate Khan's cells and we have a pipe dynamic specifically for these kinds of things. So let me explain this a bit. So here is the syntax, it doesn't have a lot. So there is an additional type dynamic in addition to the char and pointers and arrays. And any value in dynamic can be a value or a reference

53:34  
to a console or Neil and then you have these kinds of expressions. So Neil is a null reference. So it's it's, it's a reference to a specific value that you can observe the values that you recognise that you can recognise it's not I mean like an invalid invalid value. So, then there is an expression cons e one e two v one and D two are expressions. And when you evaluate this, then actually a new cons cell is allocated in the heap and its components, it has two components v one v two think of them as two fields and they are exactly the fields for v one and v two. So, if you want to do lists, then actually you will take the first one of them as the integer as an integer data value and you will think of the other value as a as an address to the next console which is the next thing in your linked list. Then, if he is an expression referring to a console, then car gives the first component is singer gives the second component and these are sort of historical names from lists and related like Images. And then there is so this is for reading the two components of Excel. And then also we have means to update the first or the second component of the cells self care sets. P is the pointer is the name the expression whose value should be a point? Yeah, should be a reference to the cell. And we should be the actual data value that you want to put there, which may also be a pointer because here, there is no No, no type checking going in. Right? So, maybe I'll illustrate this a bit. So how do you do lists with these.

55:46  
So, the first examples actually do not use this mechanism for lists, they are just pairs allocated in the heap. But then, for the next ones, we actually do the real list. So, so here's a programme, the main programme returns nothing, of course, this main should, and it takes one argument. And the idea is, in this particular case, we don't actually use the end at all, but in the next one to use so. So there is a local variable C, that we declare is dynamic. When we say C equals cons, at this point, a console is allocated on the heap and C gets C is, is the pointer to it. Then we when we print car, actually 11 is printing then when we print sitter 33 is printed. So here, there is another uninteresting example. But let's look at more interesting ones.

56:51  
So wait, so here, we've actually used using the fact that you can use these concepts to build the list of integers by, for example, in just by storing an integer in the first cell, and in the second and address or an integer that you view as an address. So here is the function print list, it takes x is of type dynamic. So that's a pointer to a console. And then while this is not now, you print the first element, and then you update the pointer to be the address in the second cell. Right, so axes, cover axes. So if you do this, then of course, you repeatedly print the head of the list until you reach the end, which you recognise, because that's a null pointer. And here are some more functions for for for making lists, for example, we can make a list of numbers one through m in this way. So So now it's a function that takes an integer and produces a dynamic. So how does he do so we first have a local dynamic named rests, which is actually passed out. But it's heap allocated to that, okay, so we're not passing out a pointer to anything in the stack. And then we say, initially, rest is nil. And that is the null pointer. So this corresponds to us being at the end of the list. And then we sort of keep changing rest, two pointers to more interesting lists. So while n is greater than zero, we create a new cell where we put the head component to have the value n. And then the second component corresponding to the tail is in this reference race, and we get the new reference rest. And then we decrement. And And finally, when we return race, it points to the very beginning of this history list, which was created from all these courses. And then you have other examples, which I recommend you've gone through yourself.

59:13  
Now,

59:17  
how to work with this, well, let's talk about the compiler. So, we had a compiler producing byte code for a stack machine. Now we just add a few instructions so that we get the stack and the heap machine. And then we can think, how to execute this machine sorry, how to implement this machine, while in the usual way, such that it also comes with the associated garbage collector. So here it's done actually with Mark and sweep. So what would we have In the instruction set for these abstract machine manipulating both the stack and the heap, you have these extra instructions that more or less directly correspond to those from the higher level language from lists see. So, mail actually pushes the needle reference to the, to the top of the stack. So it's a reference to the designated now value when I want to create the cons, so then I've got these v1 and v2, which can be integers or addresses. I mean, this thing doesn't know I mean, there is no difference between these two things. But anyway, so that's the stack after stack before the stack after the executing this instruction will be whatever the stack was as part was before. But then the top element is now p, it's an address to the heap. It's not it's not a stack address is a heap address corresponding then to the first position of this data structure that was actually allocated in the heap. So, so this is allocated in the heap. And the free list is is is correspondingly updated. I mean, the, we go to the, to the first block there, and we shrink it size by however much is required for for this guy. Current singer, they take this address to the heap, and they look up the values there. Set Karthik and others to the heap and the value and they go to the heap and update the heap. And so what is returned is the same s&p but the actual heap has changed. And same for sets. Now, let's now talk about the

1:02:15  
the

1:02:19  
the abstract machine and its collector part. So previously, I was a bit vague about what are these objects in a heap? I mean, what actually makes an object in the memory and how on earth? Memory is just the sequence of words, right, but how should the garbage collector in general know, you know, which words together constitute some sort of object, of course, you expect some sort of structure on these heap objects. So here, this is done in a very simple way. So we actually, the heap just consists of words. And the words are for integers. The words are 32 bits, but here we need a tiny bit for our bookkeeping. So the integers are actually 31 bit. So the 32nd bit is used for for bookkeeping. Yeah. And then what we do is we just distinguish addresses, I mean, things that are to be understood that addresses from those that are to be understood as as as as integers. So an integer will have the designated bit as one, and the reference will have a designated bit the zero, which is a very simple a naive thing to do. Of course, there is a cost namely, you can't use the native 32 bit integer instructions anymore that you may have, from your underlying architecture to actually implement your machine. You need 31 bit operations and you need to make sure that your operations don't touch these, these designated bits, but just remember if you've got addresses or or integers, but that can be done right. So you have this, but then how do these How do these cells look like in the heat that is also important? And it's the following things. So so so basically, the cell consists of three parts I would say there is a there is a header which is 32 bits, and that is the first field which is 32 bits, and there is a second field. So these are called car and sitter. And these are also 32 bits. So, so basically your heap memory looks like this. So, every block is a header colour code your header The next one is header car cover header car control here this mistake

1:05:21  
okay um but then yeah okay, but I should say. So, there are the regular blocks corresponding tu tu tu tu sells two consoles, then there can be of course, other blocks and maybe the picture it was three illustrate this. So, in an another block is just some block from the free list right and these can be arbitrary long they also have a header Now, what is the header the header is 32 bits 32 bits organised in some way There are eight tag bits and for a console the tag bits are all zero. So, the T's are all zeros

1:06:20  
and then there is the length the length part the length part is the one that is important for four blocks in the field just because you need to know how long they are. So, here you use a 22 bit integer to indicate the length then of course, as cellblock in particular consists of two useful words and the first is the header word. So, for that one is 000 10 standing for the binary number two, but for a general block this can be any 22 bit integer number and finally various two more bits that are used during the market sweet and not otherwise.

1:07:11  
Yeah

1:07:31  
the yeah the garbage bits to actually stand for colours 00 means white 01 means grey 10 means black. So these are colours used in the in the market sweep and 11 it means blue. And that is a particular colour for things that you know are in the free list. So Mark and sweep doesn't even need to inspect them. Okay. So how does how does how does a freeze block like it has it has a header exactly like this and then it has these other blocks but actually the first one of them is in a special use because the free list has to be a linked list. So for a block in the free list of course we have to know if it's the last block in the free list. So this is indicated by a word that is all zeros. But it can also be not all zeros and in this case it's just the address of the next block on the free list. Yeah, so I mean if this this block here is a block from the free list when the actual free blocks are these two and this one is a special word which if it's all zeros indicates that this is the last block in the free list. If it is some other number, then it is the address of the next block in the free list. Yeah, and and this this header is also like for these console blocks. Okay. Now that is all good. How does mark and sweep work So let me explain it in two stages. So first only using three colours white, black and blue, and then I can explain, also the grey. And the explanation is here, and it's sort of corresponds to the general explanation. So in the mark, you'll go, you'll go through the programme stack and you find all references into the heap. And how do you do that? So? So first of all, you have to understand that the system is weakly typed, right? I mean, we give things types, but actually, we use things as integers or addresses interchangeably. But now, for the garbage collector to work properly, of course, we need to know whether something is an integer or, or is an address, right? difficut a value on the stack. And if it is an integer, then it's just the data value and then it doesn't correspond to anything that would be an address on the heap. So we shouldn't just look at this number and treat it as an address and say, Okay, yeah, this position in the heap is in use, because no is the database. So So value in the stack is either either an integer that is like a normal data value, or maybe a stack address. Or it's a heap reference. And then this was distinguished by by a bit in all these words, right. So it's a heap reference, when when we encounter such a thing, and we see it is a reference to a white block, white stands for unused, then we mark it black, it means it is used. And then you can recursively process all of the all of the blocks words in the same way. So the block, again contains words. And depending on what their nature ease, if they are sort of data values, or if they are addresses to the heap, you have to process them.

1:12:15  
And

1:12:16  
this is the mark mark face. And then, as a result of this mark trace, every block in the heap is either black, because this means it was recursively reachable from the stack by a sequence of references. But it's white, which means it's not reachable. This means it's unused. Or maybe it's blue. Because it's already or what was on the free list all the time. And then in the sweet face, of course, you just traverse all blocks on the heap. If a block is white, this means it was a block that was not in use, we can paint it blue, and that to the free means if a block is black. This means it was in use. But then of course, we can reset it to white. Because the next time when we want to do the mark, again, we want that all of these are white. So White is kind of the default colour right before garbage collection, everything has to be white or blue. So not currently marked or in the fields. So that's possible, but there is an improvement that goes by by these grey things. So this doesn't work then IE depth first recursion by this more clever thing that I already referred to before is with the better Mark face. So let me explain this.

1:13:51  
So, it goes into faces. So, when you find a block that is referenced from this stack, then the corresponding block in the heap is painted grey, not black directly. So now, when you have to traverse the stack, then all blocks that are directly reachable from the stack they are already grey and nothing is black. Then when you traverse the heap, then we may find as this goes in recursion, we may find no white grey or black blocks. If we find a grey block, then we mark the block itself black, which means we've actually dealt with it and then we look at the words in the block. And if they contain the reference to the white block, then we mark it

1:14:47  
grey.

1:14:51  
Then the next time when we come back some of the blocks already marked black then you don't Go through there through these blocks again, to look at further references, we know, black means it was analysed already, we don't need to touch it anymore. This is done. And we only repeat the process for grey blocks. So the idea is grey are blocks that are in use. But from which we haven't yet analysed the further references, black blocks that are in use, but we've already dealt with references from that block further on as well to the finer form of

1:15:49  
bookkeeping.

1:15:50  
So eventually, when the mark face is done, everything is white, blue or black, then you do the sweep sweep gets rid of the black and everything is white or blue. Again. Okay, so that was the explanation. I encourage you to go through this independently read everything in detail with the lecture attendance here is not great. I was listening for this alone. So this doesn't motivate me to prepare slides. I've read the book. I also encourage you to read the book read the blue read the book, also check the list see abstract syntax and the compilation to understand what is going on and to check the garbage collection collector. And and then in the last lecture I'm I mentioned I go through the rest of the last lecture. I'll revisit some topics and we discussed we discussed the format of the exam.

1:17:13  
Okay, bye

Transcribed by https://otter.ai
4:40  
Hello

4:44  
you me

4:49  
very good.

4:51  
So good afternoon. This is the last lecture which is really not the lecture but kind of a recap. So let's talk about the eggs

5:00  
Sam, I also prepared a few things to go over

5:06  
that maybe you'd like to rehearse about, in particular lambda calculus and piping.

5:15  
So

5:17  
what is important, I prepared

5:23  
a little list for you about

5:28  
things to revise for the exam.

5:31  
So so first of all details of the exam, right, the exam is going to be three hours on Monday.

5:40  
I'm gonna set it up as, as a canvas,

5:45  
Canvas assignment, rather than a big exam, it's a fully open book thing, you can use whatever you want, but you should not communicate to each other.

5:55  
There will be a part with

6:01  
multiple choice questions or concepts. And then there will be free text questions, which are also

6:10  
for the largest part of them about concepts,

6:15  
maybe two or three problems

6:20  
that involve either understanding a bit of code or writing code.

6:26  
But these would be small things.

6:29  
The good thing about the home exam is that you can actually check these things.

6:35  
With with any interpreters, you don't write something that is that is completely wrong, or you can sort of self self test yourself.

6:45  
I've got a list from the teaching office about the number of students that there are a number of you that are entitled to a longer

6:56  
exam period. So instead of three hours, three hours and 45 minutes,

7:02  
I'll see how I set it up, I tried to do it so that

7:08  
it is saying it is assigned differently for you. So that you have a different deadline for for for sending in your solution to to Canvas. But if it doesn't properly work out,

7:21  
in the sense that I cannot separate the two groups the way that I want, then you'll just get extra time. And then you turn in the solution by email.

7:31  
After the zoom, sorry, after the canvas thing has closed, I'll write a clear instruction about this. So on Monday, you'll see which way it is

7:42  
and you don't have to worry about submitting at the right time.

7:47  
Is this

7:49  
clear? I may want to I may make the multiple choice part

7:58  
a separate assignment with with a separate shorter deadline something like 45 minutes out of the three hours

8:07  
then that would mean simply that you have to upload two different things

8:14  
or answer it in the quiz format, whichever way is the smallest

8:20  
here to set it up. So, here is the list of topics that I prepared these are on

8:30  
let me share my thing

8:36  
which would be this.

8:38  
So, I prepared a list of topics to revise to think of

8:45  
for the exam, especially on the level of concepts, you have to check the material of the lectures or better read the book.

8:56  
So, about F sharp, you will have to understand things like first order versus higher order functions will Pyro the rest means the idea that you can do two argument or in general multiple argument functions, either curried are encouraged to submit arguments, saying the two argument cases pairs or maybe one by one,

9:18  
recursion polymorphism. How do you work with a list type with the option type which has these tags,

9:27  
some none.

9:32  
Exceptions and references I won't really go deep into at all and you don't have to programme with them. Especially not with references, but you have to be able to understand code and understand the concepts. Then the main part of the course is basically in in three sections. So just basic expressions where you cannot even distinguish whether it's so functionary imperative setting, then split

10:00  
Specifically functional programming and then specifically imperative programming

10:06  
in the expressions part what is what is very important is

10:11  
well, the basic distinctions interpretation compilation lexing parsing for for syntactic pre processing,

10:20  
understand the

10:23  
the idea working with a stack,

10:26  
understand the idea of

10:29  
local scope or let blocks.

10:33  
So, the idea that you can have local variables and they can shadow out the less load local variables.

10:41  
And these are chapters two and three of the book. In functional programming, what is important you have to understand that you can define functions with LED but there are also these things called anonymous functions or lambdas.

10:54  
Very important for the processing a functional language is the concept of closure. So, when you process a function definition, you remember its definition in syntactic form together with whatever free variables that are in scope at the moment.

11:16  
The difference between static and dynamic scope role

11:21  
the idea of pipes and type inference versus programmer supplied pipes

11:28  
and the lambda calculus

11:32  
to the degree that we went through it, so, it's important to understand the concept of reducing lambda terms. Also the idea that

11:44  
lambda terms you can type either simply typed or polymorphically typed.

11:49  
There may be small problems on lambda calculus, you have to understand the important things that when you

11:57  
when you do computation with lambda terms, that then substitution is done properly is capture avoiding, so you don't get

12:06  
free variables bound by accident.

12:11  
And then from imperative language, what is important to understand is this idea of naive store.

12:19  
And to level stores where you map variables to locations and locations for the two values.

12:27  
Very important is the difference between

12:31  
expressions that have just our values. So, like three plus five only means a and other expressions like x or

12:42  
I don't know, the third element of x that actually also denote locations and that can occur to the left hand side of the assignment symbol.

12:51  
Regarding parameter passing to functions, it's important to understand the difference between call by value and call by reference.

12:59  
Regarding compilation

13:04  
it's important to understand the idea of frames for

13:09  
activating functions.

13:14  
And then the last topic was

13:18  
was heap allocation

13:21  
and automatic garbage collection through one you should know the notions of what is the heap

13:28  
free list and the main methods of garbage collection that I should say are the main main things and this corresponds to chapters.

13:40  
Well, Chapter One is really an introduction, but chapters two to 10 of the book, there are more chapters in the book please I will touch also in chapters

13:52  
two and three, and in some later chapters as well, every now and then, the book talks about

14:01  
lexer generation and parser generation but this was not covered in the lectures at all. So we I showed you some handcrafted lecture and the handcrafted parser. But I didn't tell you about the automated Lex Lexa generation or passage generation. So these ones are outside

14:19  
the scope I won't cover them

14:23  
in the exam. So

14:26  
let me know switch and show you how last year's exam look like.

14:44  
So here's the last year exam that I posted.

14:49  
When I first uploaded the file there was there were two silly types typos in the first two problems which came from my experimenting with colouring the right

15:00  
answers but no, they, I corrected them on the same day. So they are correct there. So these are sort of typical examples of what multiple choice questions could be about. They're really about

15:14  
concepts and principles, they don't go deep.

15:18  
They they test the understanding of the subject like, there is the big difference, for example, between statements and expressions that you have in both functional and imperative programming. In imperative programming statements, or commands are the main syntactic category in functional programming expressions are the main one.

15:39  
And the statements are the guys that essentially are not supposed to return anything, but they typically produce a side effect like changing the memory. Whereas expressions are things that normally don't produce side effects.

15:55  
So they don't normally read or write the store, although they may, but the main their main purpose is to return a value and the question is, what is more primitive computing values or changing changing memory and depending on that, you you're organised the language imperative programming is all about changing the memory functional programming is all about

16:15  
expressions that return values. So similarly, I could I could ask what is the difference between a list and a tuple. So lists are homogenous, they collect values of the same type, there is no restriction on the length normally, whereas a tuple is a thing of a fixed length like a three tuple or, or the tuple of In other words, or a pair or a two tuple.

16:41  
But

16:43  
elements can be of different types. So lists, the correct answer is B. tuples, would be the correct answer would be, etc. So

16:53  
there are basic questions about like interpretation versus compilation that could be about

16:59  
L and R values that could be about difference between say lexing and parsing,

17:08  
conventions about, say, compiling code to stack, like you expect that the statement, or a command doesn't change the stack height. Whereas an expression is supposed to return a value on top of the stack and grow its height by one, two, here a is the correct answer.

17:34  
Yeah, and they are really similar. You can go through them one by one I.

17:38  
Of course, there is no promise, I'd ask exactly the same question. But there is a spirit of

17:48  
I don't like tricks. So the exam will contain no tricks. But this doesn't mean that you should Google for answers, you should really think.

17:56  
And

17:58  
the really important thing is to

18:02  
read the question correctly, not, you know, not too shallow, so that you have some impression what the question is about, but you miss an important keyword in the question. That would be sad, because

18:16  
that will have a bad effect on on the correctness of the answer.

18:22  
Then

18:24  
the free text questions here,

18:28  
you will have to write something. In this particular exam, there were

18:33  
three cases

18:37  
where one had to write some code.

18:41  
The code would always be very small, like maybe sometimes just one line, or maybe sometimes five lines here. The same thing can also be written in four lines. If you do it more thoughtfully.

18:55  
There could be questions about is something a correct type for something? Or what is the correct type of something?

19:07  
I might ask some little thing about

19:13  
lexing or parsing

19:16  
them. So in this particular example, sorry, exam, there were two questions on this general topic. Like one was to understand how

19:31  
precedent precedences between operators work. So if I tell you one operator is stronger than the other, and maybe they have certain associations, how do you then read this thing? Where do you put the parentheses and here is the correct answer.

19:50  
So there was also

19:53  
an example about parsing where there is a little grammar of expressions and just to test

20:00  
to parse this expression

20:02  
as an expression.

20:07  
In the past three, you will have the different other kinds of syntactic categories there are there are parts of this string that actually correspond to summons and factors. And the question here was to just find out in this grammar, so what will be what So C is obviously a summon.

20:26  
And this whole thing is a summoned because the whole thing is a big sum. But also, everything in parentheses will have to be an expression, because the way that you process parentheses are goes via this

20:40  
rule of the grammar.

20:43  
So, this thing here, like the top level expression is also an expression and therefore,

20:50  
a and seven, the eight are actually summons as a result.

20:57  
And they will show up here

21:00  
maybe some things having to do with excuse me, yeah, sure. Isn't there a common mission in the last line?

21:11  
Oh, indeed, yes, here there is a common missing thanks, I can fix that.

21:15  
Very good observation.

21:21  
So there could be little things trying to understand what something does I mean, not not, not, not the real computation. But in this exam, the question was to understand what happens here.

21:34  
And then

21:39  
here, since Obama

21:45  
continues not to show everything at once. In this example,

21:53  
there is a function call

21:56  
where the function involves a free variable. And now, you know,

22:05  
most tools yours static scope rule, which say, if you've got a free variable that has already have to be in the scope at the moment when you make the function definition, and then the correct

22:20  
variable

22:22  
you should have in mind, so here in this particular case, definition, x is 70.

22:26  
But it's also possible that you want to

22:30  
consider this under the dynamic scope rule, and then it's different. So then it's not the function definition side, but the call side that matters.

22:38  
And in the call side, this occurs in a block where x is locally defined, and shadows out the the x that is further out. So instead, you would use 42.

22:58  
This problem here was really a way to test if you understand closures.

23:04  
And the say, next problem is on the same topic, there can be little things about lambda calculus, I

23:12  
promise only keep these small, because it's easy to earn simply

23:19  
in a

23:21  
you know, in a jungle of parentheses, otherwise,

23:25  
even though nothing deep is going on. And here there was a little problem about understanding how reference is also known as as pointers work

23:37  
the exam will be roughly the same size

23:43  
and

23:45  
not more complex than So, also not more, not more, not much simpler than so

23:55  
used this.

23:58  
Clear, would you like to go me to go through some particular thing here.

24:05  
Otherwise, I thought

24:09  
I would perhaps repeat a few examples from from lambda calculus with a blog post.

24:41  
Share.

24:52  
Okay,

24:54  
so let's do some lambda.

25:00  
All

25:13  
right.

25:17  
So in lambda calculus, the interesting questions will be to understand how reduction that is to say simplification of, of lambda terms works.

25:30  
I could also specifically ask about substitution, which is, which is a thing that you need in simplification, but it's not an important thing on its own.

25:41  
And there could be something about

25:46  
types. So let's take,

25:49  
let's do some examples.

25:53  
I want to look at this term.

26:19  
So let me first remind you what the rules of association are here.

26:24  
So you don't make mistakes in that regard. So for lambda, the rule is always lambda extends as far as it can to the right. So when you So here, for example, there is this lambda Zed lambda abstraction. So after the dot, you can go as far as you can, to the right until the first closing parentheses

26:51  
that was not opened in this lambda term. So as

26:56  
at the moment when you hit a closing parentheses,

27:00  
which doesn't belong to the same term, then this is the end of the of the lambda abstraction. So here there is no sipes, I mean, there is a pair of parentheses, but they belong together. And the the left parenthesis here,

27:16  
this one

27:24  
already is part of the lambda term, so the the right parenthesis, okay, so everything belongs here. And the lambda y here similarly spends the whole thing.

27:35  
And likewise, the lambda x here spends the whole thing. So that's not particularly interesting or complicated on this example, but we'll see from some others.

27:48  
How about applications application associates to the left? So

27:58  
here, we see three things in a row. Like we see hex zet. Why apply to that? And the question is,

28:09  
what is applied to what here, but application associates to the left, so that really means that the missing parentheses

28:20  
are sort of morally here.

28:26  
And they are not in the other place.

28:35  
So the missing parentheses are not

28:39  
here.

28:42  
It's not like you're applying that to Y to that

28:46  
and then X to it, that's wrong.

28:50  
What is done here is we apply X to that and the result is applied to white to white

29:01  
noise on the screen.

29:10  
Okay.

29:15  
Now, let's, let's do some exercises about it by the way of simplification. So,

29:22  
let me call it s the whole term here.

29:27  
Simply to write less,

29:29  
I could be interested in for example, the following simplifications. I could be interested in applying s to

29:43  
be applied to W.

29:47  
Or I could be interested in applying s two V

29:52  
and two W and these are two different things because in the second case

30:00  
What is really kept in mind, but not written is to implicit parentheses here. That's because

30:06  
it's clear that we have got two applications in a row. But we don't know in which order we have to do the application. So then

30:13  
the left one has the stronger precedence and the right one has the has the weaker precedent. So first S is applied to me. And then the result is applied to W. And if instead I want to apply the V to W, then I should rather

30:32  
put it in the parentheses explicitly like here.

30:38  
But now we can we can deal with both and see what we get.

30:44  
So in the first case,

30:52  
let me spell it out fully. So we can see what is going on.

30:57  
This is our picture. And now the whole thing is applied to be W.

31:04  
So what is the rule of simplification, there is only one that is important.

31:23  
Yes,

31:25  
there is only one rule that is important, which is the one that says if I've got

31:32  
a lambda term like this lambda x dot t,

31:36  
and I apply it to you, this should simplify to you.

31:42  
Sorry, to

31:48  
where I've replaced every free occurrence of x with you.

31:53  
And you can apply this rule

31:56  
not only top level, but anywhere inside your given term.

32:02  
And the intuition is lambda x dot t is just the lambda calculus way of stating anonymous functions is a function whose return value is described by T, the T may contain x's and x is the parameter. And when you actually make a function call application is making calls, then, you put the

32:26  
what people call the argument or the actual parameter instead of the parameter or what those would be to call the formal parameter. So instead of x, we put you

32:35  
that's what is done. And it's only the three axes that you actually can replace,

32:47  
we only substitute you

32:51  
for free x.

32:56  
Moreover, the substitution has to be done such that there is no capture. So there may be free variables in you that if you do the substitution naively get bound in T, and that is not allowed.

33:11  
So then you have to do some reading first.

33:30  
Okay, let's let's do the example. So

33:34  
the term here is exactly the correct shape,

33:39  
like this, so the simplification applies straight away.

33:45  
So what do we need to do? We have here a function whose formal parameter is x, and the argument or the actual parameter in the application is V applied to W. So we have to put v apply to W instead of x at all occurrences of x. And here there is exactly one. So the result is straightforwardly lambda y, lambda Zed,

34:13  
v w goes in place of x,

34:19  
then applied to Zed, then applied the white to Zed.

34:26  
And actually,

34:28  
this pair of parentheses here is not needed. Because our precedence rules say, we may just as well not write it. So it's also okay to drop it now.

34:56  
Okay, and that is actually not the result because

35:00  
We are no longer in the situation where we would have a lambda abstraction applied to something. Because

35:09  
this inner lambda abstraction upon lambda Zed law is not applied to anything. This lambda,

35:18  
you know, its scope is until the end of the expression. And similarly here, this one is not applied to anything. So that is actually the, the the end result here and nothing else happens.

35:30  
How about the second example that looks very similar? It looks similar, but it's quite different.

35:37  
So, let's do that too. So,

35:42  
this piece

35:45  
is come here.

36:02  
Yes, go away,

36:04  
slowly in combination with

36:21  
I apply S to V and then to w.

36:27  
So, now, it looks very similar, but the picture is quite different.

36:41  
This whole thing is applied to VI. And the result is applied to W.

36:48  
And let me remind you, there are implicit parentheses here that we don't need to write.

36:54  
But they are here like they were here.

37:03  
Okay.

37:04  
Now, actually, there is a bit more simplification that we can do.

37:14  
So, what happens?

37:21  
So what is the structure of the term given to us, we've got one lambda abstraction applied to V, and the result is applied to w. So, the top level thing is not a lambda abstraction applied to something, the top level thing is, is an application applied to something else, it's an application of a big thing applied to me, in turn apply to W. But the big thing apply to V is of the right form it's

37:48  
assisting here.

37:51  
Right? So therefore,

37:56  
we can use the rule. And what does it say the formal parameter or depending on your way of speech, the formal parameter or parameter parameter is x, then the actual parameter or argument is V. So v goes for x. So let's let's make this move

38:16  
lambda y length reserved

38:19  
V for x,

38:21  
y, Zed.

38:24  
But still, we have to take care of the application to W, which we haven't yet done. So now this is the situation in which we are

38:34  
after one first step.

38:36  
And now on the top level, we are in the situation where I've got a lambda abstraction applied to something. And the rule applies here on the top level. Now, who is who, why is the formal parameter W. Now in this case,

38:55  
is the actual parameter or argument so that means w goes for needs to go for y, and then the result will be

39:07  
and then visit

39:10  
visa

39:13  
W.

39:19  
And we're stuck here because the whole thing is a lambda abstraction is not applied to anything. So this is the normal form. This is the final form that we can reach with this term.

39:31  
Now, these two examples were nice in that we didn't ever have to have to worry about capture or renaming. Why didn't we? Because essentially, we never tried. I mean, the variables were already sufficiently named apart, right? So in the first case, we were putting v apply to W for x in a big term and neither v

40:00  
Or w occurred, bound, for example, in that term, so there was no danger of us actually

40:13  
capturing

40:16  
a free variable, sort of by accident illegally. And the same actually occurred in the second case, because here we had VW as well, while the parent visitation was different, but but we is substituted for x in a term that doesn't contain that doesn't bind V, and, and, and the same for W. So that was all nice. But let me just for comparison, put here on the same page, an example where things are not as easy.

40:58  
So let's do a variation on exactly the same theme. So maybe I'd like to do s apply to,

41:09  
shall we say y apply to set?

41:20  
Okay. So S is just a name is an abbreviation for for an actual lambda term. So for us to see everything very clearly, let me write out this again.

41:39  
This is one big lambda term. And we want to apply to Weiser.

41:44  
So this wants to be very similar to the first example. But now

41:50  
we've used less letters for our variables, and there is already some danger for clashes lurking. Because for example, when you look at the y's, their usages in the term that y is in two places.

42:12  
The first one here, this one is bound by this lambda.

42:17  
The second way This one

42:19  
is free, is not bound by anything.

42:23  
Okay, so this has now of course effects when we actually want to do the simplification, which would be to do what?

42:37  
What would be my first step of simplification, actually, the only one that I can do here anyway, is to replace x with y Zed in the lambda term, and of course, then remove this prefix lambda x.

42:51  
So I have to make

42:57  
a substitution of y's that for x.

43:01  
But what y and Zed are these, these are the three top level three y and Zed.

43:06  
If I put them in the place of x, which actually is here,

43:12  
then they will get bound by the two lambdas that are here.

43:18  
This one and this one.

43:22  
So that's not good. This is exactly what is called capture something that is that is free.

43:30  
And should mean something for us on the top level of the term would,

43:38  
we'd get mixed up with something that was entirely local, namely, these y and Zed here in the lambda term. So what are you supposed to do in this case is, well, we can't,

43:51  
we can't begin with simplification, we actually have to replace the term with what is called equal but more more precisely alpha convertible version of it, where we've renamed some bound variables.

44:07  
And you can always freely remain renamed bound variables,

44:14  
provided you don't create

44:17  
further captures by this, but here, the only ones that matter are the bindings of y and Zed. So let's rename them into something different.

44:27  
So let me write lambda x,

44:31  
lambda y prime

44:33  
numbers a prime. So I've decided that instead of using y as the local name, I'm using y prime instead of using Zed as the local name, I'm using Zed prime.

44:43  
And then accordingly, the body of all these lambdas would be x zero prime, y prime z prime, this is what it is.

44:54  
And then in here,

44:57  
sorry, this term, we want to apply to y Zed.

45:00  
Let's hope that we are now in a better shape. Now, if now I'm gonna put y Zed for x

45:11  
in the body of this lambda x thing here, which is here.

45:16  
This is contains exactly one fee occurrence of x, which is this point. And now this x, if I were, if I were to move, why is that there, which I'm going to do in a sec, then

45:30  
they do not get

45:32  
the y and Zed do not get bound by accident. So this will be a good thing to do. And the result will be

45:40  
lambda, y prime, lambda Zed prime,

45:45  
then why is that is for x,

45:50  
then Zed prime, y prime z prime,

45:55  
like this. And,

45:58  
again, the association rules are there. So

46:04  
I can actually drop a pair of parentheses here,

46:08  
which would be those.

46:21  
Okay, this is the final result.

46:24  
And if you compare it to what we saw before, this one here,

46:30  
it is a bit different, right? Because

46:34  
we had to be able to, to refer to these wines that that are globally free. So therefore, we don't have the luxury that we had here.

46:44  
That we can use the names y and Zed as local, local names. Yeah, we needed really to rename the local variable. Is this clear? Or does it raise questions? I have some more examples that we could look at. But

47:00  
can you tell me if this is

47:04  
fine by you?

47:11  
Okay, just shout when there is something, let me let me show you a slightly different example more involved, just to illustrate the exact same ideas,

47:22  
then we can think of we can proceed.

47:28  
So here's one,

47:31  
which has a tiny bit more interesting structure. So we've got lambda x.

47:39  
And then

47:41  
lambda y, and why acts like this.

47:52  
Reply to

47:54  
numbers that

47:59  
closing parentheses, applied to, shall we say why?

48:11  
Now this is a tiny bit more interesting situation, because

48:16  
we've got more lambda abstractions here, and they are nested in each other in more interesting ways. So let's look where they are. So one is here, lambda y. And the body of the lambda abstraction is this bit, right. And then there is lambda that the body is partisan.

48:32  
And then finally, there is lambda x.

48:36  
And now what's the scope of this, this is an illustration of this principle that lambda extends as far as possible,

48:45  
until you meet until the very end of the term or until you meet an unmatched closing parentheses. So here I can go this far. And then I have to stop because there is a closing parentheses that was not studied within this ambetter right. So this is the outer lambda.

49:04  
And now we are in a situation where there is two ways that I could start

49:10  
simplifying it

49:12  
because I can do the sort of outermost strategy or innermost strategy and by the rules of lambda calculus, this will take me to the same place unless I have side effects like printing or so they don't have here.

49:28  
So we could try both and see what what happens.

49:40  
So we could do inner most.

49:45  
First.

49:48  
We're okay most

49:52  
first, wind can also be

49:56  
right axes that are on the same level then you also have to say left to right.

50:00  
First, I always mean Left, left most. So left, mostly normals are left most often most.

50:07  
So here are the two strategies.

50:12  
So which are the red axes here? One is the whole thing. That's the outermost one.

50:21  
Because it's a big lambda apply to why.

50:26  
But inside I have another one, which is this, which is the body of the alter lambda, namely this guy here.

50:34  
Yeah, because it's, it's a lambda thingie lambda y y, y x applied to something namely lambda that.

50:44  
So the big one is the outermost one to touch the small one is the innermost and there is no other candidate for innermost because

50:54  
this one here lambda says that this is not apply to anything. So that one is not

51:02  
useful as as as a red X or as part of a red X. Let's do the innermost being and most has

51:12  
lambda y,

51:15  
y x as the function and lambda Zed Zed Zed as the argument or actual parameter, the formal parameter of the function is, is y, so we have to replace y with lambda Zed, Zed, Zed,

51:29  
and that will be it. So we'll get as a result lambda Zed,

51:35  
then we replace y with lambdas. That's what we get when

51:43  
applied to x.

51:55  
The whole thing applied to why this is what you get.

52:02  
So where did I start, I started here, let the market begin, I started here.

52:08  
And this bit got simplified to this.

52:13  
lambda y is gone. And for y, I've put lambda Zed Zed Zed index is still there.

52:20  
So it's the body of the function that we had previously. So the body was here.

52:26  
And in this body, I've replaced y, which is the formal parameter with lambdas.

52:32  
So now, actually, I have a red X again, actually, I have still two. So I've got one inside, which is these lambdas that apply to x. And the Ultraman is lambdas, that blah, blah, applied to y. So again, we do the innermost first two, I just continue with the same, although I could switch down to both now, but but that's not. So let's continue in our most and why is that first lamp

53:02  
set not x.

53:05  
Well, this one here, this is a very good observation, this is just copying mistake, this is what has to be the same Of course, the lambda y is gone, right? Because that was the that was the formal parameter of the function that was called on lambdas, etc. Okay.

53:25  
Now, what should the inner one then do? Well, what is happening here,

53:31  
so the function is lambdas, that were that that is the body so this is what is returned, and that is the formal parameter. And now for the formal parameter, we put the argument that will people also call the action parameter. So x goes for that.

53:47  
And we do get

53:50  
lambda x, x x

53:54  
applied to y.

53:57  
And it's also easy to see what happens one. Now again, we've got a function applied to an argument x is the formal parameter y is the argument we actually parameter. So y goes for

54:12  
x

54:16  
Okay, I could have started at the other end to see if this gives the same result.

54:22  
So here,

54:25  
we should have started

54:28  
with a whole thing as the as the red X. So the function is lambda x blah, blah. And the the argument or the actual parameter is y. So y should go

54:42  
in place of x,

54:44  
aha, but that is a bit dangerous, because where is x?

54:49  
x is here.

54:53  
But this is

54:57  
in a context that binds y

55:00  
Don't want to put why there. So that's very bad, because I will have my free why the top level why that gets then confused with a local why if I do this, so we can't really afford this at all. So really, we should do some renaming here.

55:19  
So let me first rewrite it,

55:22  
like the equal term

55:24  
is just the one where I've renamed one suitably.

55:28  
And that will be

55:32  
lambda x, lambda y prime. But you can also put any other name prefix picks

55:48  
the whole thing of like the why.

55:51  
Now I'm in a slightly better shape. So I'm not in danger of mixing up

55:57  
the two different scopes for y, I mean, the top level y and the local y are not going to be confused by this move, which I want to do. So y goes for x, and then I do get lambda y prime, y prime y, blank lambda Zed,

56:30  
then we're doing the outermost strategy. But actually here, it doesn't matter because there is only one thing that we can currently do.

56:40  
Because lambda y prime is part of a red X, and we look at the function applied to something but lambda said that this is not part. In that sense. I mean, we were not applying the function lambdas of block or anything. So we need to work with this whole thing here

56:57  
and replace y prime with

57:03  
lambdas.

57:13  
I'd like to why. And then

57:17  
it looks different from the penultimate step in the other production sequence. And it is because things happened in a slightly different order. So we've dispensed with

57:27  
bound variables,

57:30  
Zed and x in a different order.

57:33  
But the end result is going to be exactly the same.

57:47  
Okay.

57:49  
And these are two of

57:51  
the possible simplification sequences or reduction sequences that you can carry out here, which were sort of implemented by this pure strategy by their innermost first throughout our outermost first throat, but of course, because we would have switched on the way So, in the end, actually, there are four different ways that you could have arrived on the same result like I could have done the innermost first first

58:14  
and then maybe switch to outermost first

58:17  
and then continue. And there is a similar story here, I could have done the outermost first here, but then switched to the innermost first idea and Oh, forget it before combination, but it really doesn't matter. In the exam I may tell you well, please use one fixed strategy, what corresponds to languages like we looked which are called call by value is the is the one where you are in this is more deeply than so but, but on the level that you need to understand it corresponds to doing things. innermost first.

58:52  
Does it make sense?

59:04  
Perhaps I should also show some little things about

59:09  
typing

1:00:31  
So I'd like to look at the following one.

1:00:37  
So let's do type checking rather than inference, I'll tell you what the type is. And then we can, we can try to verify whether this is

1:00:47  
indeed,

1:00:49  
correct.

1:01:24  
claim this is the following type, I'll just use capital letters for

1:01:32  
for four types here

1:01:35  
are sort of schematic five variables, they could be anything.

1:01:41  
So this one is like this

1:02:05  
may look a bit complicated. But But what is happening, so the whole thing

1:02:12  
is a big lambda term.

1:02:15  
And you can see it's a sequence of lambdas in a row. So this is this idea of, of curried functions. Really, in some sense, we are dealing with a for place or for argument function here. But but the arguments are given one by one. So which you can also see here in the type. So there will be one argument corresponding to type A, another argument has to be of this type, a third of this type and the fourth of this type. And the result we claim here is of type A, which happens to be the same type as the type of the first

1:02:49  
argument, right. And I might want to know why this is why this is correct, why we can apply everything exactly in the ways that we

1:02:59  
expect.

1:03:03  
So let's see, we have these rules, that allowed us to check types.

1:03:20  
So I want to prove such a thing,

1:03:31  
which is a formal way of writing down

1:03:36  
something that also intuitively makes sense with checking all the lambdas whether they are functions of the correct type, and we're checking if if all our applications of this was not straight.

1:03:48  
We also want to check if if our applications are reasonable.

1:03:58  
So, what is required for a function lambda x block to be of this time, we really need to check that if we assume that x is of type A, that then the rest of the term which is the body of this abstraction

1:04:15  
is of the correct type.

1:04:17  
Namely this

1:04:21  
and then because of the structure of this term, we will repeat the same exercise a few times

1:04:26  
before we see if this works.

1:04:29  
So what is the term I'm looking at now it's again the lambda lambda f and then the body. Well, for this thing to be a function type like this, I have to check if f has type B airway airway does the body have type B arrow B arrow a

1:04:49  
introducing is to see if excess type A and as tight as we said

1:04:58  
your way right

1:05:02  
Is it true that the body which now is lambda y, lambda Zed

1:05:07  
have Y and Zed x? Does it have time the arrow?

1:05:16  
Well, it's still the same gain points, because we've got two more parameters here to deal with in lambdas. So let's check that under the assumption x is in type A, and f is in type B arrow a. away.

1:05:33  
And y in type B, is it really the case that lambdas that f y, Zed x is of type

1:05:45  
B away?

1:05:48  
Well, this depends on if the last function that we're trying to type here has the correct type. So for input, type B,

1:06:00  
sorry, for

1:06:02  
under the assumption that Zed has the correct input type B, we need to check that the what the function returns which is the body as the type the return type A.

1:06:31  
Oh, okay.

1:06:34  
Sorry,

1:06:37  
that went too fast, like this. Um,

1:06:43  
well, let's see, let me give this thing a name.

1:06:47  
The context that we have here, could be called the whole thing gamma,

1:06:52  
that actually also delete all of this, because I don't need it anymore here.

1:07:05  
So this is an application

1:07:08  
F, applied to y is applied to F at X.

1:07:19  
So in the context, gamma, we have two type f applied to y in some way, and we also have to type

1:07:31  
the text in some way that actually fits together.

1:07:39  
Now, what do I have to write this types? So?

1:07:47  
Well, I better be in the situation where the function gives me something of type A, and here I don't know what to put here.

1:07:56  
But, the argument

1:07:59  
supplied to the function has of course, to agree with the input type of the function, so that the total currency is a question mark here should should really be the same type.

1:08:12  
So maybe we can check a bit.

1:08:21  
So, what's the situation here, if is applied to y, we actually know the type of F this is b arrow a arrow a, and we also know the type of y which is B. So reasonably the result that we get here should be a airway.

1:08:41  
Just looking a bit the head

1:08:44  
and formally we can complete this by saying look in the context gamma we very well know that f is of type

1:08:51  
era airway

1:08:54  
and y is of type B. So, therefore, we are entitled to conclude that f of y in this situation is of type A airway these two are just actions because

1:09:07  
all we are doing is we are using the knowledge that we have in this context gamma about F and why Okay, so the question mark was was

1:09:17  
was a swan better check that everything is here as well, good here as well.

1:09:27  
So, I need this and this again is an application. So in gamma, I have to give some time to upset

1:09:36  
and in gamma, I have to give some time to x. But actually, we know what the type of x is the type of x is a.

1:09:46  
So therefore, f apply to that has to be of type a way for this application to be well typed at all. And then

1:09:56  
what do we know here? We know that gamma

1:10:00  
says f has type B arrow, a ray.

1:10:08  
And gamma also says that has type three,

1:10:13  
type B.

1:10:16  
And these two together give us that F applied to set is the correct way

1:10:27  
to learn.

1:10:30  
Okay. And this is then foolproof. But in the end, what did we do all we all that I played with was I was, I was applying the lambda calculus rules that tell me how things work. So let me record for you what they were. So I'm entitled to say that

1:10:51  
in context gamma x has is of type A, it's actually this is part of the of the context gamma. So if you've gamma contains this knowledge, then I'm allowed to use it, this is how I finish a derivation.

1:11:05  
For lambda, what is the trick? If I want to prove that some term key sorry that some term x, lambda x to T has type A or ob, this is only justified if in the context gamma extended with the knowledge that x is of type A, I can prove the T is of type T. So this is checking that

1:11:33  
for a function to have type A arrows B, I can really deduce that the body has the return type under the assumption that the argument is or that the parameter has the correct type. And then for application, we have the rule that says

1:11:52  
you have to be in the same context is of type a aerobie, for some a, and then you is of type A, so it's a good application. So in a function application, the main thing to ensure is that the input type of the function agrees with the type of the argument

1:12:13  
when we see it.

1:12:15  
That was too hasty writing this because I also want to fit in the gamma

1:12:20  
in the context cannot be proven.

1:12:29  
This is how to do these things.

1:12:42  
This makes sense.

1:12:45  
I did this very slow. But I also hope sort of sufficiently carefully. I'm

1:12:55  
sorry, quit this exercise be on the exam.

1:13:01  
Maybe not as big but the smaller one could, in principle, be yes.

1:13:07  
So that you need to do a few steps in this in this type.

1:13:11  
type system.

1:13:18  
What is the format of what have

1:13:24  
you the basic format is you really, you just write something in a text file, like using a notepad or whatever text pad,

1:13:34  
if you feel that you need to draw, I will allow this as well. So I mean, you can you can take a picture of something.

1:13:44  
I've tried to minimise this.

1:13:47  
But this is the best I can do.

1:13:49  
So the important thing is that I understand what you've done has to be in a readable, readable format. But the main thing is to really upload the text file. I'm not a big fan of if you draw if you if you convert it into a

1:14:05  
doc or PDF, but but but that's also of course possible, but I don't want you to spend a lot of time on typesetting. So you should really

1:14:14  
if you want to sketch a drawing or maybe two or three like this, the best is you just attach

1:14:20  
you attach a photo so I make the upload sufficiently liberal for this.

1:14:27  
But the the absolute preference is just just plain text

1:14:32  
for most things at least.

1:14:36  
Okay, but sorry, in plain texts, like simple like that, to understand simple rhodos whatever. Yeah, yeah, I mean, then of course, I mean, if you if there is a problem like this, then then you have to come up with something I mean, for the for the turnstile, you'll probably do vertical bar minus and for an arrow you'll probably do minus and greater than, and you don't need so much more right and for lambda, you can just

1:15:00  
To a backslash. And if I put such a problem, I will, I will put some hint in the, in the text as well how to how to sort of show with easy. But anyway trees they do, they do get messy because you also have to indicate the branching structure in some way. And this can get messy to do in just imply that. On the other hand, if you if you use some drawing programme, you maybe spend too much time, I mean, if you're well versed in it, you're most welcome to do it.

1:15:26  
And, and that will be helpful. But I'll try to be reasonable in making things easy for you in the sense that you don't waste too much time of your solution time on typesetting things. But I also want things to be easy for us,

1:15:45  
to the degree possible to the degree to grave, and also so that

1:15:52  
you know there is no ambiguity in whatever you submitted.

1:15:57  
So that you mean one thing that we happen to read out, and

1:16:02  
that's always a tricky, tricky thing with these kind of

1:16:06  
home exams, which I really hate, but what can I do.

1:16:19  
But the main thing also having to do with like,

1:16:23  
cold understanding or, or, or writing a small snippet in code is you have to make yourself understood and we

1:16:33  
so

1:16:36  
if you are with some syntactic detail in an exam, it doesn't count, but the idea has to be right for you to get marks, like positive marks. And

1:16:48  
do they want to say

1:16:53  
no, I lost my train of thought.

1:17:01  
Yeah, when when when you have the feeling that something is,

1:17:07  
is understanding, maybe the little calculation, and there is the danger that you are with a particular number you write down, it's always good to write explanations.

1:17:18  
I mean, it can be a strategy to not write any explanations. So and guess the correct answer and just write down the answer. This can work with some problems in your favour. But then on the other hand, if you read the noise, and no explanation, and the answer is wrong, then you strictly get zero points. But if you if you have written a bit of explanation,

1:17:41  
and we see that explanation makes sense, but there is a typo in the final answer that you've given, then, of course, we are nice and give you You know, sometimes a good amount of mark for a problem. So my solution, my my, my suggestion is, if you understand the thing, then always

1:18:03  
say what you mean, like give explanations. On the other hand, there is a limit to this, right. So I mean, one other thing that that will upset every grader is

1:18:14  
if you don't know a solution, but you just write a long waffle.

1:18:19  
Hoping that the teacher will find something in the right direction in it and give points. So this may work in your favour. But it may also just upset the grade, the grade that especially if one spends a long time trying to find an idea and what was written. But if they're really in the end of the day is no idea. This, it doesn't work in your favour. So the usual sort of student

1:18:42  
things of course, apply here you have to be

1:18:48  
the best is if you know your thing. And if you want to be very strategic in how you write down answers. This

1:18:55  
may work

1:18:57  
against you if you overdo it, but if you do it sort of in good faith, and frankly and honestly, then, then writing explanations will work in your favour. But what else can I say?

1:19:11  
So in problems that certainly require explanations while I put it in the problem statement, you know, don't just give an answer but explain which means write one or two sentences. What is your argument while you think the answer is correct?

1:19:26  
There may be some cases where it's just a yes no answer or you know, give a particular number you don't need any explanation. Then that will be clear from the

1:19:49  
book. Okay. Is there something

1:19:58  
else

1:20:05  
If no then maybe I'd stop here. I'll put the lambda calculus things somewhere, some examples

1:20:15  
and then I wish you good luck.

Transcribed by https://otter.ai
3:40  
Hello

3:45  
welcome to this lecture

3:49  
Let me check that everything is well with a sound can some of you tell me that?

3:57  
You can hear me because I get some feedback but that cannot be fully Yes, yes.

4:03  
Okay, very good. So we can we can continue like last week if, in a live lecture if there is something the best is perhaps that you simply interrupt me and ask.

4:16  
While I'm not sharing the screen, it's easier for me to see raised hands while I'm sharing the screen both full screen because I have two windows and it's very difficult for me to notice hands.

4:30  
So what's the plan for today? Last week, we've covered what in F sharp, I gave you some very basics of the language

4:39  
on the first time and then in these pre recorded lectures for Thursday,

4:44  
I told you

4:46  
about lists in particular how you programme with lists using pattern matching and recursion, mostly recursion in various forms. We'll go back to this. I emphasise that some functions are polymorphic

5:00  
Like,

5:02  
finding out the length of a list works the same whichever type the list is over. So finding the length of a list of integers works exactly the same way as finding the length of a list of strings, or finding the length of a list of functions etc. So this was polymorphism, that you can have very general types, you just write the code once.

5:25  
xml will figure out sorry, F sharp will figure it out for you.

5:29  
That programme admits this very general type. And when you apply your function to give an argument, then based on which type of argument you've provided, the correct specialisation of the function is used.

5:44  
And then I also emphasise higher order functions, which means another kind of modularity mechanism or reuse mechanisms that the reason F sharp,

5:55  
high order functions mean functions can take other functions as arguments. And the way that you use it is

6:05  
if you find in your code, a pattern, where

6:11  
part of the

6:13  
code is changing, the rest is not.

6:16  
The part of the code that is changing from application to application is actually something that depends on some input, so it's a function, then you can actually produce a function that takes another function as input. So

6:30  
these different things that can be substituted to your code can be provided into your code can be provided as arguments. So what will happen today is I'll show you a tiny bit more about lists just to repeat, and emphasise some points regarding

6:48  
direct recursion versus tail recursion, and complexity issues. Then we look at user defined data types on two examples. One is trees. In particular, we do know trees, but you could also do leaf trees, you could do many other types of user defined data types. I'll also show you another type, which is more sort of a database nature, if you wish,

7:11  
a type of a person implemented as a data type.

7:16  
I'll tell you something about one specific data type option,

7:20  
which is actually provided to you in the basis environment of F sharp, this one is very useful

7:27  
to model

7:29  
functions that are not everywhere defined functions that are naturally partial, like maybe head and tail of list.

7:36  
Last time, we saw that head and tail, know as they are normally defined, can give you an error during the runtime because of a missing pattern, or incomplete pattern matching. But there is a different way where you do not get a runtime error. Or rather, you do get kind of an error, which officially is from the system point of view is not an error. And it's something that you can actually handle nicely. And then finally, I'll show you exceptions, which is like apart from incomplete pattern matches, and the option type a third way of dealing with special situations or undefined at best. So that's the plan for today.

8:16  
Any questions about this, then I'd like to go

8:21  
if this will be fine. One by one through the topics first one day an example of of, of lists.

8:28  
And then we talked about trees

8:32  
as a user defined data type and and person

8:36  
and some key programming and the option data type. Then finally, exceptions. Now I need to share my screen to make this work.

8:46  
Just a sec.

8:50  
I think I want to share

8:54  
all of this is that's good.

9:02  
Can someone tell me that you see it all? Well, including all lines like on the screen?

9:13  
So if you don't shout, I assume it's well, because now I can't see the chat anymore.

9:19  
That's good.

9:21  
So what kind of things would you

9:26  
deny the lower part of the beta or the video, I showed you things like putting two lists together by concatenation, which is also called append. I showed you a few other things like if you had a list of

9:40  
over some numerical type like integers, you might want to sum all elements of a list or maybe take the product of all elements of a list

9:48  
with something that works for all lists.

9:51  
List of any type three would be finding the length and then there were a few other examples

9:57  
and they also showed you some

10:02  
Some higher order functions in particular to that were called fold and fold back, that give you a very nice cryptic, concise way of writing down recursive definitions

10:13  
where the recursion actually is hidden into the higher order function.

10:18  
And

10:20  
what you seem to be seeing is kind of straight line code. But of course, the recursion is hidden then into one of these

10:29  
one of these combinators?

10:35  
Yes, let me do just to sort of repeat or rehearse a bit more on this to one more example of Lisp programming where I explain exactly these things.

10:45  
So

10:47  
I'd like in particular, be interested in defining the reverse function on lists. So the idea should be something like this that if you

10:59  
are asked to reverse a list, say

11:02  
379, perhaps

11:11  
the answer that should come come back should be 973. So the same elements in the opposite order.

11:21  
Sounds very simple.

11:25  
There are various ways that you could imagine that this kind of algorithm works.

11:32  
Maybe the one that is

11:34  
that is more customary to you from imperative programming would would essentially be a loop or a programme with an accumulator. You could think, for example, that you're sorting a pile of sheets of paper. So you've got a pile of paper on one side of you, and you just want to see the sheets in the opposite order. And the natural idea is to take from the top of one pile, you move to the other pile, then the next one, the next one, the next one,

12:04  
the first pile you had will be completely empty at the end, whereas the second one will contain all the all the paper that you've had, but in reverse order. So that works with accumulation. And we can actually write it down using using also the F sharp hydro function.

12:22  
Fold.

12:25  
But let's first try to do it with direct recursion. So let's just think of the problem of reversing a list.

12:34  
And I'd like to do it by recursion by just thinking of what cases do I have? Well, I have two cases, the list is either empty, or it's a cons list. And then what do I do in each case, and maybe in the cons case, I would like to reduce the problem of reversing the list to perhaps the problem of reversing its tail or some other smaller part of that list, right? If I do this, then I then I reduce my big problem into a smaller problem that in turn will reduce into a smaller problem that in turn into a yet smaller problem. And finally, the problem will go away. That's the idea of recursion, right? When you do it by structure, like getting smaller instruction. So let's think what a reasonable definition could be.

13:18  
I want to define this function in reverse this axes is my argument my parent, my parameter, which will take the actual argument values in parameter passing.

13:28  
First thing I want to do is to pattern match on on this axis. And actually I give two patterns here. One is this is empty. The other is we say this x is consists. It is a cons list, and it consists of a head and a tail.

13:45  
And for the tail, I use the same name axes. So this is now local scope here.

13:51  
This part where x and x these are the new local names. So this axes shadows out the outer axes, which was the whole list, this axis here is the day.

14:01  
Now, what's the empty list the other way around, it's still the empty list.

14:12  
What's the reverse of x followed by X's?

14:17  
Well, I want to reorder the list the first thing should be at the very end. The second thing should be penultimate, the third thing should be the third from the end, etc.

14:27  
So this x should go to the very end.

14:32  
What? Well, it suffices just to miraculously, already have the result from recursion of reversal of the tail, right? If I already have the tail turned all the way around. The only thing I need to do is to put x at the very end.

14:50  
I call this operation snop. It takes a list.

14:56  
A value sorry and produces a new list, with with with

15:00  
A new value at the end.

15:03  
How could you define snoc? Well, there is two ways. One is to use append, because knocking Why two axes is the same as x is concatenated, together with a singleton with a one element list consisting of just y. By the way, you eyes it comes knock, anyone guess you can just tell me

15:24  
read it out loud.

15:28  
It's called snuck because it's comes the other way around. So it's like,

15:33  
you add single elements to the list, but not from the front. But from the back.

15:40  
Yep.

15:44  
So there is something to think of here, causing an element to a list

15:50  
actually just takes constant time, because you've got the list, I think how this could possibly be implemented, your list is probably some some pointer data, structuring the memory. And then causing an element to it just means you you, you allocate a cell, where you put first of all the head and then a pointer to the rest of the list.

16:10  
So access to the front of the list is very quick. And adding one element to the front of the list also,

16:17  
is constant time.

16:20  
But this is a singly linked list from every element, you can navigate to the next one, but you can't go backward. Or you also do not have a random access to every element, you just have to walk through the whole list until you find your element. And you cannot in particular, approach your list from the end. So if you want to add an element at the end of the list, how much time is it going to take?

16:45  
Well, you have to walk through the whole list, and then put down your y at the end

16:51  
in the construction of an entirely new list, in fact,

16:54  
so the list is also copied, which is very bad.

16:58  
So this takes linear time, time linear in the size of axes, the time linear in the number of elements. Does that make sense?

17:08  
I can maybe also explain it by implementing snoc. differently, just implementing it directly. So how do I book why at the element of a list exists? What do I need to do?

17:20  
Well, I need to

17:25  
pattern match on axes. If x is empty,

17:30  
then all really I need is y. Yeah, that is the new list. If x is longer if it's something of the form x, and the new x is, which is the tail.

17:42  
What is my resulting list? Well, surely it begins with x. And the rest is just why it's not two x's.

17:51  
Here, and it's clear that to to calculate the result here, you have to walk through the whole list. Let me just check one thing quickly. We'll stop sharing for a moment.

18:06  
To be very sure. Yes. All as well.

18:13  
Okay, we're back here. So this is knocking. And whichever definition of soccer use, whether this one append, or what are this one, which is like

18:24  
implementation of snoc from scratch. But kind of the corresponding instance of a pen really, if you look into the code of a pen that has exactly the same pattern,

18:33  
then I can use knock. And this does my reverse.

18:39  
Let's for a moment think how this could possibly then execute. So we understand. So we're all on the same page about how this thing will come with ever compute. So suppose we want to compute exactly this.

18:57  
Actually, this is not the right number. The standard numbers are of course, 1742 and 2021.

19:06  
And then, how do you do such a thing? So what does the code say the code says,

19:14  
match this, this one is not empty. It's a cons list. So therefore, what I need to do is

19:21  
reverse

19:24  
42 2021

19:27  
and 17. Do you agree? Then in one step, this actually goes to stock

19:35  
stock.

19:38  
Reverse

19:42  
42

19:46  
what do I need to stock

19:53  
2021 close to 17 through CDs so

20:00  
Snap cannot run. This is a strict language, it cannot do anything before I evaluated my arguments. So I need to know what this is, we need to look up the definition of reverse and do some work here, the 17, there is nothing to compute, it's already computed as expression for something.

20:17  
And then there is this repeats one more time, I need to do snoc.

20:23  
Let me just first copy everything and then let me develop it.

20:27  
So we need to do all of this, but then we need to work a bit on reverse 42. So reverse 42 is going to be

20:35  
snoc of reverse.

20:38  
Empty

20:40  
42 on doing with parentheses

20:49  
here

20:53  
is that

20:55  
I can see something but not one. Two participants raised hand. Okay.

21:03  
Just the silly thing in this view is that I can't really see who raised hand. So can you just speak up the two of you? I would be happy to to explain.

21:14  
chenier heroes? Can you unmute yourself yourself?

21:19  
This is the funniest shed ever.

21:27  
Or I can test that Hitler did nothing wrong. Yep. Yo, and you should be able to speak Yeah. Hey, can you hear me now speaking?

21:41  
They don't have an idea. Yeah, yeah. I

21:46  
think oh, something bad is happening somebody already on your computer to see if I can fix it.

22:01  
This is very bad.

22:04  
Because I tested sound before starting.

22:10  
And everything was fine. And actually I had a similar problem yesterday and there is no good explanation for this.

22:36  
Okay.

22:39  
I fought quite a bit with this.

22:43  
Yes, yesterday and the similar thing happened.

22:50  
So why don't you Why don't you just put your two questions or three in the chat right now and I'll I'll I'll try to answer

23:30  
Thank you.

23:33  
Quickly go problems four or five, six from programmes one, maybe maybe not today because you'll have a look at those actually, or you can ask the TA is about those tomorrow. But I'll also be happy to touch upon them say on Thursday, if anything is unclear is Will that be fine.

23:53  
It's very important that you understand how these are solved. You will also get solutions from me

23:58  
after the lab classes tomorrow so

24:02  
you can also look at those but I will be happy to go through these regarding why I cannot hear you this is completely ridiculous because I can see the mic going up and you know that the mic, mic image working properly when you speak but I can't hear

24:19  
and the sound test the speaker test was fine. Just in the beginning of this session.

24:28  
My volume is not down. No, I tested it and the speaker spoke

24:35  
wrong output device most probably yes. But what can I do about it? Hardly anything.

24:45  
The speaker system is correct. So um, there's really very little I can do.

24:52  
Okay, um,

24:54  
I'll have to continue here but I'll try to keep an eye on this.

25:00  
All these hands in some way, there is very little I can do.

25:13  
Yes. Okay. share screen.

25:24  
Right? Where are we. So this is what is going to happen, there is only one last step to do reverse, reverse empty, just empty. So we get through some stages like this,

25:34  
isn't it?

25:40  
You see, so far, we haven't really computed a lot, but everything is kind of ready. Because now what we need to do is to put 42 at the end of Mt two to 2021, at the end of whatever we get, and 17 at the end of whatever we get then so it goes in small steps now, like, the entire thing goes to

26:03  
just 40.

26:06  
And then we get

26:08  
the next stage, we do get

26:15  
what do we get? We will get 42 followed by 2021.

26:21  
And then finally, we do get

26:24  
this,

26:26  
which is what we want.

26:33  
Yes.

26:35  
So it looks quite reasonable, it looks linear. But actually, it's not. For the stupid reason that while this stock goes quickly, yeah, I'm at the end, I'm just putting 42 there. Here, I walked through the list consisting of just 42, which is also kind of fine. Here, I need to put down 17. At the end of this thing, I have to walk through a list of links to

26:57  
if the list would be longer than the next page, I have to walk through three elements, then four elements, then five elements. So it's something like one plus two plus three plus dot dot dot plus n,

27:09  
which is size of order n squared. So this is quadratic complexity, not because so much of reverse, but because of this knock here, which is expensive for us to see this.

27:21  
But this is what the directly recursive programme that

27:25  
I told you last time that there is a concise way of,

27:35  
of writing down these direct recursions by basically capturing the pattern of what is happening, the base case and the recursive case, as arguments to a higher order function, fold back. So fallback is fundamentally for taking a list of A's into a B. So here, specifically, we take a list of A's back into a list of A's. So here's specifically B is also a list of A's but could be something else.

28:04  
Then this guy here is a gadget

28:07  
that we have to provide as an argument to fall back. And it's something

28:12  
that takes the current list head at which I'm looking for the you know, the head of the list and pattern matching against it takes the result of the recursive call

28:22  
and produces me produces for me the result of the main call.

28:29  
Yeah, what does it have to be in this particular case? Well, here the pattern is this. So from x, and from reverse x axis, which is the result of the recursive call, how do we put the result together? Well, we just snuck them.

28:44  
So in here, I needed to place curried function, I'll answer you in a sec, that takes

28:51  
an x, then a y's that stands for the result of the recursive code. And all I'm saying that in this case, corresponds, then to the second line here in the pattern match, all I need to do is to stock them together.

29:04  
This argument is the least that I'm actually reversing, and this argument. And for a particular funny design reason this is given as last year, not this is the second.

29:14  
This is what do I do in the empty case, and in the empty case, I just return empty. So this is an alternative definition and runs exactly the same way. So now I can reverse lists. So for example, I can reverse the list one to 10.

29:32  
And this is the list, and it's actually gonna be quite slow exactly because of this quadratic thing.

29:40  
Maybe in the video, I don't want to demonstrate how it slows down, but you will see when you try 1000 or so.

29:48  
Right? So

29:51  
this design is unfortunate here, not so much because it's a bad design, but because of the particularity of this function. So if you do bye

30:00  
recursion you indeed this auxiliary function snuck in that one is expensive is linear. So if you combine the linearity of snoc with with with the fact that reverse itself also goes through the list once, then you get square complexity.

30:16  
a completely different idea is to work with an accumulator. And that's also a nice occasion for me to show you how

30:26  
nested scopes work. But let me first check what the question was.

30:33  
Do I really have to stop sharing?

30:40  
Is the reverse outcome wrong? 1742 to 2021, reverse is blah, or am I losing it?

30:49  
Did I do something wrong?

30:59  
At which place? Did I make a mistake?

31:13  
That was correct.

31:24  
I'm making a mistake somewhere, right? Is it 2021 is here, here.

31:38  
The mistake is here. Sorry. No, I can see them.

31:45  
Thanks for spotting That was good.

31:50  
And now it's in an all these other places.

32:02  
I just wanted to step it for you. You also can do debugging like things here. And later, I'll show how to programme them. But the key here is just to really get the feeling but see the problem is I'm not as good as the computer.

32:17  
Let me share this with Id share

32:20  
of no fix this.

32:25  
So what's this better than mistake originally was around here. So here 42 and 22 to 2021. We're in the wrong order. And that then percolated rest. Yep. Very good that you noticed. Thank you.

32:42  
We can perhaps ask the machine to check to be sure.

32:49  
Yes.

32:52  
Now,

32:54  
here's a different way of doing it, as I said by an accumulator. And it's a good,

32:59  
good place for me to explain to you how also to work with local scope.

33:04  
So let me define reverse a four accumulator. So it's the same function, but just implement it slightly differently. And actually, with a better complexity here, in this case, just because of the particularity of the function,

33:18  
what I will do is, I will define reverse a,

33:23  
actually without using recursion, but I use a local function called reverse prime, which is defined recursively. See, the outer one here doesn't have rec, this one does have rec, I can of course, always put rec just in case. But you shouldn't really when the function is not recursive. Now, it's not a mistake to always say rec.

33:48  
So what's this reverse prime.

33:52  
Reverse prime takes two arguments, it takes one argument called act, another one called axes. So this one is the This one is the outermost axis, that's the one that I'm really taking care about. These axes here, I'm using

34:07  
reusing the name because I'm, I'm defining my local name, and this one will have its own parameters. So the scope of this exercise will be this part, which is the definition of reverse prime.

34:20  
And the idea here is, I want to define how to reverse a list exes. If I've already reversed something, I've already done part of the work. This is like when I move papers, pieces of paper sheets of paper from one pile to another.

34:38  
There is there, you know there is what's left over the original point. This will be x's in the recursive calls to this function. And there is what's already piled up in the new pine, this will be the act the accumulator. And the idea is when the original pine sort of has exhausted itself is empty.

34:58  
Then you just return the value.

35:00  
Have the accumulator, which means you've completed the reversal.

35:04  
Yeah.

35:08  
I'm using a slightly imperative explanation here because I'm saying there is a pile and this pile changes, and there is this other pile. And this also changes from the point of view of F sharp, it's not quite like this. It's more like, I call reverse with some act at some axes. And this results in a recursive call to reverse prime with some other act, and perhaps with different axes as well, well, here, the call is with this, and the video says to call this so let's see the cases.

35:38  
When I've been thinking productively here, because this is basically an implementation of a loop. When I've expired, sorry, exhausted my original pile, then everything is in the new pile and already reversed. Yep.

35:53  
If whatever is left of my original point,

36:04  
is,

36:10  
is is of the form head on Sunday, the head is x and detainees axes.

36:16  
Then what do I need to do? Well, I should, I should just repeat the procedure with some new parameters, or with some new arguments. So x axis is currently my sort of version of the original pile. Next time, it's actually so I'm removing one sheet from there, where do I put the sheet, I put it to the sheet of the new pile, the accumulating pile,

36:40  
and right now is at the top. But if I take more elements out of my original pile or list, more things will, will will, will we pile up on top of that? Yeah.

36:53  
And, and that's the definition of this function with the accumulator. And all that I need them to say, to complete the definition of the main function reverse a is to say,

37:06  
to get going, I have to take this auxiliary function reverse prime, and I have to apply to these two arguments, x is the least that I want to reverse. And mt is the original,

37:19  
or is the starting accumulating Pilar at the beginning in the new part, there is nothing.

37:26  
And mysteriously, this is nice, because it's happens to be linear here in this case, and the fundamental reason is, this programme needs snoc, to put something at the end of a list, which is expensive.

37:40  
This one uses comes to something at the beginning of the list, which takes just constant time. And then the whole programme, reverse a is linear, also reverse prime is linear. In the given list, reverse prime is linear in the sum of the two given list.

38:01  
This true,

38:03  
no, just just a second list,

38:06  
right, similar to how you could code direct recursion with fold back, you can code this thing, which is tail recursion with fold.

38:17  
And fold takes, again, a number of arguments, fundamentally, I'm trying to send a list of these into a B. Here B is also a list of A's. And these are the two cages that are used to do this two bits of information.

38:31  
B here you have to think of as the return value, but it's the same thing as the value of the accumulator, or the type of the accumulator. Sorry. So initially, it's empty. And the thing that we need to do at the recursive step to to produce the new accumulator is is is basically just cons. Yep.

38:56  
Huh, can we execute this one as well, I'm afraid I have to do this. But this will be the last thing that I will do in this class, sort of so explicitly. Let me see what that can be used hardly anything I suppose.

39:14  
What's happening?

39:18  
We're seeing this list.

39:22  
With reverse a.

39:26  
Well, first of all,

39:28  
it all reduced, it's actually not using diversity anymore. That's when it's not recursive. We will do it with the reverse prime. And we use it with these two arguments.

39:40  
Now, this is kind of our original pile of sheets, and we will gradually move things over here. So to say,

39:47  
in kind of imperative thinking, this these are the two variables that will change in our loop. Here nothing changes. We just make new recursive calls with new arguments.

39:56  
Let's see what happens. So

40:02  
The pattern match always, when you have a call of reverse prime is on the second argument, which here is this thing. So this one is of the form x axis,

40:14  
which means that I have to

40:19  
the whole thing reduces to reverse prime of,

40:24  
maybe I should make it

40:26  
sort of very explicit, I have to put 17 at the beginning

40:31  
of the original accumulator, which is this, right. And what is left is 42 2021. Yep.

40:41  
And then the next stage,

40:45  
I still pattern match on this one, it's still a conscious thing. And it said 42, we'll move to the beginning.

40:54  
So you get this.

41:06  
And then I have to make a pattern match on this one. And this one is actually of the form to 2021 followed by empty. So the remainder is empty, or the tail is empty. But I need to put 2021 in front of this thing.

41:24  
Now, I'm in the interesting case, where x is in my neck in my new recursive call to reverse prime is empty, which means that the recursion is finished here. I'm at the base case. And I just have to return the accumulator, which currently is

41:42  
the correct thing.

41:47  
I've written in the different syntax, but that's just the same as 2021 42.

41:57  
Let me check how you're doing.

42:07  
Yes. Any questions or any discussion here?

42:13  
Yes.

42:19  
Okay, so there is there is a lot of interesting questions.

42:24  
But I can't read them out while sharing. Maybe I can partially.

42:29  
Do you mind if your names are visible when you ask questions, or you don't?

42:37  
See No, since I cannot hear what you're saying. I'll do this anyway.

42:42  
Let me share my screen.

42:49  
Ah, I did the wrong thing.

42:57  
This is unspeakably see.

43:01  
Okay.

43:08  
I have to do differently, how to like this.

43:12  
For the moment, I'll just share my

43:21  
constancy. Other things while I'm doing this.

43:24  
Why not?

43:27  
Check. Yes, please. Okay, now you will see my Emacs buffer. I hope.

43:34  
I can see your questions, and there are a lot.

43:40  
And some of them are important.

44:00  
So there's a question, is there an efficient way to do the opposite of attending to the front of the other list? So the question is that we create some space for myself.

44:19  
think the question is basically this. So instead of something like smoke, you know, x 1x, two, bla bla,

44:30  
Excel.

44:31  
So why

44:35  
could I possibly not write simply something like maybe,

44:41  
maybe this

44:48  
as a first try, but this is completely impossible? Because you see, cons is a thing that can take an element and the list to a list, but here I'm in the opposite situation.

45:00  
So I'm given a list and an element in that order, and I want to make a list out of them. So this just doesn't work.

45:07  
The, the reasonable thing that I can do is to say that this is append of the singleton list, why and then it has the correct result, because this one will compute to

45:20  
what you want, namely, this.

45:24  
so naive, you can't.

45:29  
And really, data types, recursive data types, like lists, they are.

45:35  
I mean, they're biassed in the sense that one end is easier to access than the other.

45:41  
This is not to say that you can't have fast access both to the front and to the end of the list. But then you need to use a different clever encoding of the list data type, which is actually possible there is something called difference lists. Which is an idea, which is a trick to exactly get fast access, both to the front and the back of the list in constant time.

46:04  
But I can't show it right now.

46:08  
Someone said there is least append Indeed, this is what I'm using. But this indeed is linear in the first argument. So when you append together to for two lists, you need to walk through the first one.

46:23  
The second list may be long here, it's just one element, but in general may be many. But you don't need to walk through it to perform the concatenation, right?

46:34  
Because all you need to do is to comes the last element of the first list to the whole of the second list. And you don't need to look into it any deeper for calculating

46:45  
concatenation. So it's linear in the first argument constant in the second.

46:50  
But unfortunately, snuck has the first argument complex than the second one trivia. One said yes, someone has said exactly correct.

47:02  
I thought less has a one access to front and back. That's not true. So for that, you would really need

47:10  
sort of doubly linked list where on the top level, you can have quick access to the access to the both and the front.

47:21  
What else is there lists cannot be F sharp list cannot be appended in place, indeed.

47:30  
But partially.

47:32  
So what is actually true is that if you concatenate together two lists,

47:42  
both of which are long, maybe this one is n elements, this one is m elements,

47:48  
when it's sort of half in place, in the sense that you never need to copy the second list. But you basically recreate

47:57  
cells for all elements.

48:02  
In the first place, if you want to think in terms of how things are in the memory, does it make sense.

48:08  
Because think, these two lists are somehow laid out in the memory, I need to walk through the first, then I put the pointer to the beginning of the second, I don't need to touch it, I can also leave it there. And then I recreate the pointer structure, you know,

48:23  
a sequence of n cells, the first one pointing to the second, third, fourth, the last one pointing to wise. So I've, I've,

48:31  
when I'm, when I've done this, I basically recreated axes, so I've duplicated axes, and got wise.

48:40  
So after I've done the append,

48:44  
so when i was when i before had x is once in the memory wise twice, then morally, what y is, is once in the memory x is is twice, but

48:55  
if x is no longer used anywhere else, except in this append, then the old copy of x is will be garbage collected automatically. So this is the bonus of functional languages like F sharp and others.

49:08  
You cannot do your own memory management unless you do tricks. So programming with references is one of those. But

49:17  
the good news is, you know,

49:20  
you're not given the rights to do something but then also you don't get the responsibility. So if you're not given the rights to do your explicit memory management, then well the system should take care of it. And that's it. So uh

49:32  
so that's a good thing.

49:47  
Yes.

49:53  
Okay. I think I think I'll continue with their regarding

50:00  
vigoroth in Hawaii, I cannot hear I, I really cannot tell you and I think it is it is not so much an issue with.

50:11  
With my speakers, there is surely something else wrong in the configuration that is that is badly wrong.

50:18  
I will find it out in time.

50:22  
So let me stop sharing for a moment and then share differently.

50:39  
Okay, so this was less, you can work with these things. And that's really nice. Maybe just a quick illustration of reverse a then just for you to get the field. So reverse a applied to some,

50:54  
some some given list, of course, doesn't give you so much information. But

51:02  
the result will be the same as before, but one of the things I could do for you is to

51:15  
is to actually show for you reverse prime.

51:19  
Currently, it's a local function. So the way that I've written my code is that only reverse a has access to reverse prime, because it's one left. So this one defines a top level name, this lead here, indented defines the local name, I could also write in, but if I use proper indentation,

51:40  
F sharp, we'll see. And that's sort of typical to many functional languages, you try to minimise the number of parentheses.

51:48  
And then one way to deal with this is to make sure you really use your invitation strictly this lead. And this thing match up and I don't even need to write the in the keyword is legal syntax. Although the aim is morally there.

52:01  
One thing I could do would be to lift

52:06  
reverse to the top level. Here, it's actually very easy to do of course, I will need to reload the file.

52:12  
I think all I will need to do is this, this will be fine.

52:17  
And

52:19  
then what I also need to do is this. Now reverse prime is a top level function defined recursively. Reverse A is a non recursive function defined via a recursive function reverse prime, which was top level

52:36  
load,

52:38  
or

52:45  
Okay.

52:52  
Let's see if we've got the reverse prime available.

53:03  
Hmm.

53:05  
Maybe a good idea is to save five. So let's repeat.

53:13  
Now we're in good shape. Now I can I can demonstrate you how it works in the presence of an accumulator, right. So the idea here is x is something that is not yet reversed. ec is something that was already reversed. So it's already in the correct final order. And now let's see how they work together on here, of course.

53:38  
So what are some numbers?

53:42  
Let's say what are some strings?

53:54  
Do you see I made a mistake, which is the mistake No, you cannot tell me Of course.

53:59  
Unfortunately, correct the mistake. The second

54:04  
mistake is writing a comma instead of a semicolon, which we can give you a lot of headache if you can't read their messages. So this part is the accumulator. This is a list that I still need to reverse.

54:19  
And in that course, it will pile up in the accumulator. So to say in the accumulator will be returned. And the result is Hello, world. Here I come sorry, but it came in the wrong order, because I didn't think of it properly. So hello, world is already sorted.

54:38  
But this list, I reverse, and I add one by one elements from here, here.

54:45  
So my mistake was to forget which way these things go, but you see clearly how their community works. Okay.

54:52  
No data types list. Here's a secret list. Actually, we're a data type. So characteristic to a data type.

55:00  
Is that it's a mix of things of different character. So there are two kinds of lists, for example. So this is two different characters, the empty list, and cons list.

55:13  
In some languages, like C, there is union types for this. So I mean, you can, for example, have a union of,

55:23  
I don't know what, of a numerical value of some numeric type and the numerical value of some slightly different type, maybe in some floats or something like this, you can store a thing in this union type, you can store an int, and you can extract the float, and C will tell you nothing. And you don't even get back the same integer turned into a float. But you just get something that corresponds to the same byte representation or word representation as the given integer. So the float that you get will not remind you of the integer at all.

55:54  
Because you can use words differently to represent the different types of numbers here,

56:01  
this kind of mix up will will never happen, because you will always tank

56:06  
the value that you have in your union, so everything will know what it is. So at least we'll know whether it's empty or cons. Here's a different example.

56:15  
I'm defining persons, I will have two different types of persons, I think it has to do something with a university Handbook, or sorry, a phone book or something phone directory. So you have students that have just a name. For the teacher, in an old style, Danish university

56:35  
will have a name, but it will also have this internal phone number, which is four digits, and something else will go in front of it. So that's the difference of students or teachers, those that do and those that don't have landlines. So no one uses them anyway.

56:52  
Now there's two different ways of actually making

56:56  
persons. So I could, for example, say student Joe.

57:05  
And F sharp will tell me this is a perfect person.

57:10  
But I can also say I like teacher,

57:15  
pepper,

57:19  
and some phone number, let's first we think correctly, this is not the right way to do it, because feature

57:27  
is a tank, but really is a function that you know makes persons for me in a recognisable way, taking some argument is a two place function here, but the functions are given as a tuple, not in a curried way. So what I wrote is not correct. And you should be aware that you really need to do it like this.

57:51  
You should apply teacher to the pair of Peter and 5083.

57:58  
In a pair, you use a comma in a list, you use a semicolon in a pair, you do not need parentheses, in general, but here you do, because otherwise, F sharp would parse it incorrectly, it will try to form if I skipped the parentheses, it will try to form the pair of teacher, Peter, and 5083. And of course, that's not possible. Because Peter Peter was not the correct thing in the first place.

58:25  
Right? So what does it give me? Well, it

58:30  
gives me a possibility

58:33  
to

58:35  
make different things to be of the same time. So here's students and teachers, students are morally just names, teachers are pairs of names and the teachers.

58:45  
We used to say a list had to be made, or things of the same type. But now I can put students and teachers into the same list. Why? Because very late neither students nor teachers, they're just persons. I mean, as soon as you've tagged news, with a tag student names is no longer a name or a string. Nils is then a person. Similarly, as as soon as you've tagged the pair, Peter 5083, with a tech teacher, or apply the function teacher to it,

59:20  
it actually becomes a person. And now this thing is just a list of

59:25  
persons.

59:27  
I think it's already in the global scope, because

59:33  
Have you defined it here with a global lesson loaded the file, and you can see this is just a list of persons.

59:40  
Now, how do you work with data types for these discriminated union types, you define them in this way you give a name to the data type, keyword type, and then you give all cases it's nice to give them in an aligned way. There are also other ways but this is the stylish ways

59:58  
and you just tell what the tags are.

1:00:00  
And you say what kind of arguments each tag takes.

1:00:05  
And once you've done this, you basically have created functions corresponding to these tags. So student is a function for forming persons and teacher is a function for forming persons out of different things.

1:00:17  
How do I work with this?

1:00:19  
I can match on these tags, similar to how our match on the tags empty and cons or double colon. So for example, I might define a function that extracts the phone of a person.

1:00:34  
Yeah, and then I can apply it to people. So I can, for example, do get phone

1:00:40  
apply to this guy, Peter.

1:00:45  
Maybe it's a bit silly here, because you see the phone

1:00:49  
directly on this line. But of course, teacher Peter 5083 could have been given a name someplace else, and you don't see the phone number directly. And you can extract it. But of course, I could have the bad idea to also try to use it on student job.

1:01:07  
Surely I can't, I mean, there are quite a few swear words here. But But the main point of the error message is the match cases were incomplete. Because what did I do?

1:01:19  
Ideally, this thing, to not give a runtime error of this character, I should have matched the given argument person

1:01:32  
against any possible

1:01:36  
pattern that I can that can arise here, but I've just only used it in one case, actually, for the reason that it's very difficult to find out the phone number for a student because they're not in the database. Yeah, Is it fine.

1:01:51  
But of course, in principle, I could come up with something like a different pattern match, let me put it as a comment here, which would perhaps say student anything,

1:02:02  
we just return to some standard thing, like four zeros.

1:02:07  
And that would be a perfect piece of code.

1:02:12  
Another thing I could emphasise here, here, it just happened as an accident because it was not like this in the textbook.

1:02:21  
But in general,

1:02:24  
you can use names in different roles. And they don't get confused. Here person is a type name.

1:02:33  
Yeah, it's a constant type person. But at the same time, I've also used it as a variable for a value here a parameter, and that's okay. With these two things live in completely different universes. So there is no way

1:02:48  
F sharp will get confused about this. We may.

1:02:52  
And then you might say it's a bad idea. Perhaps we would want to write p here.

1:02:57  
That would be fine. But there is no problem.

1:03:12  
Just because I can't hear you, and

1:03:15  
I can't see your questions. I will temporarily check with your set here.

1:03:32  
Comma, semi colons. Yes.

1:03:40  
Indeed, I already said this, but maybe I can emphasise it one more time. And I'll show you I'll show you on an example. I also showed it in one of the lectures before.

1:03:51  
But I can do it here.

1:03:56  
commas versus semi colons, commas are there for tuples tuples are types, which have a definite length, you can see.

1:04:06  
Sorry, tuples are data structures that have a definite length. So the type fix is the length that you have in mind like a tuple of three elements, two elements, four elements to element tuples are called pairs. Zero element tuples are called the unit type.

1:04:22  
The syntax there is comma. Lists are different from tuples in two aspects.

1:04:29  
You can put together elements of the same type only, like maybe a list of all numbers or list of all strings, every element has to be a string.

1:04:39  
But you don't fix the length of a list in the type. So there is just one list type for every element type. And then you allow your list to be of any length and the syntax for lists the semicolon and, and there is real difference. So for example, I can write something like

1:04:58  
but can I write

1:05:00  
can do something about telephone numbers,

1:05:03  
not involving the person type it all here. Suppose I want to make my little database and I want to put it in a list, then I can do it like this.

1:05:18  
I'm just making it up. So the numbers don't make sense.

1:05:35  
So that's,

1:05:38  
that's a mix of different punctuation marks, you see a bunch of commas here, you also see a bunch of semi colons.

1:05:45  
But actually,

1:05:48  
for F sharp, let's see what it is.

1:05:52  
Good, I make a mistake, I hope not.

1:05:55  
F sharp has a very definite idea what this is, it is a list.

1:06:01  
But this list has elements which are pairs of strings and integers. And actually, when F sharp shows it to us pretty printed, it has put in some parentheses for us, which are not strictly speaking needed.

1:06:14  
But that's who's ever taste who wrote the pretty printer. And maybe, yeah, maybe you want to see them for clarity. So

1:06:24  
you can see that every element of the list has to have the same type here string times int.

1:06:31  
But the pair type is perfectly okay to mix elements of different types. So we can have pairs of strings and integers. And this type of data structure actually has a name people who call it Association lists or dictionaries. Because the idea is that it is like a small relational database with basically two columns here, four rows, where the first column corresponds to names and second one telephone numbers. And then I can look right look up functions that work with these key value pairs. So given the name, I may want to look up a phone number, maybe I want to work the other way, use the phone as as the key and then look up the name as the value. It's also fine.

1:07:11  
Let me do another kind of an example of data type.

1:07:17  
These are trees node labelled binary trees, there's very similar for lists.

1:07:23  
And this is to illustrate that I can have data types user defined data types defined with a keyword type that work on multiple types, the way that you should read the thing construction here is, I want to define in one go, the type of trees actually node labelled trees for any node labelled type A. So it could be a tree of integers, three of strings to Booleans, a, it could be any type.

1:07:50  
So the resulting type will be called a tree written down in this order. In some other languages like Haskell, you would write three a, so here, F sharp, and other ml type languages have really funny choice of naming, but this is what it is.

1:08:06  
And the tree can be of two forms, it can be a leaf, which means it's just a tree consisting of one node, or it can be a branching node. Or say it can be a big tree, which means that the root is a branching node, it has a label. And the two immediate sub trees are also node labelled trees.

1:08:27  
Actually, two things are happening here. One is that this is completely generic in the type of node labels which are used here. But you can also notice another thing differently from the type of person. But similarly to the type of list this one is recursive. So a tree can be something that is made up of other trees in turn. Does that make sense?

1:08:53  
Then, leaf and Burr are these Lyft and Uber are these data constructors. In this case, it's not the situation at all that it would always need to be two data constructors, you can have 341 any number you want.

1:09:07  
Here is two again, like for lists we have different homes.

1:09:12  
And once you've made these definitions, you basically get two functions leaf gives you a tree right away without taking any arguments. branch

1:09:21  
is a function that takes an argument but that argument is a triple so morally branch is it's like a three place function takes the root label and the two immediate sub trees and makes a tree out of them.

1:09:37  
Now here is an example of a tree maybe difficult to see in this notation, but you can imagine right at the root you've got 34

1:09:46  
then there are two immediate sub trees which are these.

1:09:53  
Let's go to the left subtree This one has 23 at the root

1:09:59  
but the immediate

1:10:00  
Sup trees are already trivial sub trees, they are the leaves, the leaves, and the right hand subtree. Right and immediate subtree is similar.

1:10:10  
I don't want to go deep into into trees at all.

1:10:14  
It's just an example of a data type.

1:10:18  
But I'd like to emphasise at least for once that you programme with trees, in very similar ways to how you programme with,

1:10:27  
with lists, or even with the same person data type that we had here. So we work with pattern matching. Because if you want to define a function on a tree, then you have to say what this function does if the trees is a leaf. And what it does if the tree is more complicated, so it has a root node and further nodes.

1:10:46  
So here, for example, I'm defining a simple function by direct recursion, that's sums all the node labels of a tree just goes by pattern matching and direct recursion.

1:10:59  
So

1:11:02  
if the tree is just a leaf, when I say zero, there is no values to sum up. Zero is the unit of summation if its branch, and

1:11:12  
so the branch just indicates this is a complicated tree. So there is a root label and two immediate sub trees, what do I need to do?

1:11:19  
Well, sub trees are smaller problems than the whole tree. So I just assumed that the recursion can work out the sums of of, of the left and right sub tree TL dr for three left three, right. And then all I need to do is to add to the sum of those two also the,

1:11:38  
the label here an integer, or a numerical value, no in integer because we say zero here, corresponding to the root node.

1:11:50  
Just Just to give you one other example, actually, no, maybe we can show you I can show you these things, T one, T one is your three,

1:11:58  
that's your three, it's really the same one as their, I can sum over all of this, it's maybe a bit difficult to verify.

1:12:08  
Because these are large numbers.

1:12:11  
But it's a number, it's the sum of these four numbers. These are the only, you know labels that I have here.

1:12:18  
I could also, for example, count leaves in a tree.

1:12:23  
So let's think, again, how do you do it with direct recursion, which should always be your preferred way of doing recursion? accumulation you need sometimes for efficiency purposes, and sometimes they don't even help you. So always prefer direct recursion? I would say if you're a functional programmer, especially beginning one,

1:12:41  
how do I count the number of leaves? Well, if I'm at a leaf, this contributes one because this is one leaf. Otherwise, if it's a complex tree, so there is an old label, which here I don't care about, so I can throw it away from the point of view, not using it.

1:12:58  
And then there are the left and right immediate sub trees, I need to take the counts from there and just add them together. Yeah, and then count up

1:13:08  
to one

1:13:09  
would be five. Does it make sense? Well, let's count Love, love, love, love, love, that is fine. That's what he's counting

1:13:23  
What else do I need to do?

1:13:31  
Okay.

1:13:39  
Here there is something similar to other examples that we looked at, about

1:13:45  
taking

1:13:49  
a tree and forming

1:13:52  
rather than say something together, then old labels, forming a list of the node labels in a certain order. And the order could correspond to sort of first working first taking the root node label, then walking to the left doing collecting everything there, then walking to the right collecting everything there. So basically enter the T morally at the root and you leave it at the if the if the tree goes downward, then you leave the tree at the at the bottom right, you know, at the very end of the right immediate subtree.

1:14:27  
Let me maybe show you on an example here pre order

1:14:32  
T one

1:14:34  
is for some reason,

1:14:36  
this order why, because I form a list. First I take the root label, and then I take whatever labels I can collect from the left subtree then I take whatever labels I can collect on the right subtree in the left subtree. I'll start in the similar way I take the root label which is 23. Then the labels from the left hand right but they don't contribute anything here. Then I go to what I

1:15:00  
Here, which was the right subtree, collect the label 54 from the root, then I go to the left, which has nothing contributes nothing, then I go to the right, which gives me 78, then I go further down to the left and right, but these contribute nothing anymore. That's the final list. Now, it's a good exercise to think how to do it.

1:15:23  
And you get a kind of an issue with that is very similar to reverse.

1:15:29  
Because here, if you do it with direct recursion, there will be a part of the resulting list

1:15:37  
that you kind of are parts of the resulting list that you traverse over over and over again. And that gives you a quadratic complexity rather than linear rather than linear, which is what you should have. But if you programme it with an accumulator,

1:15:52  
the idea is you're somewhere in the tree, you've already collected the values from everywhere above and to the left of you, and the only ones that there are still to collect are those to the right of you more or less, then then you can write the nice programme that has a linear

1:16:11  
complexity. I'll jump over this.

1:16:17  
Just to illustrate, you can also similar to math for lists, you can write polymorphic functions for teams. So while

1:16:27  
trees themselves were polymorphic, for example, summations still works for trees of numbers. But there are functions that work for any type of tree. Especially you can make higher order functions that work on any type of tree, and sort of capture common programming patterns for trees. One of them is called map three, four, I call it battery here. And the idea is to do something similar to map for lists. So this thing takes a tree. And the function,

1:17:02  
which is a hierarchy of the function, one of the arguments that comes in is a function. And it applies the given function to every node, all the tree.

1:17:15  
So let's look at the type of map tree.

1:17:20  
So it's the function we can't see much of its value, I mean, it's some function. But here's the time it takes a function for sending any type A to any type

1:17:32  
B for some fixed a and b.

1:17:36  
And then it takes a G of A's. And based on this function, it's able to produce a G of these intuitively what it should do, it should walk through the tree in some order. Here, it's done with direct recursion. So it works kind of bottom up.

1:17:49  
And,

1:17:51  
and applies the given function at every note. So we can we can do easy exercises on this one. So for example, I have this treaty, one that we've seen so many times. I can for example, Mac

1:18:06  
plus,

1:18:09  
what is easy, plus 123.

1:18:15  
And I've increased the node label of every note by one.

1:18:22  
Yes.

1:18:25  
I might not like it. Maybe I want to have 17 everywhere. Then I could write the following. I will put here the function

1:18:34  
that whatever it gets in it just returned 17.

1:18:40  
And I got the tree of 17. But of course, I could just as well have a tree of highs

1:18:47  
and it's also perfectly possible.

1:19:04  
Do I want to do positions?

1:19:15  
I want to see if there are questions.

1:19:43  
Okay, there are quite a few questions.

1:19:47  
Let me share just my Emacs window.

1:20:06  
Okay,

1:20:17  
here's a question about person and zeros here.

1:20:24  
I think I made a very small typo here. And it's good that you noticed it.

1:20:30  
So the whole thing, of course has to be have a correct claim. So get phone here takes the person and returns an integer, because phones are integers. So it was a bad idea for me to put quotes around the zero, right? Is that okay? So this is just zero.

1:20:52  
So, why did this happen? Of course, because I put it as a comment, and I wanted to make a shortcut. And then

1:21:00  
why does lf

1:21:03  
not need a type definition left for leaf.

1:21:14  
So you can have data, data constructors or tags that don't take any argument or you can have those that take one argument that can be complicated to in particular, it can be a tuple. In principle, I could, but I don't advise you

1:21:30  
to say that leaf takes an argument of five unit.

1:21:41  
But then you see the penalties, then I cannot write leave for some relief, then I always have to write leave empty,

1:21:48  
which is just a

1:21:50  
nuisance.

1:21:52  
Because then leaf will take an argument, the argument can never be anything of interest, it's always the empty tuple.

1:21:59  
But it's kind of a nicety of syntax that you're allowed to just not have an argument in this case,

1:22:06  
is direct recursion, just going all the way through and doing calculations on the way back? Yes, you could say these days. So a typical recursive data type is some form of a tree or a tree like structure, with labels here and there.

1:22:22  
You make calls on smaller parts of the data structure.

1:22:28  
So as you go down, so to say the data structure, you just accumulate a stack, of course,

1:22:34  
what is more complicated if this data structure is branching, but anyway, morally, it's there is many calls that you start to go down, and then you'll do the calculations on the way back up. So in the case of a tree, suppose the trees go from the top to bottom, like, not like in nature, but like in computer science, you typically put the root at the top and leaves at the bottom, then you work down the way on the tree, make recursive calls, and smaller and smaller sub trees,

1:23:02  
you reach the leaves or leaves, the base case will tell what the result is. And then you will calculate the result on all sub trees on the way back up.

1:23:14  
Could you define what leaves and branches?

1:23:18  
I can't, they are nothing else, then

1:23:24  
data constructors, or tags, these under the names of them.

1:23:29  
They work like functions, in the sense that they are some way to take, you know, to make a three out of nothing in the case of leaf or to make a tree in the case of a no label or to other trees. In the case of branch, or a composite tree.

1:23:48  
But it's nothing like what I could define

1:23:53  
no

1:23:55  
kind of mathematical name for it would be a free construction. So I'm looking, I'm looking for lF and ber, which really are nothing else than like syntactic constructions. I mean, you can see here these are my trees, Burr and lift, don't compute anything. Love is already in its simplest form. It is it and nothing else. Also brands have

1:24:20  
a node label and two other trees is already a tree. It's not like I apply a branch to three different arguments and then it will still compute something No, it is just a tree. Of course, here instead of 71 eight, like we'll have 70 plus eight and that will simplify to 78. here instead of leaf I could have two complicated trees and they may be compute to simpler trees. But in the end, what you get is just this. So it's kind of a way of General of

1:24:49  
of making data structures.

1:24:52  
But these are not like data structures like records that would have a number of fields and every field has a value but

1:25:01  
They are kind of an ilogger. And an analogue of records, where for every particular instance of your data type, exactly one field has a value so

1:25:13  
or has an argument. So every chief either leave or brands but not both. Yeah.

1:25:19  
And then if it's a brand standard is

1:25:22  
a triple of information, which are the note label and subtrees.

1:25:27  
Okay, I'm

1:25:32  
done, stop share share differently.

1:25:46  
These were

1:25:49  
trees.

1:25:52  
Here's an interesting type that you can perhaps play with.

1:25:57  
Here is a type of what I

1:25:59  
have what I call positions, it's a type POS.

1:26:03  
And this is to identify a place in a putative tree. So S stands for the root position in a tree. And l means

1:26:15  
l apply to some other position is a position that that is given by first going to the left, and then going to wherever the other position

1:26:25  
goes. Our means first go right and then wherever else. So then I can form because positions like R R, L S.

1:26:37  
So this is a valid position, and it means

1:26:41  
it morally indicates or it can be used for looking up a subtree. In a bigger tree, when I first say, I'm actually interested in the, you know, the right immediate subtree of a given global tree. And then maybe I want to go deeper into the right immediate subtree of that. And then I may want to go deeper into the left immediate subtree of that.

1:27:04  
And then maybe I want to have the root

1:27:09  
position

1:27:13  
of the three that I've reached that. So basically estimates kind of stop here, I'm already there. Yeah.

1:27:19  
And if you've defined a data type like this, all of these will be legal legal positions like S will be and L

1:27:29  
L, L or S will be

1:27:32  
an L of m of s Volpi, because I cannot go to the middle, there is no constructor M.

1:27:38  
And once you've done this, you can actually write the nice function, sub tree recursively, that takes the position and the tree

1:27:48  
and extract the sub tree at the given position in a tree. And then you could think how it works.

1:27:55  
Basically,

1:27:57  
if your position is S for the root position, and you're at the tree, then you just return that tree. That's the base case.

1:28:05  
If the position says go to the left, and you're given three is has some node label, which you don't care about some immediate subtree, which don't care about some immediate left subtree, then you recursively call subtree P

1:28:22  
and T one. So go deeper with P in the left immediate subtree, which was T one. And similarly if you're on the right,

1:28:29  
there are bad cases where you are at a leaf but you still need to go to the left or to the right. These you can model with incomplete pattern matching, that's okay. But here actually show you a different solution, which is to raise an exception. So failed with raises a standard exception called failure. And it also allows you to emit an error message together with it. Still an error if you if you end up in this case, but at least you get some information other than just random swear words.

1:29:07  
Then

1:29:09  
this is a very useful data type called the option data type more or less defined like this. But actually, it's already predefined for you. So don't need to redefine it.

1:29:22  
The idea is

1:29:25  
thing for example of our person,

1:29:29  
the data type.

1:29:32  
This is a good example,

1:29:34  
where maybe that's not a good example think it is a good example as well, but not as soon think of our lists case. So we previous I previously showed you functions head and tail that extracted the head and tail of a list, but they were done with incomplete pattern matches. And if the given list was empty, you just got a runtime error because of a matching of a missing matching pattern.

1:29:57  
So the function was not defined for the empty list.

1:30:00  
But if you actually call it on the empty list, then then the interpreter starts yelling at you.

1:30:06  
Now what you could do to avoid these things and to actually be able to handle these erroneous situations, one possibility is to use an option datatype.

1:30:15  
The option data type takes any type A.

1:30:20  
And the basically unions together with

1:30:26  
with a special kind of signal value called none. So this one is a tag that takes no argument none. It says no value morally. And there is another tack some to tell you Apart from this, which takes as an argument somebody have type A. So anything that lives in this type must be either

1:30:46  
a value, or your type of interest, a just marked some, which means this is a good value, it's the regular case, it's not error, or it's this special value none which signifies error.

1:31:00  
So I can, for example, have none of type

1:31:03  
the option

1:31:06  
Sorry, wrong sorry.

1:31:11  
Maybe it will require

1:31:13  
it once parentheses here.

1:31:17  
And then that's good, right. So none is a is an erroneous value, not in integers. But then optional integers, this is how you should think of them, I mean, an integer that may be missing.

1:31:28  
Whereas at the same time, some five

1:31:35  
is also an optional integer, it is, it is an option that is actually used, you know, it's a proper integer, it's not an erroneous integer. And once you've done this, you can write nice functions.

1:31:51  
So for example, instead of the ordinary head,

1:31:56  
which had the type

1:32:00  
so what type it had had had had the type a list goes to a, so it takes a list of arrays and gives you an element today, I can define a different function called try head,

1:32:12  
which takes a list of arrays and gives me

1:32:17  
you know,

1:32:19  
a value of type a with a possibility of an error. So it's an optional a, a option.

1:32:25  
So this one is listed.

1:32:31  
And that's what I had that. So it's it's like the usual head programme, it says, When I see a list, which is x followed by something else, then the head is x.

1:32:40  
But now I put the tag sum, which doesn't compute anything, it's just a syntax error wrapped around the actual list head element value. But I can I can write the complete pattern match, because now there is a good thing to write for the empty case. Namely, I say, look, this is a bad situation none.

1:33:00  
And then some other function that uses try head can pattern match and say, okay, was this a proper list, did it have a head, and this is signified by non you can find it out by pattern matching, or none. And if the list was, was non empty and had a head element, then you can pattern match on some successfully and you can use the Add element for some good purpose.

1:33:24  
So similarly, we could fix this get phone function by getting it the type

1:33:33  
that goes from person, I'm not putting the wrong size here. This is a single column.

1:33:39  
The reason I'm making this mistake is that in some functional languages, colon and double colon are used exactly the other way around.

1:33:46  
So this one will give me an optional integer now

1:33:51  
rather than just an integer. And you can see I can very well give a phone even if I'm calling

1:33:59  
the get home function on on a student, I just say a student cannot possibly have a phone.

1:34:06  
Let's try this.

1:34:12  
And I see a student doesn't have a phone, but then maybe someone like teacher

1:34:18  
I forgotten what the

1:34:21  
phone calls better was, doesn't matter.

1:34:26  
Let it be something

1:34:29  
maybe close this.

1:34:32  
And then I do get the numerical value, which is 5038. But together with a tax sum, which just says this is a proper value, it's not an error.

1:34:44  
So that's one way to to do

1:34:48  
credit erroneous situations by hand using user defined data type.

1:34:55  
Let me just finish off by saying that there is also a mechanism of

1:35:00  
of exceptions, I don't want to go deeper into this. Now I'll do this next time. But just to show you an example. So suppose maybe

1:35:11  
I want to convert,

1:35:14  
you know,

1:35:17  
what is it

1:35:19  
I want to calculate time in hours of a day,

1:35:24  
in two minutes of a day. So that should be just to take illegal number of hours, and multiplied by 61 way to do it by also signifying that, I don't want to multiply my number of minutes by 60. If the number of hours is smaller than zero or greater than 23, which are not legal hours of a day, then I can read raise an exception illegal hour and provide some extra information, which here is an integer, provided that I've defined the legal hour as user defined exception. And this is an exception, which, when I raise I'm allowed also to provide some information together with the exception, which here will be a number, integer number, which is just the hour.

1:36:14  
So

1:36:16  
I can apply minutes to 25. Normally, maybe let's first do something reasonable to three, this is 180. If I apply to 25, sorry,

1:36:27  
then

1:36:30  
I get an exception illegal hour.

1:36:36  
But then exceptions can be caught with the following sort of try catch syntax, I can say try to evaluate this thing. But if this exception arises, with whatever information, just return minus one as the kind of a default.

1:36:54  
And that's perfectly possible, I do get minus one.

1:37:00  
But I could also choose to do something else, I could maybe

1:37:06  
actually capture the the number, then I could maybe return that number, that would also be a possible thing to do here, or maybe return something else.

1:37:21  
And there is only one thing to say to finish. So here I'm using a user defined exception. Illegal our in some previous code, actually, there was a failed with where was it here. This is just a shorthand if you don't bother to invent your own exception.

1:37:42  
Type, which can be useful, because you can match pattern match on these different types of exact example, you can use one of the system exceptions, and one of the system exceptions is failure is called failure with capital F. And this one allows you to provide some information with

1:37:59  
as a string. So pain with cannot continue is basically the same as raised failure. And argument cannot continue.

1:38:09  
There is an example

1:38:12  
of this.

1:38:17  
So here's basically the same programme as before, but I don't use my own exception, that was called illegal hour, but I use the exception failure. So then I don't have to write race failure, I can just write failed with. And this is my error message, which is a string.

1:38:33  
And I can get exactly the same functionality as before this try catch thing

1:38:39  
where I do not try to catch

1:38:45  
the exception the legal hour anymore. I'm trying to catch the system exception called failure.

1:38:52  
And that is maybe good for now about this part. Let me see

1:38:57  
about questions.

1:39:02  
Well, there are

1:39:04  
some more questions I'm done with,

1:39:08  
with everything I wanted to show you today. So if you could write something else in the chat, they can quickly, quickly answer.

1:39:31  
While you can raise your hand.

1:39:35  
Can I quickly see the first version of pre order again? Yes, let me do it like this that I keep the chat open.

1:39:43  
So I can see other questions share screen Emacs.

1:39:55  
I didn't really go through it at all right? So you have to properly think

1:40:00  
And what happens here and it's not so immediate. And it's quite interesting in the sense that the fast version of preorder, which works with the accumulator,

1:40:10  
uses an auxiliary function P order prime, I've here chosen to be the top level. But of course, I could make it local to preorder a so no one else will be able to see then apart from the definition of pra, but the interesting part, of course, happens here, right?

1:40:28  
So maybe we can quickly think what is happening. Morally, the situation is this. So

1:40:36  
the way the thing works is there is some running sort of tree that you're looking at, that is not yet pre ordered,

1:40:43  
in the sense that you haven't extracted the node labels yet in the pre order order.

1:40:50  
And initially, or the, say, the top level accumulator in this initial in the sense of imperative programming, top level accumulated in the sense of recursion, tail recursion here.

1:41:01  
It's not a recursion, actually, interestingly, but it still uses accumulator

1:41:07  
is empty.

1:41:09  
And I gave you the, the intuition that is something that I haven't processed yet.

1:41:15  
Which morally is, is is with some sub tree somewhere. And the idea is I should have processed everything above and to the left of the given three, and that will be kept in the accumulator, then the idea is, is the following.

1:41:32  
If you're,

1:41:34  
why can't I see the chat anymore?

1:41:42  
Okay, you say thanks. But maybe I'll comment anyway, just take a minute, for those that are interested.

1:41:50  
When you're at the leaf, then you just return the accumulator. And you should think that I'm at the very end of the rightmost part of the tree somewhere at the bottom right? If the tree is drawn, growing from the top to bottom on a piece of paper.

1:42:09  
So then everything is already there in the list. Otherwise, what happens?

1:42:15  
And that's quite interesting.

1:42:18  
Is the following thing.

1:42:22  
As you can the right order, actually,

1:42:27  
do you think it's in the right order, or maybe t, L and T are mixed up? Anyway, let's think about it. So when you have to process, maybe it's post order. And

1:42:39  
when you have to process the composite t x t L.

1:42:45  
Dr.

1:42:47  
Then you first put your

1:42:51  
root node label in the list in the list that you're building.

1:42:56  
But then what is the rest, the rest should cover?

1:43:03  
both

1:43:05  
the left and the right

1:43:09  
subtree.

1:43:14  
And I think the left and the right are mixed up here. Let's see. So what is done here is

1:43:21  
you have to traverse

1:43:25  
the right subtree with a given accumulator, and this will give you some new result, which then is used as an accumulator for also processing the left subtree. And I think the way that we can check whether it did the right or wrong thing is to look at again, the one

1:43:44  
and then what is the whole thing called?

1:43:50  
Okay, now you can't see what I'm doing too bad.

1:43:58  
But now you can. So let's look at T one again, T one is this. And if we call the new version of preorder that sort of more efficient.

1:44:07  
Let's see if it does the P Oh, they're actually the post order. pre order a T one.

1:44:15  
So it's 34 No, it's good. 3423 5478. So think why, why this is the right thing.

1:44:38  
But but but but you see here something that is a bit unusual in the sense that is a recursive function.

1:44:45  
That actually takes

1:44:48  
some argument and the argument also uses the recursion recursive function again. So it's kind of a nested recursive call.

1:44:58  
That is, that is happening here.

1:45:00  
Which is maybe

1:45:02  
a bit

1:45:04  
mysterious?

1:45:11  
Actually, no, I see everything in the code is correct. But I said the wrong thing to you. So

1:45:17  
that the tree that you process here that you always process is something that is not yet processed. Everything to the right of it is already processed that is in the accumulator. And, and everything above it is processed. So what you have is some tree somewhere to the left of the tree. And the you leave it when you're at the leftmost at the end of the leftmost path. Yeah, so in the accumulator, so the processing with the accumulator starts at the right.

1:45:47  
So first, you say nothing is in the accumulator. And then yeah, you accumulate basically going from the right bottom and corner, through all the intermediate nodes to the left, bottom and corner. And this is where you actually, and actually, the explanation here is also correct. Just what I happen to say you mixed up left and right.

1:46:15  
Yeah, sorry for the

1:46:18  
for the wrong sentence. I said, Okay. But you can play more with this. So the plan now then for tomorrow is you've been assigned to groups and also for the future.

1:46:31  
You can work on sort of practice problems I've given to you. And I'll keep giving them to you. These are practice problems for which I show you a full model solutions and you can agree with them or invent your own solutions or invent something slightly different, which is often possible. They are not to be handed in. But they are meant as preparations for the actual assignment exercises, which perhaps are sorry, the actual assignments, which in some cases are not so different from what happens in the practice class. But of course, there must be some question on it. Because if you solve everything in the practice class, then there is nothing for us to

1:47:10  
if you solve a tech everything with THC in the practice class, there is nothing for us to give you a mark for for the assignment.

1:47:19  
And then I'll publish the

1:47:23  
first assignment sometime next week, Thursday, I think is the day. And then also in the next sessions, you can also ask about the assignments. But the TS can only give you hints, they can't obviously give you the full solutions of the assignment. But what I really, really recommend is to look at the practice problems, because they should contain all information that you need to do the assignment problems.

1:47:47  
Yeah.

1:47:50  
And no, there is exactly there is going to be one Practice set for each week. The the reason why you now have to, and a lot that once is simply that we have to skip the first practice class, but you'll typically every week you get three, four or five problems.

1:48:06  
For this time, it may look like a lot, and you don't have to do them all. And the problems with recursion are very similar to each other. So what I recommend is,

1:48:16  
if you solve one and two and you, you, you, you feel confident that you understand about recursion versus loops.

1:48:24  
You know, don't need to look at the rest. But if you feel you're unsure, play more with recursion, because it will simply it's like an investment of time, it will.

1:48:35  
It will win you a lot. In the rest of this course everything else will be so much simpler. If If sort of, yeah.

1:48:44  
You know, if you can do recursion first thing in the morning before before even the first coffee, if you're on that level of confidence, then you're all well set for the rest of the course.

1:48:58  
The practice sets are not to be turned in No. And I'll publish the model solutions for the for the first two tomorrow night or maybe Thursday morning after after the accuracy group has taken place. So you'll already see the full solutions. And yeah, no grading no nothing about those.

1:49:17  
For those sorry.

1:49:19  
Yep.

1:49:24  
Okay, so now we went over time with questions, but I think this is the protocol for the rest of the course you will, I will follow it. You'll see the zoom links under the zoom tab. It now works. We've all got licences every ta

1:49:38  
some of the Thursday lectures will be pre recorded, but then I'll tell you about this. But I'll be here at least every Tuesday to sort of interactively ask the answer questions

1:49:50  
and that sort of thing with his own licence and an E loudspeaker

1:49:57  
or earphones.

1:49:59  
Okay.

1:50:01  
Is everybody happy?

1:50:03  
Yes, have a nice Tuesday night

1:50:06  
and then we stop here.

Transcribed by https://otter.ai
0:43  
So let me start, This is lecture four, this is the last lecture on F sharp, we'll come back to many features of F sharp, also, of course, later in the course. But this is the last lecture in this in this crash course. So we've already seen quite a bit, in particular complicated things like lists, and also general user defined data types. Together, we look at the different form of interesting types, which are record types. And we'll also look about something that we haven't seen so far yet, which is the first non functional feature of this functional first language, F sharp, namely mutability. Sort of in a controlled way, we'll see it on the example of references, which are just a special case of record types that are provided to you in F sharp, you don't have to define this type yourself. But records use mutable fields. So for the first time, now, you will see that you can have something in in F sharp, that actually changes its value in a computation. Previously, we only had immutable names for examples of names can change their value. Okay, so let's start I'll share my screen. Just a sec. Alright, this is Leo, thank you. So let's define that you want to work with today.

2:29  
Let me

2:38  
also open it.

2:46  
So now we're all set. What are record types, records are quite a bit like tuples. So the idea is to group together a bunch of values. So that you can work with not only with, with with with basic values, but but groups of values. Differently from tuples. components in records are identified by field names. In tuples, you can talk about the first component of, say, three tuple, or the second or third, or the first component of a pair. And the second component here don't go by this numerical position information rather, every component in a record is identified by name by field name. And the way that you state record types, is like this, you can make type definitions using their keyword type, like a used for data types are discriminated union. So it's the same keyword, you give the type name here, I want to define a type a record type person. And here is sort of a type expression for records. Then, the symptom here are braces, then in braces, you will have something colon something some number of times where there's something to the left of a colon is always the name of a field. And the thing to the right of a colon is the type of that particular field. So a person groups together a string and an integer. But for the string, you don't say the first thing you say is the name. And for the integer you don't say the second thing you say is the age. How do you make values in a record type? Use record expressions. This syntax is very similar to the syntax for type expression, except in colon, sorry, instead of a colon. In many places, you see the equality sign. Otherwise, it's similar so that a brace This is to the left of the equal sign, you use your field names. But to the right of the equal sign, you put the value that you want the field to have. And everything by default, this is again, the mutable. So So here, for example, I'm defining a main j, this name has a value person. And there are these teams. And they don't change. So the field, john of J is sorry, the field name of J is john and the field page of J is 35. So let's play a bit with this. So let me check about J. So here it says, J is a person, that's the type. and the value is this. Very important to stress again, you have to make a distinction between the colon use and the equality sign use, colon indicates we're talking about the record type, quite the sign indicates with, we actually have a particular record. Of course, you don't only want to put together records, you want to take them apart, you want to do field selection. So there are several ways to do this. One is something that might ringabel from object orientation. So if j is a person, I can, of course work with It's me. And it's john. And I can just use the dot notation to access it. So the value of j dot name is john, I can also ask what the

6:51  
value of

6:52  
j pages is 35. So So clearly, then I can use it. Such a thing in j dot name on on the right of equal sign in by defining when I defined some name, like n. So that's one way to do the field selection. You can also use pattern matching. So here is a typical example of that. So maybe I'm interested in extracting the name of a record, my record is J, they want to call the name n. Similarly, like I did here, just different syntax for this. One way to express it is this, I say name is n in the pattern. But about the age, I don't care solely on the score. If I do this, I get to know that n is john. Yeah. So n is defined at this stage. It's a new thing in the scope. And I could similarly extract actually name and age both if I care about them. So this is like defining two names at once. So maybe we call the AJ. And then I've learned both. I can also, instead of underscore, it's also possible to just mention the fields you care about. So rather than giving, indicating all the field names here, I just indicate the ones that I care about. And I can do the same thing. Let's do it also for name.

8:39  
Ah, that is faint. No reason at this stage may be completely surprising. But that reason actually happens to do with something else that I that I have here in the loading time. Namely, I don't only have one record type person, I also have a record that record type person three and another one, called person five. And they happen to have also field name and name as part of the type. Now, when F sharp sees this thing, it doesn't, at this stage know whether the pattern is for the value of type person, or person three, because I've given too much too few clues to to F sharp to figure it out to F sharp type inference to figure it out. Of course, J we know is person, but F sharp wants to check that the left hand side and the right hand side here agree by type for the left hand side is not sure what we meant. So maybe we meant person three here. So that's not good. But I can fix it by writing something like this. So I'm saying yeah, it's it's indeed about About the record, but, but it's about a record of type person. And then so now I've defined the name and and it's still john. Right? So remember, then, where was it? The j is, is this particular record. One thing I'd like to emphasise to you is that the order in which the fields are listed in a record is irrelevant. So this is one of the major differences from two booths when tuples. Everything goes by position, since there are no field names, really where you are in the tuple is very important. Here, since we can identify components by name, holder shouldn't matter. And indeed, it's designed in such a way that it doesn't matter. So here is a different record, or it looks like different in principle, or maybe even a different record of a different record type, because the fields come in a different order. So I'm saying here's a guy who has aged 35 and named john. Yeah, whereas Jay was defined as something else named john h five. If, if I ask F sharp, are these equal, then there are several things that could go wrong, maybe they are from different record types, maybe this they are from the same record type but not equal. Let's test F sharp didn't complain, it didn't raise an error, which meant means they must have been of the same type, otherwise, you can't do comparison. Moreover, they will literally the same records for F sharp because F sharp says yes, this comparison gives as a result, Boolean which is true. Now hear something else, I can also define the new record by giving the fields in the wrong order. So if I say something like this, I don't get the record of type person with the fields name and age properly defined. And you can see when this person is pretty printed here, actually, the fields come in the sort of canonical order, which is the order in which I indicated them in the type definition. Does it make sense. But then, if I tried to cheat by, for example, saying something like this, that I want K to be some record that has exactly one field, age 12. Or maybe I mean that there are two fields age and name, but name is somehow undefined, then F sharp will complain loudly. It somehow figures out that this is potentially a record of type person, because I don't have any other record types around here in my file, that would have a field age. So he thinks this must be a record of type person, but then I don't give a value for the field name. And that's, that's an error. Now, here is something interesting. record types may be recursive, like we had data types that were recursive, right? We had a person data type that had students and teachers. That was not recursive, but we had lists and we had trees and they were recursive in the sense that

13:32  
a tree can be made of other trees here, I can have a person or a form of a person, record type, that can have fields that are other persons, or more precisely, something defined of other persons. So let's see, let me define another record type, I call it person three. for lack of a better idea, it also has a field name, name, but then there are two other fields father and mother. So field name can take values of type string, father and mother are fields where this recursion thingie occurs. So Father, and what really should be a person. Yeah, and the mother as well. But think now, if a person has a father, that person will also have a father and mother and that those will have their own fathers and mothers. So if we don't use option here, it looks like only possibly persons would have to have these infinite answers and says drills. Where do we go all the way back? Even past Adam and Eve. That's tricky. So we should leave the option that we define a person but just don't indicate it's father or mother. And we have the option data type lists. Now that's great because I can I can do Interesting definitions, like I can say,

15:03  
J

15:05  
is such a thing, let's see what happens, I get to know that j is a person three, you know. And the fields have these values. And there is even some nice at the end, instead of showing that Father has its value none. This pretty printing shows now. So it's really like no value on the finiteness per se, in, in the sense of null pointers. Yeah, if you could think of a record, or a recursive record that somehow laid out. Let's try to do something interesting with it. Let's make another person let's make a daughter. And let's let let Yeah, let's let let john have a daughter. So I'll define k like this. That's quite nice. So I get a person whose name is Mary. It has a father, or she has a father, I should rather say if your information is given, so we know that the name of the Father is john, but we don't know the name of the grandfather of Mary from polar site, neither we know the grandmother. Neither do we know the grandmother. And we don't even know that the mother who is Mary's mother, Mary does have a mother but the information is, is not provided. Now I can do field access, and I can do cool things, right. So of course, I can write stuff like k dot name, which is Mary, I can also do k dot father. Sorry, k dot toddler. Maybe I'd like to know case father's name.

17:08  
Okay, what will happen?

17:13  
To extract the name, I should have something that is of the type person three, or maybe person five or whatever, or even person that has that as a field name. Name. But case father is not really a person. As we can see here, it's an optional person. So directly like this doesn't work. But I can use the function get from the option module, which is well defined when I have a real value, and then it extracts it. And it just gives a pattern match error, if I try to extract the value from an optional value, if the value is not there, so we could do the following thing we could do option get.

18:06  
Okay.

18:12  
So now I'm just closing my eyes and trusting that all goes well. So I don't know. Favourite priori, if case father is some something, or none, some none. But let's hope it is some something in this particular case it is we've already seen it. If it is the case, then I can go and extract this guy's name. semicolon, of course, and I can see john. So this is already getting a bit more complicated, but it does work. So I can use this dot. Also, if to the left or the top, I have an expression, not just not just an A right. But of course, this expression should have a record as its value. Otherwise, I can't do field selection doesn't make sense. Let's do some more things. Here is something really cool. That is not purely functional anymore. What is is I'm defining another type of person, person five. So persons five have a name. So that is a field name, name. And the fact that I've used the same field name in so many record types is the one that no one then confuses f sharps type checker because it just doesn't get enough hints from me which kind of person I'm having in mind. But but this is legal to do it like this. I mean, you can You can use the same fields naming different record types, you just have to be careful. But then it also has a person any person five also has a salary. So there is also this field name salary here. And the salary is always an integer. These are not Icelandic crowds. But the salary field is mutable. While we were not supposed to have anything mutable in functional programming, but F sharp is only functional first. So there are imperative features here. So, part of our you know, the big thing about imperative programming is that you work with language constructs, whose meaning is that you change the state. Now there is there is the idea that there is something there containing values, where the values can actually change that can disappear, and the new value will appear in place of the old one. So, destructive update should be possible. And that's exactly what mutability here means things can change. So I'm making a new definition, I make j not to be a person anymore, but the person five, then j becomes j is defined as a person five. His name is john and salaries 5000. I can, of course, extract j salary. I can of course, do any arithmetic operations. With it, I can maybe give a little pay rise. But this doesn't change j salary, I just calculated that. If I added five to it, I will get the number that is 5005. But this doesn't change to a salary.

22:10  
All right. Now, of course, I can't write anything like j salary equals j salary. plus five. I can write this with equal sign. But this is just a comparison, which is false. But if I tried to define or redefine j salary, this is not a good idea. Right? Yeah. So this kind of syntax would be legal if j was a namespace or module, but j is a record. So this is nonsense, you can't write such a thing. So you can update the fields in a record that has mutable fields, but that goes with a special syntax, I can write the following thing, I can actually give a much bigger pay rise, I can increase the pay by 10%. Using this wonderful syntax, which is an arrow pointing to the left. Now, important equals you cannot use here you have to use arrow pointing to the left. What is strange, there is no let so it's not the definition. Yeah. Previously, we only had definitions and expressions, right? They could define types, they can define names of values. And then add expressions which I could evaluate based on values of other things that already know. This one is not a definition, it is an expression, which actually doesn't return anything, as you can hear, say, See here, it returns the single uninformative value of the type unit. And remember, the type unit is something that in some other languages, would you you would call void. It's a type that has exactly one element. So in that sense, it's not completely empty. But it's empty of information. Yeah, if somebody tells you my element in this type is empty parentheses, you've learned nothing because you already knew it, there is no

24:19  
music.

24:21  
So no information about one element. logarithm base two out of one is 01 element, no information. This is something now very particular to to, to to this phenomenon of mutability. Generally, expressions of type unit are quite useless in F sharp when you say purely functional Because it's not quite true, but but but also, because when you, when you computing something of type unit you're not computing anything, the result is known in advance it will be the empty tuple or maybe not termination or maybe an error. If, if the expression gives a runtime error for some reason,

25:22  
but

25:27  
but the point with with these things is something that doesn't return anything in a non purely functional setting can have a side effect. And here are the side effect is under the hood, the secret change has happened, namely j salaries knew nothing is returned. But Jays salary has changed to expressions that have typed unit. So they return nothing interesting. These expressions are often called commands. And they are the exact analogue to commands in imperative languages, or maybe also call them sequences, sorry, statements or instructions. This is a synonym, but I'll talk about expressions versus commands. This is the first place where we see commands and now I can ask what is the value of,

26:15  
of J.

26:18  
J, remember, was a person five. And it was defined like this, I never redefined redefined it, I don't have any kind of a new lead j here. So it's not like I've shadowed out the previous definition of J. Instead, it's kind of very same j, but but the value of F or its field salary has changed. I can also of course, directly now ask, what is what is what is the value of this field. And I can also, of course, write something that looks like quite imperative. Now I can, for example, let's forget it was 5500. I want F sharp to do the computation for me, let's give this guy for that pay rise, maybe by 70. This is now also legal syntax. As long as you use arrow to the left. You see, nothing is returned to us. But if I go back and ask what is J salary again, then it's 5570. Right. So this completes one part of this lecture. So we looked at record types, these were analogues of two types. The big difference being that instead of indicating or referring to components, positionally, like by where they are in a tuple as a structured value, you have access to components by field names, that you sort of declare at the same place when you're defining their record type. Now to something else that actually uses record types. And a particular polymorphic type of records are called reference references, or pointers. I should also say some people like to say pointers. So this is predefined for you. And there is some handy syntax that you cannot define in exactly this form, by yourself. But you almost could you could define your own to the version of the reference record type without any problem, but not exactly that syntax around. So what's the idea of a reference? intuitively, a reference points to a memory location holding a value that we hear called contents of some type. This is a strongly typed language, you should always know what type of value you're holding in that location. The way that this is implemented in F sharp is morally by this kind of type definition. So I'm not writing it myself. It's in the comments here. This is provided to you by

29:56  
by the language so the type of references Type A is a record type where there is exactly one field contents that the field is typed with a type variable A. So this one indicated here is a parameter of office type ref. But this field is mutable. And then of course, there is some interface, some some useful functions to work with the references. And they are the following there is something called ref. I mean, the type is called ref, but there is also a function called ref. And types that sort of value names they live in two different worlds in an F sharp you they never mix up. So, it's okay to reuse the name then there is bank and then there is colon equals So what are they? ref is credit for defining a new reference or for for creating a reference, you would say in an imperative context. What's the idea? ref is a function that takes a value of type A, and it basically sort of creates a location if you wish, and puts the value there. But how you should think of it using imperative programming analogy, like is a location or a memory cell where you can put values of type x, it's not a cell in the strict sense in this in that a can actually be a very complicated type, not not a primitive thing. So in this cell, perhaps you put something very complicated like a list of lists in one single cell, so to say, so that's why we talk about locations. So visit, so we could perhaps exercise a bit with it. I could, for example, say let p be ref of 42. When I do this, then P becomes a reference to an integer. And what is its value? Its value is an immutable record. This is how you understand what the what the value of reference is. So to say. There is this one field, which is mutable. It's called contents. And it's it's currently or is initially, shall we say 42.

32:27  
Yeah. Then, so clearly, then ref has this polymorphic type, it takes the value of any type, and it gives you a reference of the corresponding type. Very something for D referencing or sort of looking up a pointer, or looking looking under a pointer, if you wish. That's called bank. And bank has exactly the opposite type, it takes a reference and the tracks, it extracts the value. And more or less defined like this, except I'm not allowed to use bank as a function name myself. So this is where this is not completely legal F sharp syntax. But if bank were that a valid identifier, like a valid name, that would precisely be the definition. So all it does is just, it's field access. So it's p dot content, it's just a shorter way of writing p dot contents. So let's try this. If I do p dot contents, it's 42. And bank P is just a shorter way to express this. I can write it like this. I can also just drop the space even. And this is maybe more familiar.

33:50  
Yes. So that's the referencing but then of course, when you have references or pointers, you want to do updates. And what should that be? So that should be a two place function. So I want to have some reference some pointer to somewhere, then I want to have some new value that I want to put there. I just want to overwrite the old value. And nothing should be returned. But under the hood, of course, then the contents of the reference should have changed now, when I've called the function. So how is this morally defined? This actually is legal F sharp syntax. So it could be defined like this. So it is it is basically field update, right? So P is a record. Y is a new value for a field and all I need to do is to update the field p contents with the value one. So let's let's see this. I mean, I can I can do this manually using the sort of general record syntax saying I don't like 42 anymore. I wanted to Now b

35:01  
43. And that's fine. And then when I look up what P is,

35:13  
then I see it's a, it's a reference like this, I can do the proper lookup to see the action value, and then it's 43. So that's all well, but I can also use this nicer syntax, which is p colon equal, and then maybe some new value like 99. And when I check now what the value is, it is 99. Right? So what can I do now with this? You can do imperative programming now, right? So let's, let's, let's play this scenario here. Let me again, define P. So this is, I'm now shutting out my old P. So P is a reference, the initial value is 40. To choose a reference ratio, ation value is 1011. Instead of one parenthesis missing in my file as well, that's bad. And then I can look up what these things are 42 then 11, then I can say, let q equals P. Here, there is nothing destructive going up going on. Rather, I'm shadowing out my old queue, which is no longer accessible if I execute this.

36:44  
In terms of imperative programming, what I've created now is kind of aliases. So. So there are two pointers, but the alias each other so they point to the same location. Yeah. If I now look up, P. It is what it was before, it's 42. But if I look up Q, or dereference Q, it is what P is. Because I made to point to the same location as what PB. Now remember, these are aliases. So I can update you.

37:27  
I see nothing here, of course, because it's an expression of type unit, also called a command. So it returns nothing. But I can now I can now see what has happened in the world. So you see, I updated Q, but I can now look up P. There's also 17. Although last time it was 42. And I sort of didn't touch it explicitly. But the point was, p and q are the same reference. Yeah, they are. They are two pointers pointing to the same location. So therefore, when, when you do look up, you do get the same value. Let's do some more things. Let's do some more imperative programming sort of, implemented in,

38:15  
in,

38:18  
in F sharp as convenience, these things are also provided for you. To see everything here is in comments. And again, I couldn't quite define it like this, because F sharp doesn't accept semicolon as a user defined operator name. But morally, the definition is this. So we can, for any command, and for any expression of type A, I can put them in a sequence using semi colon sign is the semi same semi colon sign that we see in lists, but here is used in a completely different function. It's also the same semi colon sign that is used as a separator in in both record types and records. But yeah, it's used here with a different purpose. And what does this thing do? More or less defined like this? it executes the command. Because I do this pattern match. Yeah, I want to evaluate the command. See, I could be interested in what it returns, but I can just throw it away, because I'm not really interested in it what the returns unit is or is the the empty tuple. Anyway, but, but the interesting thing is, while I evaluate it to throw away the result, the side effect is performed. So this is what we do. And then we evaluate the other that's nice because now I could do things like lead queue. For example, the Q plus Q is 17 write Q plus one. And I write semi colon Q, sorry, a bank u, which means when I execute this thing first, this guy, the command is evaluated, it returns nothing of interest. But it has the side effect. The value in the location cue points to changes so that when I do look up for the reference, as we call it, I get the new value. What did I do wrong? The title does not match.

40:40  
I suppose now this is just Oh, yeah, sure. Of course, when I when I want to increment cue, I better make sure that when I want to use cue for it, I first dereferencing. So we see we got 18. Yeah, so this kind of a thing is, is perfectly reasonable. So I can give a kid also to you as an example.

41:09  
So now we can write imperative programming, or imperative programmes. So let's write a simple function swap that takes two pointers, and swaps their contents. So it's very easy to do. So I want to swap the P and Q are pointers to integers, say I want to swap their contents, what can I do? Maybe I institute a local third pointer, which is initially zero. And then I can do the following. I update our to the dereference of P. So I put the value of what is stored, what is the contents of the initial contents of P in R, then I move the initial contents of Q to P. And then I retrieve the initial contents of p, which I have sort of temporarily stored in R and an update cumulate. The result is these guys have changed. Place. So let's let's write out, P is a reference, we initialise the 15 Q is a reference initialised to 32, then I evaluate swap pq, nothing is returned. So this is a command, it's an expression that returns nothing of interest. Or, you know, the thing to be precise, the singleton tuple, sorry, the empty tuple. But under the hood, things have changed. So if I now look up P is 32. And if I now look up Q, it is 50. So this programme was almost polymorphic. But it wasn't quite because I needed some initial value for my for for the contents of our and I put zero which fixes that everything here needs to be integers, I can actually write the polymorphic swap by doing something slightly different. So here, the intermediate guy, the local guy was a reference, but they can make the local guy to be a proper value of type A, and then I can write the simpler programme. So Id reference be I make this the value of the local name r. so r is directly of Type A is not of type a ref here. And then I can do exactly the same things as before. So R is already p, that's nice. And then I can do this. And then I can do this, the difference. Now here I don't use Bangor, I just use r

43:59  
which is good, isn't it.

44:04  
And the same effect will work. Let's do some more cool things. So here is also another thing that is provided to you. You can so besides sequence you can do loops, if you wish, like imperative loops in F sharp. So morally wildoe is defined like this, but it's not the syntax, right? Because while there is mixed fixed syntax, and users can't use mixed fixed syntax, or we can't what is it we can't use introduce mix mix mix operators. User Defined mixed mix operators in this language, but it's provided to you like this. So one takes two arguments B and C B is a Boolean C is something of type unit.

44:54  
I should also say this is not completely official because why it should be I mean, the language is whatever they say the language is restrict. So when you call while though, both arguments should be evaluated before you can go ahead, but that's not what you do, really, in the case of y. So what happens is we do, we check if b holds.

45:31  
And if it does, then we do C, and then we repeat while B to C again. Otherwise, from the beginning, we do nothing interesting. So I'm in the condition is true, then we don't have to execute any further command, we will if we can evaluate the ante topples, doesn't do anything. And then I can write the factorial programme in an interesting way, in a purely imperative way, so to calculate the factorial of n, what what,

45:56  
what,

45:57  
what can I do, for example, I mean, this is just one possible way. Let's create two references. So P is something where you store what you're currently taking the factorial of. So initially, it's n, but you're going to decrement it. Q is where you keep the sort of running, running factorial. So initially, it's one but you keep multiplying things on to it. And here's the loop. So while the dereference of p is greater than zero, update q by multiplying together the current value, you get by dereferencing q by dereferencing, p, and then decrement P. And finally, you're interested in the final value of Q, you can do this and you can calculate the factorial is not the only possible version of writing this imperative problem. We do some more things. Now you can do really cool things like private state, if you wish. So so here is something I'm defining a pair of two things, a pair of two functions, simultaneously using something local. And here's the cool way of doing it. So tick zero, and reset zero are both going to be functions one takes no interesting argument, but it takes the empty parentheses, sort of as a push for it to go. And returns an integer the reset also takes a push and returns nothing of interest. How does this work? So we locally use a counter which is initially zero, then we define the function takes zero, which takes a push. And then what it does, it increments the counter, and it also returns the counter. And there is another one, which just resets the counter to zero and doesn't return anything or interest. So this is why the type of typist and actually these two local functions are the ones that we also expose, because I returned these two, these two functions. What is cool here is that no one else other than zero and reset zero, which are two functions that are defined simultaneously have access to counter zero because it's a, it's a local name here. And it's actually a local name of type reference. So something that is local and is also mutable at the same time. Let's try to play with this. Let me do so that the reference sort of is already there in and shared between two functions that I've already defined, I've loaded them, there's nothing to sort of initialise in that sense. So the the private counter of these two is already zero. But when I don't think zero,

48:58  
it says the value is one. Interesting. When I do try again, the value is two, if I just to take zero, nothing happens is the function, it doesn't do anything before you apply to an argument. And this is why we've made things zero into a function because it takes zero wasn't a function. Then in some sense, the counter would run immediately before we give it the push. That's not what we want, right? Then I can for example to reset. This doesn't return anything but the counter inside has been reset to zero. Now I can click again. And it's not going to be three what is returned but it's one again, etc. This is nice, but this is just one counter. Perhaps I should write the phone that delivers me counters.

50:03  
And

50:05  
so that each time I want, I can have my own counter and then work with it by taking and resetting. And that's possible. What you then need to do is,

50:20  
is the following thing. So yeah, we defined counter with capital C, as a record type that has these two things stick and reset. Using should really, in some sense, perhaps want to think that it's more like this counter is a type of objects. And they have these methods taken reset. I mean, these fields are functions, and fields that are functions, you may want to think of them as methods, back officially their fields in F sharp jargon. And then I can define a function new counter, I should have given its type as well. New counter is something that will only need a push, so to say to go with what comes back is the culture. And how is it defined.

51:33  
So we defined a local reference counter with small C, which is initialised, to zero. And then we define these two functions can read that exact the same way as before. And then we make these guys the fields have a record of type counter with capital, see, this tick here is a field name, this reset is a field name, this tick, is the function I just defined. And this thing is the function I just defined. Now we can play with this, if I say, let's see one be a new counter, then I, what is formed is a counter see, one is no a counter. And its fields are some two functions, like can't see what they are, they are something the the action counter with small sees private or was private, rather, to the function that I just ran. So it's not part of this thing here. Yeah, but now there is some reference in the background. Let's see what we can do. We can we can make a tick with this counter. We can maybe make another one, then maybe I can make another counter.

53:05  
I also get something that as a tick can reset. And then I maybe I can make fixed with that one.

53:17  
It's not going to be three different countries running. This one is one. Maybe I want to now make a tic with the first one. That one is three. Now maybe I want to make a tic with the second one. This will be to know the second one will run past the first one. Maybe I'll make a tic where the first one again. What's the last video the first Anyway, it was for three now it's become four. That's how it works. Oh, okay. Let's do one more. Cool topic. This is the final one here. And it's really kind of advanced programming, but it shows you that now you basically can do all your pointer programming of the C language if you wish. But in a in a much more safe way in the sense that strong typing is here right? So whenever you point something, it is something of a definite value. So it's not possible to to do anything unsafe with with the pointer arithmetic of the style of C for example. What you say okay, I'm pointing to this location, but let's look at what is what is in the next location within the memory. Whereas we should have no control over how the memories like actually laid out we should not know what is in the next. Next cell that could belong to someone else really. Remember, F sharp lists ordinary lists. So lists are a recursive data type. And you can write, you can form finite lists, in F sharp, in C, you can, and they are singly linked lists right access through the head. If you want to get any, any, any deeper element in a list, then you then you have to traverse the list to that point, and you can extract the sort of current pattern in the sense that you've chopped off quite a few heads. And then the head of what is remaining is, the remaining is what you want perhaps. In imperative programming, like in C, for example, when you create the list, it gets laid out in the memory, you can actually do other strange things, you can, for example, to circular lists. Why? Because morally, every list this list, first of all, in some sense, are really pointers to the data structure in the memory, right, all references. And what you have at any stage is either allowed pointer, or is a pointer to a pair, where you have the head of the list and then you know, then recursively, a pointer to the rest, right? Again, again, a list which is a pointer to the rest. And you can create cycles here, because you can make the third cell to point to where you started. And then you could create the list 123123123, which is actually infinite if you were to print it out. This is not possible with the with the F sharp list. But it is possible if you if you do list, your own reimplementation of list using using references. So let's try to do something c style directly in F sharp. So I want to define circular lists over a type base. So this is going to be a polymorphic thing. A circular list is a reference to a cell for type A. So what is the cell for type A, it can be two things. So it is either nil. Or it's a cons of a head element. And then circular list again. And remember, a circular list is actually a pointer to a cell. So it's not directly the next cell, but it's a pointer to get whatever directly will even mean here. Interestingly, I have to define these two things simultaneously, or mutually because in the definition of series, I need to know what is a cell but in the definition of a cell, I need to know what is delist. So it's a recursive definition. But it's a mutually recursive definition.

58:03  
Right. And then perhaps we could introduce some niceties for ourselves, we could say the empty list is a reference to nil. So when I create an empty list, with a little push SR apply to nothing of interest. The empty tuple gives me an empty list when I want to cons two lists. So I've got a pointer to a list. And I just want to cons an element in front of it, then what do I do is I put them together as a pair. And this is the initial value of a new reference that I'm creating. I mean, I can either do ref nil here or ref comes something because I've got the reference of type cell and there is two forms of cell like an empty cell nil, or a concept, which is a pair of two things. It's very cool.

59:02  
And

59:06  
now I can do lists with cycles. How do I do it? My aim is gonna to morally build this list, but this is like an F sharp list. But I want to do a circular list. It should be morally the infinite list that has first four and then three 815. But then here there is a little pointer back to three. So then when you unfold it, you should get three 815 three 815. Again, I'm

59:33  
at inflaton. Right. So how do we do it? I do it with a local reference yes

1:00:07  
Which is initialised to nil. And actually here, it doesn't really matter what we initialise it to we just need some reference to a set of integers, I think is going to be a list of integers in particular right now.

1:00:29  
This is going to be entirely local. And then how do I use it? I update P. So what do you need, what it initially is, doesn't really matter. But then I do a really bad thing. I update p in a way that uses the same p again, but not p reference, but as a reference. So P is gonna be the following its cons of three, C cons, a 15. And then P. Again, so this is the value the new value of this reference. So I've updated it to this thing, this is what p now points to. And then further, I create a new reference, what I just comes for, in front of this, this list, circular list that already have in the memory that is called P. Yeah, so I do this command, sequence together with this thing, which is actually an expression, what does this expression return, it returns this type of reference, namely, it is a list. So I can now look at my list. I mean, all of this has been already logged, this has been executed. my list is something like this four, three, a 15. I doesn't want to show me any further, but it goes on the reason. One of the reasons it doesn't want to go show any further is that it goes. But I can now write something that allows me to take any number of elements from this infinite list, I mean, it's not a good idea to print it out fully anyway, because it's infinite. But we can print out any initial prefix of it. So let's see how to do it. So let's do some functions for for heads and pay your head for circular list. Easy. So a circular list is a pointer, hopefully to a cons. Otherwise, I can't take the head and then I just extract it and return X to do the tail. You also you dereference P and then I pattern match it against this thing, which means that so I read, I introduced a new name p which is what I return its value. And the value is the pointer, which is the tail of the list. Right, these ones can give errors because the pattern match is not exhaustive. I mean, not everything is is a cons here, the reference could also be nil. Once I'm in, of course, you can also complete the pattern match using option type. But let's not worry about that. And now I can do interesting things. So I can, I can take an ordinary list and convert it into a circular list very easy take an ordinary list for every when you see the empty list, you just create an empty circular list. When you see something less something like this, you recursively call list to see list. With sequence that's obvious, in the opposite direction, a circular list, I cannot in general, convert into a list because it is potentially infinite. Although I could, but then I have trouble when i when i when i want to print it out, because nothing will be printed out until the computation finishes. And this will be never if the circular list happens to be infinite. So I won't see anything. But I can do this sort of extraction of a prefix of first elements of a security. So for any number n and a circular list, I might want to take out n elements of it and return this thing as an ordinary list. So you may want to take out zero elements from anywhere I just get back the empty list. If I want to take any number of elements from a list that is actually nil, I mean, if dereference P and you see nil then of course, you can't take any more elements from very already at the end. Otherwise, if when you dereference p you see the head value x and and a pointer to some further cells, then you just make a recursive call. But of course from the rest you don't want to take n elements anymore because you've already extracted one you want to take n minus one elements. Now I can do for example c take eight elements from my list They see this. And I can take any number of elements from my list.

1:05:06  
And it really has very many elements, right? So I could take more. Just see it's the same repetitive pattern, it does have infinitely many elements. But this doesn't mean that my memory is full of this garbage, there is really a little cycle in the, in the kind of heap that I've organised myself. Now, let me finish by showing a bit of this programming with circular lists we previously played with a pen, let's do a pen here. There is really two ways of doing append. And this brings me back to what we discussed when we did list programming before. We said append is, is is is is what these are singly linked lists. I mean, even the ordinary F sharp lists a singly linked list. So if you want to concatenate together x's and y's, it's clear that you need to traverse x's. And actually don't need to traverse wise, but but it will be a linear time thing because you have to reach the end of the first list. But then the bad thing is you copy the first list, you recreate the first list for for appending. Yeah, what is you share that the the second list, I can recreate the same idea of the programme for circular lists that has this deficiency that you don't do concatenation quite in place, in the sense that you recreate the first part of the list that is possible. I call it yep, and zero here. So we take two circular lists, we get a third one. How is this defined, it's defined the same way as the other append. So two lists are given. And it goes by traversing the first list. So since P is actually a reference, I have to dereference, I get either nil or cons. If it's nil, then great. All that I need to return is the second list, which is actually a reference to its beginning, right, or to the first element, I should rather say. If the referencing p, the first list, I get context p, then it's clear that I need to create a new cell. So now I'm not occupying more memory, right. So what do I put there is the following thing, I form a pair of x. And the result is the result of recursive call and P and Q, which is a reference to a new list. Or say it's a new circuit cyclist, but that is a reference a form of this pair and sequence. What does it do remember the definition of sequence sequence puts the two things together, I'm sorry, with this constructor, data constructor attack cones. But it also says I'm using the resulting thing, then then

1:08:07  
to create a new reference. So see cons takes a pair applies the constructor comes to it, and then uses this as the initial value of a new reference. This is what happens.

1:08:25  
What am I

1:08:30  
let's try to use this connection. So let p be some cyclic list, I just form it from ordinary lists because it's more easy for me to do it. So Pisa circular list, which in this case doesn't contain any action circle, but it has that sort of potential to be circular we see. So, P is now a reference when you're the reference you first see columns one and another reference when you dereference that you see comes to and another reference and then there is the last reference is an old pointer. Who is a similar thing, when I define it properly,

1:09:11  
missing semicolon sorry. And then I can append P and zero p p and q.

1:09:21  
I got this 129 10 organised in this way. And P is still what it was p hasn't changed, and Q hasn't changed. So So P cannot possibly point to the same place. Where were these points here because if you traverse it, you'll go past one and two. After two when you look up the corresponding pointer there there you see nine. But here if I go down this pointer structure after two if I dereference the pointer It was an up pointer. So, so clearly p and q are different things here. I could also, of course, ask not P and Q, and p are different things here now. And I can I ask, also F sharp about it, and it says false. So this was like the sort of functional programming recreated on the level of the circular lists, we should think what happens if one of these lists is circular. If the second list is circular, we just add a bit to the beginning of it, and we get something that we get like a lot. So type of data structure. So first there are some elements, there is a non circular part, and then you enter a loop. And the whole result is an infinite list. If the first given one is already really circular, in the sense that there is some actual cycle there, then of course, since cfn, zero requires that the first list is fully traversed, then the attempt to put together a circular list with a real cycle and some other lists, will will will result in a function that just doesn't terminate, it will go on forever. This must about circularity. But now actually, we can do in place concatenation, that will have the same property. If the second list is infinite, you're fine. If the first one is infinite, you're you're not good because you're traversing the boat. But the new version is better, if you wish, depends on what you mean, by better in the sense that it does concatenation in place, you've got these two lists already in your memory, I mean, they both are references to both point to somewhere in your heap. And the good append should just connect together the end of the first list and the beginning of the second list. And then after this rearrangement,

1:12:18  
the first list so to say has become the concatenation of the two. Yeah, because the first list was a reference after all. Now, the result is also a reference but it is to the same place. So this is implemented in terms of a command. So back comes nothing. But the new value, or the new contents of P is the new list. Let us see how this works. append pq, Id reference p, when I see Neil, I just update

1:12:59  
p

1:13:02  
not to have needle as its contents anymore. But to have as its contents, whatever cue points to.

1:13:12  
And Cons is also interesting. Old cons had to actually look at values, these cons doesn't look at anything. So when you when you when you're in the cons case, if p is con, something con something and another p, you just have to recursively go and do applied p to the tail. Yeah. And you return nothing. The result is a is not returned as the result of this function. The result? You see if you if you evaluate p again, then you see what it is. Let's see what happens. This is really interesting. So remember, p and q are these things. So P is maybe we just show them one. P is this thing. Q is this thing. So P is more or less the list one two, Q is the list 910. Let's do this new append. This is no longer CFS yet with append, append pq. See, nothing comes back. Because append is a command. Yeah, we see here the in the base case, this returns. This just returns you know the the empty parentheses, the empty tuple no information and the second clause has to have the same type as the first. So nothing is nothing of interest is returned. But something happened under the hood. If I check p n up there, if I check p then I see 129 10. So what happened was instead of this Neil, this thing has appeared here and this is the new value of p but when I look at what Q is He was still the old nine. Right? Let me then finish off with one final thing. So there is also mutable names, which I actually did recommend. So we saw that we could update fields have a record. Actually, you can also make updates to two simple names, if you declare the mutable and you have a similar updating syntax with with left arrows command. And here's an example. So if you do, let i equals five, then you've defined the name I, if you then do let i equals i plus one, then you have a new sort of more local or enter name I, whose value is the old I in the old I should say is the outer i plus one and the authorised From then on, from now on shadowed. So this is six. And you see, both are defined with length. So this is one definition, this is a more inward or more in our definition, more enamel, you have more definition. When I check the result of I it is six. But the point is not that the not at any updates happen, there is just two eyes in the scope, kinda but the outer one is shadow down. So I don't any longer have access to it, because I happen to reuse the name. If I declare I immutable, like we had this field record, in a similar thing, the syntax, then I do something else. Here I define a name i and i initialise. Its value, it's now a mutual name, I initialise, its value to five. Now I can change it. But this is not the definition. This is a command. So that one actually returns nothing of interest, it gives us nothing. But when I look up Hi, it is six. And now it's not the case that there were two different eyes around where the inner one shadowed out. The outer one is one single eye and it actually changed in value. Why are immutable names dis recommended? Or why would at least I discourage them is that if you use mutable names, you can't see what is mutable and what isn't just by looking at types of things. Because all of these eyes here are integers according to according to F sharp. In contrast, when you work with references, then there is a clear distinction of values and references to these values. And whenever you see that something has type t ref. You know, it is immutable thing. Whereas when something has type t, a simple type T, like maybe teasing, so it's a difference between interest and int, then yeah, but if it's a reference, then it's mutable. If it's not the reference is not mutable, and everything is very clear. So this is a nice discipline that you have by working with with references, but it only actually applies if you if you do not also at the same time use mutable names by which you make mutability, sort of invisible on the type level. Right, so that was the lecture of, of well today. I'm stopping sharing here. I'm no stopping. Also recording

Transcribed by https://otter.ai
2:38  
Hello

2:41  
Let me check if we have sound can? Can you hear me? Yes sir. And I can get you as well, which is great.

2:51  
Very good.

2:53  
So, we will go to a new topic today, which is following the book by better this stuff about programming language concepts. We'll first spend a bit of time on something that is common to every type of programming language, namely expressions.

3:15  
And I'll talk about expressions names, local scope, sort of general principles,

3:23  
sort of on the intuitive level, but also what they really mean and what are some important corner cases to understand how they work. And then how could you possibly implement such a thing if you were to write your own little language.

3:39  
And then we'll get closer to things like lexing and parsing as well in which we don't go very deep. But this is the question of, if a programme is written down as a file or as a string, how do you read the abstract syntax tree out of it, which is on the level

3:57  
on which we actually want to work with programmes. So let's do like this that

4:04  
if you have questions, please just shout because I'll start sharing my screen and I hope I will really hear you like it. He's a case now.

4:16  
share my screen.

4:25  
Yes.

4:27  
Very good.

4:34  
make this

4:35  
even better.

4:37  
Okay.

4:39  
I want to talk about expressions.

4:43  
To start with, in a very simple programming language. I'd like to write stuff like numerical expressions of the sort 17 or 42, or maybe one plus one

4:58  
or maybe two

5:00  
Two times three, or maybe

5:05  
two times three, plus one

5:10  
to start with, and then a little later today, I'd like also to introduce maybe names, perhaps be able to write things like two times x plus one, rather than just two times three plus one.

5:27  
And I'd like to emphasise sort of different phenomena that can occur here. so we can write down expressions as strings, which is what they are here.

5:38  
This is not the format in which you really want to process them. So abstractly, when we write down an expression, we mean something else. Like for this expression here,

5:49  
when we've seen maths long enough, we know that this is kind of a three immorally, where at the root, you have plus and plus has two arguments, which are these are these. And this little thing, also, internally, we should think of our This is something that has multiplication as its main symbol. And perhaps these two things, as some smaller sub expressions. So on one hand expressions are strings. But that's not how we want to process them. If we work with a programming language, we want something sort of more structured.

6:27  
And then of course, one must be able to convert between these very flat string are five representation. And this more structured representation, which we will see here, and which is often called asds, or abstract syntax tree.

7:01  
ust stands for abstract syntax tree.

7:06  
I'll start right away and showing how this works in in F sharp if you were to implement a small language, and then we discussed what we can do with it. So naively, of course, you write expressions in order to, to express some computation you have in mind, like here is an expression, perhaps it should some value, perhaps you to the Indian end of the day, the 17. This is the case when x is eight, right? But there is some computation behind. So if you see such an expression, you don't know what X is, perhaps you need to look up x somewhere, then maybe x is eight, then maybe you need to multiply two by eight, you perhaps get 16, then you want to add one, then you get 17. So this is the computation, that an expression as a programme leads to and in the end, you get a value. This is where you write down expression. So one of the games that we will play is given an expression, find its value. For these very simple arithmetic expressions that do not contain any variables or names, it looks straightforward, okay? In some sense, you have to process the string or abstract syntax tree, but it's pretty obvious what you need to do. When you add names, it gets a bit more complicated.

8:18  
It gets even more complicated when you have local names and scopes, which is what we will see very late today, but more likely on Thursday.

8:28  
Okay.

8:31  
So but let's first deal with a simpler situation where we have expressions like this, so no

8:39  
names, no scoping, just flat expressions, in the sense of scope.

8:46  
But of course, non flat in the sense that we can have multiple operations here and

8:52  
some operations need to be done before the others.

8:58  
What do we want to allow to be? To begin with, I'd like to allow these things. So let's agree that we can write down integers.

9:07  
So an expression can be an integer.

9:10  
And on this level, we don't really care how the integer was written. So 42, could be written as 42. It could also be written as Oh 42, it doesn't matter. Maybe for some really big numbers, you can use the exponent notation.

9:25  
So all we care about is that an expression can possibly a numeral which is always an integer, then on this level, and then there is only one other type of expressions for the time being operations that look like

9:40  
some operations symbol, combined with two expressions.

9:45  
And on this level, we pretend that we don't actually know ahead of time, which are all of the possible operation, symbols that that come into play. So we just represent operation symbols as strings. So plus,

9:58  
could be one of these as

10:00  
A string of times could be another, maybe we'll allow minus four for subtraction.

10:07  
Okay, let's play this game.

10:24  
This

10:33  
I can now write down simple expressions like 17 could be written down as an expression.

10:42  
And F sharp agrees, because this is how I define my data type, I can also write slightly more complicated things. So here's another one,

10:50  
three minus four. On this level,

10:54  
you have to represent it like this, right? It's, so what is this expression, it is an operator application expression, the operator itself is minus. And there are these two expressions as arguments, both of which are numerals one is three, the other one is four, I can make a more complicated expression. Now,

11:13  
I can make the multiply the whole thing with two, I can perhaps

11:18  
want to represent it like this then.

11:26  
And this is another legal another legal expression.

11:33  
Notice that, in these abstract syntax trees, I don't need to worry about precedents, because I, myself expressing the expression already on the level of a tree, not not as a flat string. So So here, for example, I indicated that this minus binds three and four tighter, so three minus four is this part, and only then two times is applied to it. So if you were to write this thing down in concrete syntax, you have to worry about parentheses, because justice is not okay.

12:09  
You need to write like this. But then this three notation, this is already present, right.

12:16  
So the way to think of it, let me stress once again, this is

12:22  
expressions here are a data type. But really, there is two forms to two form values here. One is kind of leaves numerals that are labelled with integers, or Num, num nodes labelled with an integer. And the other ones are internal nodes, which are always of the form some label which is a string.

12:43  
And then two sub trees, which are recursively expressions in their own tour.

12:50  
So far, so good, but I haven't done anything, I've just given some way to define a syntax, there is no way to compute here yet. There is no way to see these expressions in a nice form. This is a pretty unreadable format, although it's very nice to process for the language. Also, there is no way to write expressions in this customary syntax like this. And,

13:13  
and, and have the system understand them. So we'll have to get to all of these. For the moment, the only thing we have is expressions as a data type of abstract syntax.

13:32  
This makes sense. Shout if something is

13:36  
not good.

13:44  
Let me introduce some, some some important terminology before we go on and do something more interesting.

13:54  
pretty often in this kind of an exercise that we are engaging in, you're talking about an object language, and a meta language. So these are nice words to know.

14:04  
An object language is the word for the language that you're currently studying. So we're looking at the language of expressions.

14:13  
And you maybe conduct this study in some other language, that would then be called a meta language. So, here F sharp is a meta language in which I write I write expressions or I work with expressions as an object language. Meta is the kind of thing above you for which object is the is the thing under scrutiny.

14:37  
I already said this, but let me still repeat. So expressions as we today handle them are abstract syntax, also called Abstract Syntax trees are asds. A programme normally works with concrete syntax. You don't want to ever write anything like this. You want to write things like this, this or maybe this.

14:59  
So expressions

15:00  
in concrete syntax, they are strings. But of course, not every string is a valid expression. So expressions are some particular subclass of, of strings. That might make sense. Yeah. And then there are some processes associated

15:17  
with concrete and abstract syntax. So you write concrete syntax. The machine likes to work with abstract syntax. So going from concrete to abstract is called parsing.

15:30  
So you're given a string and you try to make sense out of it. As a programme, you hope the string is a valid programme, maybe in particular, and expression.

15:40  
parsing actually goes in several phases. But but but often you give the name parsing to the whole process. You could say parsing perhaps consists of lexing and parsing proper, we'll get there. But for today, this is just parsing.

15:54  
There, sometimes you need to go the other way, right? You're seeing these humongous things, they look big. And this is a little tree, and they've already looked B, you just want to see them in, in. In customary user friendly concrete syntax, if you want to go from this to this. This move is called predict predict.

16:18  
So that's going from abstract syntax to concrete.

16:24  
Yeah, this fine by

16:27  
for the time being. So forgot, we're looking at two things, we're looking at strings, which are concrete syntax trees, which are abstract syntax. And to

16:37  
work to directions of translation parsing goes from concrete to abstract pretty printing goes from abstract to concrete.

16:46  
So for these words, not to remain too abstract, let me do a first implementation of a simple thing. parsing is complicated. But pretty printing

16:57  
is pretty easy to do, at least on some level, maybe not super pretty, but at least somewhat pretty.

17:05  
So here is the not so pretty, pretty printer that we could consider for this tiny language of expressions. It doesn't do very much, but it is

17:16  
it is more than nothing.

17:21  
So what did we say pretty printing was supposed to be pretty printing has to go from abstract syntax to concrete.

17:29  
So here, I'm defining a function, or actually the author of the book, I've just copied it defined a function from Abstract Syntax trees, which are this expert data type here, things like this,

17:43  
too.

17:45  
Concrete syntax, which are just strings,

17:51  
expressions, the abstract syntax, our recursive data type expressions are defined in terms of small expressions.

18:01  
How you typically process

18:04  
values in a recursive data type is by recursion, you look at cases. And in the non base case, in step cases, you try to reduce your bigger problem to a smaller problem, which you then don't solve yourself, but you leave it to recursion, so to say to worry about. So let's see if we can conduct this exercise.

18:26  
So what could be the simplest way of turning numerals and operator expressions to

18:36  
strings in a meaningful way so that they are at least semi nice to me?

18:43  
Well, here's the first try.

18:53  
If you want to speak I can't see that. Yeah. I was wondering about the type expression critical, critical orthodox question above.

19:03  
Yeah, I wrote it, because I couldn't because I don't see any arrows.

19:08  
So I don't quite understand what's happening.

19:11  
So we're talking about this definition right. Yeah, exactly, there is nothing more okay. So, this is a this is what what an F sharp is called a data type or a discriminated union type.

19:24  
You define these types, by giving a number of data constructors are tagged as they are also called here that are just two of them. Known an op.

19:39  
And these will work as functions that kind of don't do anything in the sense that they are purely syntactic that take arguments of specified time here. Non takes an integer of takes three arguments as a tuple string, a string and expression and an expression and what both

20:00  
To return our expression. So when you've written such a tight definition, what happens under the hood is

20:09  
you will get these functions.

20:18  
No, which actually goes from incorrect squirt. So this is one way of making an expression out of an integer, integer. And you'll see an example case here. So num of 1717 is an integer, but no more 17 is an expression already. And the other one that you get is Oq, which has done this type

20:39  
all of those, so it takes a triple and gives an expression.

20:45  
Now, when you would ask what do these functions do, they don't really do anything in the sense of computation, they just syntactically so to say, for new values, when 17 is the value of type int, num 17 is a value like this, you can simplify it any further there is nothing you can compute here.

21:06  
But it is already an expression. So this thing is a value of type expert, similar here for up. So if we already convinced ourselves that no three and no four are valid expressions, then I can form this triple of a string and two expressions. So now I have a triple like this. And when I apply off to it, all of a sudden, I have an expression.

21:31  
And by iterating, this procedure, of course, I can create deeper and deeper expressions.

21:36  
deeper in the sense of like, deepest a tree or highest a tree, depending on which way your trees grow. Does it make sense? Yeah, makes sense. Thanks. This is also similar to how for example, lists, empty lists and cons work, they don't do anything, they are kind of value forming operations. or similar to how love and burn worked in my example of node labelled trees the other day.

22:00  
So we can do these things. And okay, one thing I didn't say, these these data constructors are tags, they are special functions in the sense that you can actually use them to form patterns. So when you're given an expression, you can say okay, please show me what kind of expression you are. Are you a gnome, or are you an expression?

22:21  
And that is useful then for case distinction when you define functions. And an example is already here, right? So given an expression E, we can ask are, you know, of some integer, or IOP of some string and two expressions.

22:38  
So, if I've got, if I mean the numeral case, and I'm given some integer,

22:44  
I can just use the built in function that converts an integer to a string. Actually, there is this function string that is pretty polymorphic. It, it converts values from any type, it can handle two strings, in particular integers. So we don't have to manually need to worry about how do we turn like 17 into a string 17?

23:08  
And what's the reasonable thing to do when you get an something like this opp s e one, e two? Well, here, we are the in this situation, when we

23:20  
say, Well, perhaps the good idea would be to reduce the big problem into smaller problems. And then hoping that recursion then reduces my smaller problems into even smaller, even smaller events, all the smaller until the problem goes away. So to say, we reached the base case, everything in the end, we'll have to reduce to numerals because we've got nothing else as basic building blocks in our expressions.

23:46  
So I better find out how to how do I pretty print my two sub expressions, e one, e two,

23:54  
E, B, I'll put it on the next line is easier for you to read.

23:59  
And then what should I do? Well, reasonably, I should perhaps put the operation symbol between the two strings that I get this way. So that's here.

24:08  
Maybe it's nicer to read the file to leave some whitespace.

24:14  
And maybe that could be it. But remember, the three structuring my expressions also fixes which you know which operations are applied. First, to which arguments. So perhaps, a good foolproof way to make sure that the strings I get are unambiguous would be to put parentheses around every sub expression. Does it make sense?

24:39  
When this is excessive care, I don't really need so many parentheses. But to figure out what is the minimum amount, I should somehow know something about the presidencies of the operators and their association, but I don't so so let me just let me just do the simplest possible thing here.

24:58  
Does it make sense?

25:00  
If it does, then you can, I don't know, we can share.

25:05  
But otherwise, we could just try to play if we cannot pretty print anything, maybe I'd like to print it open up here. Maybe I'd like to print the print

25:15  
the simplest possible expression, which is

25:19  
numerous numeral 17.

25:23  
What I get back is 70. Not much big surprise here. Let's take something more impressive. Although I suppose at this stage, I can't really impress you at all, but it will come later today.

25:37  
So if we take this one,

25:40  
which already looks pretty bad and difficult to read, if I pretty print that one, then I get three minus four. And since I was careful, I also see these parentheses. Yep.

25:51  
Let's do one last one here.

25:55  
actually like to take this complicated one from here.

26:08  
And I don't get what I promised, right. And here, it's really important that I put parentheses around three minus four, because if I don't put any parentheses, then it's not clear. Which one is meant to be the stronger one of the two operators here.

26:29  
Because we've not said anything about times or minus, they're purely formal here.

26:38  
Okay, so you've seen a bit of 3d printing, but of course, it's very primitive, in particular, we produce too many parentheses, one can fix this, this is this is one of the games with which we will play a bit

26:51  
in the exercises, the idea would somehow have to be as you traverse the abstract syntax tree, the expression,

27:01  
you have to look at the the the operators symbols that you see. And depending on how their presidencies and association are, you make decisions about

27:15  
whether to print any parentheses or not. And, you know, with with the appropriate strategy, this is not hard at all. But for the moment, I want to talk about completely different things.

27:30  
So, we've done one direction of this translation, in, in a not very pretty way going from abstract to concrete, concrete to abstract I leave for the next week altogether.

27:42  
But for the time being, I want to discuss something different expressions are programmes, programmes are meant to run, which means they're meant to compute something. In the case of expressions, of course, we're interested in what their value is. Yeah. First, as long as we don't have any names, this computation is pretty primitive is like of the sort that you do on a like a pocket calculator if you know what disease or mean there is a corresponding programme in your in your phone right. in old days, we have these calculators. So we should be able to to mimic

28:19  
the functionality of a pocket calculator at least.

28:29  
This will again take you through some terminology. So simplification of expressions is often called or, which is supposed to lead to value is often called evaluation.

28:41  
Yeah, find the value of an expression.

28:45  
And this can be done in different ways. One is that you don't combine the expression into any other sort of more primitive programming language, but you try to evaluate it directly. So direct computation of programmes is often called interpretation. Yeah, interpret that. Like here, I'm working with the F sharp interpreter. I don't produce bytecode of CLR or anything or dotnet.

29:18  
I directly give F sharp programmes and want an answer.

29:25  
Similar thing for these expressions. If I directly want to work with them and reach an answer, without going through any other sort of helper language, this is called interpreting

30:11  
Okay, so what would I need on earth for interpretation?

30:16  
So I've got expressions like all of those here. What should I do to find the value? Like what should I do to find the value two times three plus one?

30:26  
Well, this is such a simple language that the process is not so different from,

30:35  
from pretty printing by its nature.

30:39  
So pretty printing went by traversing over the tree.

30:43  
And doing little actions to produce a string here is the same, I should just analyse my abstract syntax tree. And as I look into it, so to say, I will be able to, to define values Why? Well, because for numerals, we know what their values are two is 2331 is 142, times three, I already know this is six, because two and three, I know values four. And for the whole thing, I know that this is seven provided this is that I already found out that this was six. And then all I need to know to do is to add together 16 one, right, so in some sense, I should walk down the tree, and then walk back back up again, and just accumulate or calculate the value based on the values for for sub expressions or sub trees. So let's see if we can do this.

31:40  
Well, this needs a bit more of pattern matching, but not so much more, right.

31:47  
So what do we need to do? I'm writing here an evaluator that is often called eval or something like this. That is supposed to be a function that takes an abstract syntax tree for an expression to a value from the data type expert.

32:04  
And what I want back is what the expression should simplify to, which in this case, are just sort of naked, sheer integers.

32:14  
This goes by inspection of the expression and also by reducing bigger problems to smaller ones. So recursion, and, and magic.

32:26  
If I'm in the numeral case, my exercise is very simple. So I already have an integer, it just comes with this tag, I throw away the tag, I just extract the integer.

32:38  
If I've got

32:40  
an operator,

32:45  
sure.

32:47  
Then I need to, sooner or later look deeper into the string here, because depending on what the first string argument is, I may need to do different things.

32:59  
Yeah, let's agree that plus is for addition times it's for multiplication minuses for subtraction, as is customary. There could be more operations, but let's not bother about more. So let's say in the other case, we just don't know.

33:13  
And then what's our exercise? How should the addition work? Well, I should use the addition of integers as provided to me by F sharp.

33:22  
And then I suggest use the fact that recursion can handle my smaller problems and smaller problems here are to know the value of the two simpler, direct sub expressions of the given one, isn't it?

33:44  
notice some things are happening here. So

33:50  
all these three cases here are very similar. And what happens is that I've got some operation from the object language.

33:59  
And actually, I use a trick that you often do, I just use the corresponding operation of the meta language.

34:06  
Yeah. So expressions know nothing about addition, they're just, well strings. So represented in a glorified way is Abstract Syntax trees, they are sort of dead, dumb things that know nothing about anything. But F sharp knows a lot about everything. So in particular, F sharp has an interpreter which already knows what plus is about plus is addition. And we just reduce plus from this language, which so far, didn't have any meaning to, to, to code in F sharp language for which we have meaning provided to us by the F sharp interpreter.

34:47  
So we reduce

34:50  
exercises about the object language to exercises

34:54  
about the meta language but we don't translate to the meta language we never produce code in the meta level.

35:00  
Which, rather, the interpreter itself is code in the meta language to see this, I mean, I've got some fixed F sharp code, I don't produce any new code.

35:10  
But this new code will work for me as a as an interpreter.

35:15  
Let's see if this works. So suppose if instead of pretty printing, I want to have the value of this expression, known 17,

35:28  
I can know what comes back is just an integer.

35:31  
If I take the other one

35:34  
that I had, and instead of 3d printing, I just want to evaluate it,

35:39  
then I get minus one. So what happened was

35:45  
num three has value three, no four has value four. And then we just use the capability of F sharp to do the subtraction for us.

35:56  
And that is it. So our

36:00  
F sharp code has become an interpreter for the expression language. And the F sharp itself is interpreted by the F sharp interpreter.

36:09  
And I can also take the get more complicated expression.

36:15  
And ask it also, to evaluate this one. Now I predict minus two, we'll come back because the smaller sub expression here should have value minus one. And then what remains is multiply two by minus one, which should be minus two. And that's what we get.

36:36  
This so far Make sense? Maybe it's even very primitive.

36:42  
But it's important to see the different levels here, right object level meta language.

36:48  
And the fact that we are doing meterpreter,

36:52  
which we just

36:54  
write down as a piece of meta language code that executes.

37:02  
Copy

37:04  
is at least someone happy. Yeah, extremely, very good. content, if there are questions to ask, because I can, I can rush quicker, or I can go slower. Let me raise another point.

37:17  
Which is, again, to sort of

37:21  
emphasise the fact that this expression language itself knows nothing about anything. So it's, it's just strings that we perhaps have already converted into these nice Abstract Syntax trees. But they don't have any innate meaning. I could very well, I mean, I wrote some evaluator, and this sort of fixes the meaning for them. But I might write a slightly different evaluator, that might give a slightly different meaning to my expressions.

37:50  
And that's sort of also okay.

37:54  
So, when I write minus here, there is nothing that forces that the implemented by the F sharp miners, so there is nothing that forces that I intend subtraction here, I could very well intend something else.

38:08  
Here's a little example. So we we assign minus a different meaning, simply because we can write so this is the

38:18  
so nice feeling of the power of freedom, no one can tell us what to do. So we do what we want. And

38:27  
I've chosen the following thing here.

38:32  
It's sometimes nice to actually restrict these integers to be naturals only. So we could we could strive for,

38:42  
for all our values that come back to be natural numbers. Plus, and times don't take us out of the realm of natural numbers if we start out with natural numbers, but mine is of course can because the second number can be bigger than the first.

38:55  
So let's play this game that we evaluate

38:59  
both of them.

39:03  
But if the if the difference

39:07  
is negative, then we just return zero. So we basically truncate subtraction is zero, we refuse to go below zero.

39:19  
This should be possible. Let's see if it is. So all I need to do is I do eval m,

39:28  
maybe first to this one.

39:33  
Now hear three minus four is minus one.

39:37  
So

39:40  
I might be like one of these flatters theorists that says, there are no negative numbers.

39:48  
So I just refuse to see them. And then the way to to go on with my life is to say this is zero and this is it. And this will of course, percolate through more complicated expression.

40:00  
So for example, I had this one.

40:06  
So now, when I multiply this by two, of course,

40:10  
this is zero, even if I multiplied by minus two, which should

40:17  
take minus one,

40:20  
two plus two, I will not get there because I've already replaced minus one by zero.

40:25  
So this is fine. But But of course, you can do crazy things, right? You can completely obfuscate

40:32  
your code or confuse everyone, for example, by just swapping the roles of these two things.

40:38  
And there is nothing prohibiting me from doing so. Right.

40:44  
So

40:46  
I may well do this, when this gives me some sort of a meaning some sort of semantics for my expression language. It disagrees with what you might perhaps expect.

40:59  
But then, so what so I'm free to do this.

41:03  
Just to just to keep in mind, syntax itself knows nothing. So semantics is a way to assign meanings to pieces of syntax. And in principle, you can do it in any way you please.

41:32  
One way to restrict your

41:37  
freedom, though, which is natural is, if you say, you want to remain compositional, so it's reasonable to want, that the meaning of bigger expressions is made out of meanings of its smallest sub expressions, this is called compositionality.

42:14  
But this should be

42:16  
okay, so how far have we got that we spent 40 minutes. And I've not done so much. But But this pattern will repeat. So therefore, it's very important to understand what I'm doing now. For the moment, I'm not doing very much. I've introduced you a little programming language on the level of abstract syntax trees. So I don't really very much care about the string representation of this programming language or what people call concrete syntax.

42:43  
Although I've shown you how to turn Abstract Syntax into concrete by giving you a very simple, naive, pretty printer, but more importantly, I've shown you that I can do evaluation,

42:57  
which is

42:59  
writing an interpreter by my own for my little programming language and this fixes what everything means.

43:08  
And the typical way is, since expressions are given recursively as a recursive data pipe as these are given recursively you define the corresponding functions also by by recursion.

43:20  
interpretation as I said, meant that you try to execute the programme directly. So, here, you go over the tree and you you just do some little computations and you get the result.

43:36  
a different approach that will often has torn programming languages, especially if you want to use one and the same programme many times and you're after efficiency is not to evaluate programmes directly on input, but to what is called compile them combination means you turn a programme into another programme in a different language, typically simpler or more low level or say more machine

44:07  
friendly, closer to the machine more assembly like or fully assembly

44:15  
just machine code. And the idea is then that this should run more efficiently because the interpreter each time it runs has to essentially also understand the code or say

44:30  
in some sense, the interpretation may need to do more complicated computations than when compiled code may need to do

44:40  
and also often optimise, sorry, compilation involves an optimization step where you try to discover something in the programme that can be done simpler. So you've put some sort of intelligence you might call it artificial intelligence if you want into your compiler. So it does a little more than just translation is like translation.

45:00  
But modification is one of those.

45:02  
So let me give you an example of this here as well.

45:06  
So even for this very simple language of expressions, you might want

45:13  
to

45:15  
not interpret expressions directly. But to compile expressions

45:23  
into the code, have a little machine, a little snack machine,

45:28  
and then interpret the stack machine code. So then execution goes in two phases, first compile from expressions to stack machine code, that then interprets that machine code. So rather than using a more complex interpreter, we should be using another one for a lower level language, which then hopefully, is

45:50  
sort of more primitive and hopefully more efficient, in some way. Let's not go into the details of this right now. But I'll give an example.

45:59  
Um,

46:02  
so this is actually how a pocket calculator works more or less.

46:11  
If you've heard about the reverse Polish notation, this is actually what we will compile things to. So maybe I should first actually

46:20  
exemplified on our own a little example. So we have this example piece of code here, two times three minus four.

46:40  
I'm, so that's an expression.

46:44  
I'd like perhaps to translate it into machine code,

46:49  
machine code to be more precise,

46:52  
which will work roughly like this.

46:57  
I would say push to, I'll explain what this means.

47:02  
Then perhaps, push three,

47:07  
push four,

47:10  
then apply minus,

47:13  
then apply times.

47:18  
What's this?

47:26  
Has anybody seen this?

47:32  
Nope. So this is often called reverse Polish notation. To be honest, I don't know. I mean, what was I supposed to do with it.

47:41  
But the idea is pretty similar. So this is what is happening more or less.

47:47  
In every

47:50  
implementation of a programming language, you work with a little operand stack.

47:56  
And the idea is,

47:59  
you work with a stack, Does everybody know what the stack is? stack is, it's a kind of memory structure into which you can throw elements,

48:10  
you can store elements there. And then the only way to do this is to put them at the top of the stack. So you think of it as a stack is kind of a pile,

48:21  
like a pile of paper on your table. And you're only allowed to, to, to add more sheets of paper on the top of the pile. And also, what you're allowed to do is to take sheets of paper from the top of the pile and maybe apply some operations to them. You're not ever allowed to go deep inside the pile, and, you know, take a sheet of paper from in between some other sheets of paper. Yeah, does it make sense, then you could play this game. So this is almost like lists. And of course, you implement the stack via list, because list has this list have this property that the only direct direct access is from the head, you can, you know, you can compete off header elements from a list and you can cause new elements to the front of the list.

49:06  
And of course, you can also go deeper to the list. But this basically means that you peel off many elements, then you take out something and then you You, you, you connect these elements back onto the onto the list. So this really corresponds to pushing elements into a stack and popping elements from a stack.

49:23  
So one way to do this little calculation is to say

49:27  
I work with a stack.

49:29  
normally write the stacks vertically, but this is very difficult for me to do on the screen. So I'll write them horizontally. So first, my stack is empty.

49:39  
Then when I execute this to my stack will be two. So there is exactly one element there. Then I'll push three. So then the stack will be something like this. Then I'll push four, then the stack will be something like this.

49:57  
Then I do minus, minus is very simple.

50:00  
And distraction, it basically says, take the two top elements of the stack and subtract the first from the second in this order, because that's the order in which they went there, then the result and push the result back onto the stack, I'll do this, then the result is this.

50:18  
And then I should do times.

50:22  
And the idea then is, again, I take two of the top elements of the stack,

50:27  
multiply them together, push the result back on the stack. And then the result is this. You see, the stack went different states.

50:36  
Throughout this computation, I started with the empty stack and raw. At the end, the result mysteriously is this thing that I wanted. So this was sort of correct machine code for doing exactly this evaluation thing. So the idea is, these elements that are deep in the stack, they correspond to some values that you still need to apply some operations to, but for the time being, they are pushed, while relatively further down in the stack, they are waiting their turn. But

51:12  
at someone they at some point, they will bubble up and then bubble up. And then I use them like here, these two goes to the bottom of the stack. Then other things go on the top, do some work with them. So here I do subtraction for for example. But then the time comes when I actually need this value to

51:30  
I use it in multiplication, I get this result, does it make sense?

51:34  
know how I got from here to here. So that I get the correct result. Of course, I didn't tell you. So for the time being it's kind of like a rabbit from a hat.

51:47  
But But there should be some procedure.

51:50  
And this, in some sense is very simple code in the sense that this is just a sequence of instructions, like push two on the stack, push three on the stack, push four on the stack to minus which means pop two elements to the operation push the result back. And this is similar.

52:09  
There is just a straight line sequence of instructions, no jumping, no, no, no conditionals, no nothing. It's a simple straight line code consisting of simple machine instructions.

52:22  
Let me now describe my machine knows what the instructions are.

52:29  
And then we can play with this. So my goal for the next 20 minutes perhaps is

52:40  
give you the language of the machine code,

52:44  
which is basically so machine code code looks like this. But again, we write it in some abstract syntax,

52:52  
which is given by these two types.

52:56  
instrument code are actually stands, I think, for register.

53:02  
Later, there will be registers as well, for the moment you don't see them.

53:07  
But they will come one way or two introduce names.

53:12  
So I'll give you the machine instructions, I'll give you the little evaluator or the interpreter for the machine. And then I'll give you a translation, a combiner from expressions to stack machine code,

53:25  
and wine here. So far, we

53:29  
executed the expressions directly. This then will be the first sort of example of this workflow, when you don't execute programmes in a language directly, but you compile to a different to simpler code language, and then interpret that language with its own simpler interpreter citizen. Does this make sense? So there's two workflows, we will have for expressions, one is direct interpretation, the other one is compiled down to machine code

54:04  
and then interpret that.

54:07  
And if everything is saying, Well, nothing is saying in this COVID world, but if everything is is saying within this lecture,

54:16  
then the two workflows should lead you to the same results, right?

54:21  
So we just illustrated that the same language of expressions can be worked with in two different ways.

54:28  
I could perhaps say the interpreter is my language specification expressions mean whatever the interpreter

54:36  
does with them. And then we could have it as our task to write the compiler that is faithful to the interpreter in the sense that it agrees with the interpreter. Of course, one could also play the game the other way around, we could say no, no no.

54:52  
Stack machines we already know we know how stack machine is interpreted. And now the semantics of the expression language is fixed.

55:01  
By the compiler, so the compiler determines the compiler is the language standard, the compiler says, What expressions mean? And both? Both ways of going about the language are also feasible. And people people do both in real life to real languages. Yep.

55:20  
Okay, so let's look at my, my simple machine code language. Now it's, it's this part is given by two types.

55:31  
Sorry, not given this much.

55:36  
It's given by these two types.

55:40  
So on the top level, I work with tech machine code. But the code is just a sequence of instructions. So it's a list of instructions.

55:51  
So top mostly a piece of code is a list of instructions, what is what is a single instruction, a single instruction,

55:59  
you know, their language is fixed by a data type. So there is a number of options with different tags given that form instructions for you.

56:08  
So most of these tags don't even take any arguments. So there is a primitive instruction, addition, subtraction,

56:20  
multiplication, and their meaning is kind of that that you already saw, isn't it.

56:26  
So basically,

56:30  
we are not yet giving the SEC machine interpreter. But the idea is, should be the D stand for

56:36  
operations that take two topmost stack elements, combine them together with addition, subtraction, and multiplication, and push the result back.

56:44  
Our num

56:46  
corresponds to these little things here. So this is an instruction whose idea is to just push a given integer on top of this deck.

56:57  
And then for the fun of it, I also include, we won't need them to interpret expressions yet. As long as we don't have any names, but soon, we will. So I will also include two more instructions.

57:13  
Three more instructions, one is called pop. This is an instruction that just throws away the top element of the stack, like calculates the head of a list, if you wish.

57:24  
It's already calculates the tail of the list. So the stack

57:27  
is will be as before, but the head is done, the top element is gone.

57:32  
doop takes the topmost element and duplicate it. So if, if so number seven is on top of the stack, this is kept but another seven is added to the top of the stack. The swap just interchanges the two top those elements of the stack, but leaves the rest of the stack alone. And that's also sometimes useful. It's a it's a pretty typical machine instruction for for stack machines.

58:00  
Does this make sense?

58:07  
Hello, are you there?

58:09  
Yeah, sure. Let's see one more. Let's see some more. Okay, then you can imagine what what a piece of stack code could look like. So let me give you some examples. So a piece of stack code.

58:21  
So for example, this one, if I wrote it up,

58:27  
would actually look like this. It would be a list when I first do our num. Are num, sorry, our num to

58:36  
look like this like this. Then our num

58:40  
three, then our num

58:44  
four. Then what do I need to do? Our sub is my thingy for subtraction isn't it

58:52  
and then are

58:55  
called Armand model

58:57  
is my instruction

59:00  
in this data pipe for multiplication, the whole thing. Now each each each of the individual gadgets here is just an our Easter value for the whole thing is a list of our installers. So the whole thing is also cold.

59:17  
I think when I just give it to F sharp it will not tell me code. It will tell me our installer list. But code is defined as a synonym for it.

59:29  
Yes, it said are interlaced. But let me just convince you that I can also say code.

59:37  
stupidly for some reason, the interpreter wants parentheses here. And then it says this code so these two are really the same type. And the interpreter doesn't know which which one of the two types in earnings I want to see. I like cold water but

59:53  
for for the interpreter this one somehow is more primitive. Or is this a cash that you did with a semicolon

1:00:00  
Pardon

1:00:02  
was that the typecast you did there to assign it to coat or? No, it is just that

1:00:09  
there is no casting happening, these are exactly equal times

1:00:14  
what I do with semi colon, sorry, with a colon here, I can put always, you know, F sharp has type inference. So it tries to figure out that everything I write is well piped and basically assign a pipe to every sub expression or whatever I write. Also the to the top level thing that I write,

1:00:34  
but I may put in my own claims, or what I think the type is.

1:00:40  
So, I want to say, I mean, this is code.

1:00:46  
And no cost happens here. So, the reason why F sharp agrees with me is that I've defined these two to read to be the same type, and therefore, it's happy.

1:00:59  
registers, okay, yeah, you can also see this code, but I can't put say in here or string and just pretend that actually I can, and you'll see that the thing will wind loudly.

1:01:14  
So

1:01:16  
it works sort of outside in. So it doesn't even say that it has figured out that this is a list of instructions, just looking at the parentheses, sorry, at the square brackets. It figures that, that by whatever I've written here, I have something that is a list of whatever.

1:01:36  
Whereas I'm insisting it's a string, and then it says it's a conflict, right? If it had looked deeper, it would have found that this is not even just a list of something. It's a list of instructions. But nonetheless, there is this fundamental conflict between like, you know, strings aren't lists.

1:01:53  
Is this fine? Yep.

1:02:00  
Okay, so now what do I have, I have two languages, I have expressions, and I have machine code.

1:02:09  
For expressions, I have an interpreter for machine code for the time being, I have nothing, right, just the just the syntax I've defined with the Abstract Syntax trees are here. So to get going a bit further, I better define, now also an interpreter.

1:02:29  
For

1:02:32  
for these machines,

1:02:34  
yes. And then to sort of complete my cycle, I better also define a translator or compiler from expressions to stack machine code, then then I've got two ways to evaluate expressions, either directly, or first translating compiling to machine code and then

1:02:51  
evaluating that.

1:02:54  
Okay, so let's first do an interpreter for machine code.

1:03:00  
It's a bit different than the interpreter for expressions in that expressions, I could evaluate just so given an expression, I could find out its value.

1:03:12  
And the evaluator for

1:03:18  
code

1:03:20  
for a sequence of instructions,

1:03:22  
needs a bit of state needs the current machine state. Yeah, because, see, here, I did my little stack machine computation. The way it worked was that I,

1:03:34  
I was in some state and I

1:03:38  
evaluated the single instruction, I produced the new state, then I took the next instruction from from the code, I got to a new state, etc. until I reached the end of my instruction sequence, at which point, there was some final stack state, which kind of is the interesting thing to see this. So I have to work with a bit of state

1:03:56  
stacks, say, a walk here, we see, they are just going to be lists of integers. We're really stacks of integers, but we represent stacks. As lists. They're not much else, right? So stack for me, will be a list of integers. So that again, is a type synonym. The moment I've introduced this definition, to have a list of integers or to have a stack is exactly the same thing. I don't need any costs between them.

1:04:25  
But the F sharp type inference may show me either this, or this is the a fourth type, depending on the mood in addition,

1:04:35  
there but the really cool types.

1:04:38  
And then we need to write the interpreter that works with this sort of stack states.

1:04:46  
So what does the interpreter do?

1:04:52  
It takes

1:04:54  
a bit of code which is just a sequence of instructions, therefore I call it Nzs.

1:05:00  
And it takes

1:05:02  
the stack state, which is just a list of integers.

1:05:08  
And it gives me back an integer, which is the value

1:05:14  
I'm interested in doing me.

1:05:23  
And then let's just try to write an interpreter directly.

1:05:29  
And okay, and I didn't get say one thing. So then the idea is that sort of on the top level, of course, we want to start with the empty stack. So the stack works is kind of a, and accumulating parameter for the interpreter.

1:05:45  
for the,

1:05:47  
for the, for the top level code of interest, we just start with the empty stack. And then we see how far we get

1:05:57  
that, that shouldn't be complicated at all should it.

1:06:03  
So how on earth, given a sequence of instructions, and given the stack, you need to go?

1:06:17  
Well,

1:06:19  
if the piece of code that is given to you is correct, in the sense that it actually results from compilation,

1:06:26  
then the idea should be that when you've reached the end of the code, so when you've processed everything, there is nothing left no instructions left to do, then the stack height should be exactly one, and you should have exactly one element on top of the stack. But of course, we may write unbalanced code, and then this is not the case. So let's write it like this. So if there is no code to execute, we take the value from the top of the stack

1:06:57  
if the stack is not empty, so this is pattern matching on the stack, remember, the stack is a list which can be either a cons list or an empty list.

1:07:06  
So if it has at least one element, we take the first element, the top element, if the list is empty, then let's just complain.

1:07:13  
That's basically kind of a stack on their flow situation, we want an element but that is not provided.

1:07:22  
So this is how you finish. If you were in the middle of your evaluation, you're typically in this situation, you've got a sequence of instructions, there is the first one of them. And then there is more instructions.

1:07:36  
Yeah, some first instruction and the rest of the instructions. And here, the pattern match goes on what the first instruction is, it can be all of these different things that we have in the data thing.

1:07:47  
Yeah, that's the first argument. The second is the stack state, which may will also be interesting to pattern match,

1:07:55  
depending on what the instruction is. So for example, if I want to just push an integer on the top of the stack, I don't care how empty or full the stack is, if I want to do addition, I better have at least two elements on top of the stack, and then maybe some more. So I it's good to do a pattern match like this to read.

1:08:14  
If I just want to do pop, I only need one element on top of the stack if I want to do that's also the case swap still wants to.

1:08:21  
And then again, when we say when we see that none of these is the case, then we say evaluation doesn't work because the for the particular instruction, there are too few options on the stack.

1:08:35  
Okay, then what needs to be done is actually very simple. So when you've got your first instruction, and the rest of the instructions to execute,

1:08:46  
this just reduces to executing the rest of the instructions. But with some updated stack with some new stack will imperatively it would be an outdated stack. But here we don't do any destructive updates, we just pass around the stack arguments. So we will form a new stack. In the case of pushing an integer, we just formed the stack, which look like this. The the integer we wanted to push plus all of the stack we had.

1:09:16  
If we wanted to add together two numbers, the first one

1:09:22  
was pushed earlier. So it's a bit deeper in the stack. The second one is the one that was pushed last, then we just add them together and push the result on the stack. So it makes sense. So this is the new stack with which with which we make a recursive call to the evaluator.

1:09:36  
Similar for subtraction and multiplication. Now add amaal are commutative. Anyway, here it really doesn't matter which order have I won and I do but for subtraction of course it's it's important to know from which number I'm subtracting which So here, I see eye to eye one. I'm one minus item in this order. And finally

1:10:00  
Pop and swap

1:10:02  
for pop, you just get rid of the head element in the list or the top element of the stack. For dupe, you duplicate it. So push, in some sense, you take it, then you push two copies back. And for swap,

1:10:19  
use useful.

1:10:24  
Okay, so now we can play maybe with this piece of code, for example.

1:10:31  
Let me first take a brave step. Now I just want to evaluate only all of it at once. But then we can also step through it if we want.

1:10:40  
If I just evaluate the whole thing.

1:10:46  
So that's my piece of code. And if I start from the empty stack, what do I get back?

1:10:52  
Now I should cross my fingers, and I should hope. Where was it,

1:10:57  
that minus two comes back, right? Something like this should happen. consecutive recursive calls are made. This is the first

1:11:05  
stack that is provided.

1:11:07  
The recursive call is made with this and the new recursive call is made with this blah, blah, blah, these all tail recursive calls to at the end, we come back to this.

1:11:18  
It comes back with minus two, now we didn't see anything.

1:11:22  
How do we do something? Well, one way to do this is to

1:11:27  
is just to give less code for the machine to execute, because then I can see intermediate results. So if I just two

1:11:38  
or number two, then two is on the top of the stack, at this stage, isn't it?

1:11:47  
If I do the two first things.

1:11:53  
And then I basically reached here with my stack, so three should now be on the top of the stack.

1:12:01  
And if I also do

1:12:04  
our number four, then 40 is on top of the stack. That's all not so interesting. Let's do this one.

1:12:12  
So when I've done subtraction

1:12:15  
here,

1:12:17  
but not yet the multiplication, I should finish in this state. So

1:12:23  
the evaluator should return the top element of the stack, which at that stage is minus two,

1:12:29  
which is the case.

1:12:32  
Yeah, so this was some form of stepping, of course, you might want to see

1:12:38  
all of the intermediate stack states. And that's also possible. So we could write kind of

1:12:46  
watch as they call it, like an interpreter in a debug mode. So to say, where, for every instruction that we evaluate, you can see the intermediate stack state,

1:12:57  
that would be possible and would perhaps be a good exercise.

1:13:01  
What would we need for this?

1:13:07  
Well, I won't implement this now. But the idea should be clear, right? So what was the problem currently was that I only saw ever

1:13:17  
the topmost element of the final stack, of course, I could put that the return type is stack and modify the code here a bit, then I could extract the final stack. But I could also put the list of stacks here. And then the idea could be that I could see all of the intermediate

1:13:37  
stack states as well.

1:13:40  
And then interpretation would be going would be would go basically by by growing

1:13:48  
this list, adding new or new stack states as we as we go, but never throwing away any of the already constructed intermediate ones.

1:14:00  
So this is just an example that we can have a different language and we can have an interpreter. Now let's tie the knot.

1:14:08  
I'd like to have a compiler.

1:14:12  
I'd like to compile and an expression into stack machine code.

1:14:18  
This is easy to say

1:14:22  
on the type level, right? Why?

1:14:27  
All I need to say is From where do I need to get to where well I need a function that I will call our computer compilation to register machine.

1:14:39  
The input should be an expression and the output should be code.

1:14:44  
Ah, maybe maybe, to to comment, right? I mean, previously, I wrote what did I write in here I wrote colon code. So this was to give a hint to F sharp that I want the type of this thing to be called.

1:14:59  
I may

1:15:00  
I may not write these kind of hints. So here often I didn't, most of the time, I didn't. Also here, there is not nothing that forces me to write any of this, I could really write something like this.

1:15:12  
And then hope that F sharp derives some type for me, namely, that it figures out that he has to be of type expert. And then what comes back in all of these different cases of the match is always code because in that case, I really have a function from expert to code. But I don't manually have to say this, there are all sorts of intermediate options, I could say that my input is an expression.

1:15:41  
But

1:15:42  
choose not to say what I want the output type to be that's possible, then I just write like this, that's fine.

1:15:50  
Now I'm just saying the parameters type expert, I don't say what the return is. Or I could play the exact opposite game, I say, I don't care about the parameter. But the result should surely be of type code.

1:16:04  
And that's likewise possible. Remember that and notice now the parentheses here play the role. Since I didn't put parentheses around these two guys, what really means is that our companies have type code itself is of some other type.

1:16:22  
Doesn't make sense. And then if I want to give both types,

1:16:28  
I write something like this. And this is exactly the same as to sort of just make a little note for myself,

1:16:35  
which the compiler is which the F sharp interpreter wouldn't read, that our comp is a function from expert to code.

1:16:46  
All these things are possible.

1:16:50  
It's just different, different ways. Now, what is a good discipline? It really depends on

1:17:00  
it depends on many things, it depends on your proficiency. But it also depends on the kind of style you want to follow. It's actually good to give intended types.

1:17:12  
For two reasons. First is kind of documentation. I mean, if someone else looks at your code, this is kind of the first indication of what is going on, if you put these things in.

1:17:24  
But it's also a way of detecting your own errors early, even if you don't want to show your code to anyone else. Because if you write down some indented type, just type annotation.

1:17:38  
And if F sharp figures out that these types are possibly not achievable, then you know that you've done something wrong. And you're told is very early on.

1:17:50  
Who is this part of the development process then and early? Early detection of issues?

1:17:59  
Okay, so to finish this thing off,

1:18:03  
I now have to explain how to compile this may be a bit mysterious, but when you when you already got a bit of the feel how it works, then maybe you guess

1:18:22  
what it should be like?

1:18:27  
And because here I sort of manually compiled,

1:18:30  
I gave this example of an expression

1:18:33  
in concrete syntax for readability. And I showed you this compile for more sort of in concrete syntax, not not written, as verbose as time as down here. So how did I get from here to here? So this was my procedure morally,

1:18:49  
it should be the following. So when I see that the expression on the top level is times applied to two arguments, then what do I need to do is I need to produce code for the two arguments for to which justice for three minus four is just this.

1:19:04  
And I just concatenate these two pieces of code. And then finally, the code for the operation itself, which is a single instruction i need to put at the very end. And this is the principle that you need to follow. And there is nothing else a miraculous it works. And all of the operations are applied in the right order, believe it for you to think why this would be the case.

1:19:27  
So our time is almost up, but I'm also almost done, which is very, very good.

1:19:32  
So

1:19:34  
I have these cases here.

1:19:38  
So

1:19:42  
an expression can be either a numeral or an operator or an operator followed by some or an operator with some argument expressions. And we've only implemented plus times and minus.

1:19:55  
In each case, I need to separately combine the two parts

1:20:03  
And I don't really need to interchange any information between these two compilation processes, which is nice. So there is kind of modularity here for compositionality.

1:20:13  
And then at the end, I need to put the our add command.

1:20:18  
And similarly for time similarly for miners. So if I took my nice piece of code, where was it?

1:20:26  
This one the most complicated one. And if I just asked F sharp to compile it following this function here, what do I get back? I get back exactly the one that I manually did for you.

1:20:42  
Above here, isn't it? This one?

1:20:46  
Literally just this.

1:20:53  
And I might do something else. So I might, for example,

1:20:58  
do one of the simpler ones that they had, what were they?

1:21:04  
Like, if I just only do three minus four?

1:21:14  
I don't get this right.

1:21:17  
Then if I mean, maybe only do four,

1:21:22  
I get very little code, which is a sequence of instructions consisting of exactly one instruction, which is just push forward into the stack, which normally at the beginning should be empty.

1:21:35  
Yeah.

1:21:38  
And now then, how could I? How could I interpret my piece of code

1:21:45  
in the other workflow,

1:21:48  
it just goes by composition of the compiler, and the interpreter of the lower level language. So given a piece of code, all I need to do is to compile

1:22:02  
and then interpret. So take this guy, and apply our evil to it.

1:22:13  
If I just do this, there is a problem why? Well, it doesn't quite run, because our evil wants two arguments, a piece of code and an initial stack. So if I just partially applied it only to the first argument, what I get back is not an integer, but it's a function that still awaits

1:22:33  
a stack, and then is happy to give me an integer. So I need to provide to bar going the wrong direction. And

1:22:40  
I just need to provide also the stack argument. And I can always start with the empty stack. If I do it, I get minus two.

1:22:50  
So you see there is now two ways of evaluating an expression, any expression he either evaluated directly. So this is interpretation.

1:23:01  
And the other one is the compilation workflow that goes in two stages, compile it, and then use the interpreter of the other language here, the stack machine language.

1:23:13  
And then work like this.

1:23:15  
correctness of compilation, if you take the you know, the high level interpreter, as your as your standard, as your definition, is to make sure that for any expression, these two things always come out

1:23:29  
as the same integer value. If not, I've done something wrong, then my compiler

1:23:35  
is a bit buggy.

1:23:39  
And that actually completes what I wanted to say.

1:23:45  
Next time, we will go on to names. So this will be far more interesting. And then to local scope, which is where the real complications are. So today, I only sort of set up the stage and try to explain some important differences abstract versus concrete syntax. In this course, we mostly work with abstract syntax, and then the difference between interpretation, which is direct evaluation, and compilation, which is translation to another language, which you then may want three basic

1:24:16  
questions.

1:24:24  
There's already exercise

1:24:28  
out there, but we will also get a larger exci assignment this week. That's correct. Yes, you will get a larger assignment. Latest on Thursday that then you will have I think, two and a half or three weeks to solve.

1:24:44  
So this is the first assignment set which is about F sharp programming so it doesn't get touched this expressions part.

1:24:50  
And this Wednesday's exercises are still to prepare for this first assignment. But then from next Wednesday on week

1:25:00  
get to this expression,

1:25:03  
parsing topic also with the exercises, and then the second assignment, which will follow shortly, will be on exactly this topic of like simple expression languages

1:25:13  
and concepts around this little extensions that you have to do by hand to what I'm showing to you, etc.

1:25:21  
But yes, that's indeed what it is. So once this exercise is already there, you can start to have a look if you have time. But they are not yet about this part. So they're basically about the first part of the course.

1:25:35  
But they are of the type that will go into the first assignment. Actually, a large part of the first assignment is a variation of something that is in, in this Wednesday's exercise.

1:25:53  
Okay.

1:25:56  
Anything else anything about this thing today?

1:26:00  
I hope it was simple, it has to be simple, because it does get complicated. So

1:26:05  
this is to set up a framework. And what will happen in the next lectures is all these data types will grow with various things, right, the expressions we get added, like, you know, variables, then let construct, etc. And the stack machine will get more complicated. And we'll look at possible language features that you may have in different languages, sort of one by one, and we'll start piling up things. But the idea is always like, we're basically doing a programming language on our own. We're just exploring with

1:26:34  
exploring features.

1:26:41  
Okay, if there is nothing else, I'll stop the recording. Here. The thing will be natco, maybe two hours or so. And I might also update the code that I showed today with a little thing modifications.

1:26:57  
Okay, all the best for

1:27:00  
now then.

1:27:03  
Thanks. Bye.

1:27:07  
Thank you.

Transcribed by https://otter.ai
1:52  
Hello, can you hear me? Yes, very good.

1:59  
I think we're about ready to start.

2:36  
Okay, so Hello.

2:39  
This is the second part

2:41  
about expressions. And we'll do something more interesting than than last time. And I'll introduce you to some more sort of general concepts that you see in every type of language. And we have to think about these together.

2:56  
So just to recap very quickly, what we did last time, we looked at two languages, really one was expressions.

3:08  
And then there was also the stack machine language.

3:14  
Yes, and I emphasise that there is difference between concrete syntax,

3:20  
which is writing down expressions as strings

3:24  
versus abstract syntax,

3:28  
which are abstract syntax trees, that the abstract syntax is the one with which we want to work.

3:35  
And then we said, well, the point with expressions is not so much to be able to write them down or to read them out, but that they stand for something for which there is a meaningful way of executing them. Namely, we simplify expressions, because we're after the value of the expression. And then we said there is two ways or two workflows for doing this

3:58  
interpretation

4:02  
versus

4:04  
compilation

4:08  
where interpretation meant

4:12  
evaluate expressions directly. And this is generally the idea that

4:18  
you have some sort of

4:22  
little abstract machine or computation platform on which you are able to evaluate your programmes or run your programmes directly, where compilation goes into stages.

4:38  
So here, we going to stack machine code.

4:44  
And then we evaluate that

4:48  
by interpretation, but interpreting different things. So now we interpret stack machine code.

4:55  
And it's important to realise that of course in real life, there can be a

5:00  
stack of languages. So, so very typically is that you have at least one or two intermediate ones.

5:07  
So, if you for example take Say,

5:11  
say Java,

5:13  
then the idea is there is this intermediate language called Java, Java byte codes or Java virtual machine code. So you can

5:26  
you can interpret Java programmes or you can just in time compile them into into Java bytecode.

5:33  
But Java bytecode itself runs on a set of a virtual machine, but that's not the actual machine you own. But rather below is his actual machine code. So, we've got like three different levels of languages there like there is there is Java, there is Java bytecode. And then there is the actual processor code. And

5:58  
yes, when you want to process your your Java programme, you either have to be interpreted to be able to interpret it directly in some sense, or you go via the JVM, the Java virtual machine code.

6:11  
What do you say? Well, really, the way I explained my Java programme is I look at, you know, the actual machine code, I could, in the end of the day, compile it down to

6:22  
why you do have these intermediate languages, there are several reasons. One is that sometimes high level languages are very complex, there are very many constructions for the convenience of the programmer. But most of them can be rendered in terms of some other constructs, they don't really need so many. So so the intermediate language typically is a smaller one sort of easier to easier to handle. So surface level things you handle by compiling from, from the source language to the mean, intermediate language, that's one. But another reason very often is interoperability. Like you may want to run your Java code on very different processors. And all of these processors have different instruction sets. So in the end, the machine code is different.

7:08  
But, but Java bytecode is platform independent. So this is this kind of an

7:15  
ideal idea of what machine code could be, that has little to do, or that has something to do but but not so much to do with with actual machine code. So for interoperability, it's nice to have these intermediate languages because then you can compile many different languages to the same intermediate language like Java perhaps, could go to JVM, but Scala code could also be

7:39  
translated to to JVM, Java virtual machine code. That's the idea.

7:44  
Okay, today, what is going to happen is, we will say these expressions are a bit too primitive.

7:51  
So we want to enrich the language a bit and see what kind of issues arise there. And there are quite a few immediately. And we'll only do two things, time permitting. The first one is,

8:04  
let's suppose we also allow variable names in expressions. So

8:14  
first, we add names. so we can write something like three plus seven times x,

8:20  
maybe divided by wine or something.

8:24  
And then the second move we do is we introduce a little bit of block structure into expressions with the idea that some of the names

8:33  
could be not top level, but local, so visible only in a part of the expression.

8:40  
And then we also get to the idea that you can start reusing names. So if some local scope, you don't need that some outer scope name is visible, you can actually reuse the altar name for a different purpose in the locals scope. Yeah. So why would you do within a single expression, perhaps,

9:01  
there is not so much reasons. But they but the but the overall principle is everywhere, right?

9:07  
You want to write your own programmes using your own names. And you don't need to you do want that you shouldn't worry about the names that perhaps are used in the code of the library functions, because you haven't even seen their code. So there should be the natural idea in every reasonable programming language that you can make names to have a bit of a local scope. One is reuse of names, but other are simply like practical hygiene. So if many people work on something that in the end will will form one piece of code that runs together, then surely different developers name shouldn't class clash with each other just so that you should be able to control what do you expect to expose to your your pals.

9:55  
So that's, that's the programme for today. And we do it in the same way as as a Tuesday.

10:00  
So so just playing on the simple example and showing what what sort of adding features means to a programming language, what it means for interpretation of what it means for compilation.

10:13  
Does this make sense was a planned?

10:18  
Someone's there?

10:22  
Hello, hello, hello.

10:24  
You're they're very good. So just shout when when you have different ideas or questions or just even viewpoints because it would be nice to actually talk a bit.

10:37  
Okay, we're not going to do too much to begin with, I want to represent our talk about these expressions that in concrete syntax, we perhaps write down in these kinds of forms write expressions like last time.

10:50  
So we do basically arithmetic, I can write down numerals, there are some operations that we have for operating numerals that stands for that stands for integers. But then I want to be able to also have variable names. Now, of course, one of the things we need you to see is, as soon as you introduce variables, an expression doesn't have a value on its own, right? I mean, how can you possibly say how much three plus A is, if you don't know anything about a or if you haven't made any assumption about the

11:21  
and that will bring us very soon to the idea of

11:25  
the environment.

11:28  
And

11:29  
when we use the same word environment like that you do in nature protection or so. But the idea is exactly the same. So I mean, there are expressions, but then there is something surrounding them, or something that is outside the expressions, that sort of makes a nice place for expressions to live. And that we call environments. This is the official terminology.

11:50  
Before that, let's just fix then what our expressions are. I do it with this recursive data type in F sharp so that we can actually play with these things.

12:00  
And it's pretty much the same as before last time, at one point Tuesday, so I'm able to write at least two kinds of expressions, numerals, which are just the attack norm, or the data constructor norm followed by an integer, or a data constructor attack up, followed by an operation name, and two is two expressions.

12:22  
So these were the two constructions that we saw before, we just add one more, we see an expression can already can also be a variable or a name.

12:32  
And this is indicated by the tag var for variable.

12:38  
And every variable has a name. So we also provide a string.

12:42  
And we are very generous. So I don't want to limit the kind of strings that you can use this very variable names at all at the moment, because that's not that's not our sort of concern here. Of course, you can have lexical conventions in the language saying, you know, variable names should be strings like this, like starting with capital letters, or cannot start with capital letters, or may not contain special symbols or anything, right now, this is not a concern.

13:07  
So once I've done this, I can already start to play a bit, but not so much yet.

13:27  
So I can write down my own little expression. So for example, this one is going to be an expression. These are difficult three expressions, we could do with a pretty printer, it's not hard to to extend the pretty printer that we had to also cover variables. But let's not bother about it right now. So we just worked with these abstract syntax trees. So we can see that these three things in particular, they're really legitimate expressions in the sense that

13:53  
when I when I when I entered them at the prompt of the interpreter, F sharp agrees that these are legit expressions.

14:07  
Now,

14:10  
this much about syntax, let's not worry about pretty printing or parsing right now, we just work with these abstract syntax trees.

14:18  
Suppose I wanted to compute with these expressions, I really wanted to evaluate them, which is the main reason expressions exist in the first place. How could I go about it? So, if I ask you,

14:31  
what is v times nine plus a?

14:35  
Then you should reasonably tell me we do not know unless we make some agreement about the value of a and the value of b.

14:46  
Yeah, so an expression doesn't have a value by itself What do I need to provide as extra fun expression to obtain a value is called an environment here in this particular situation and environment is a simple thing.

15:00  
It's an assignment of values to names.

15:07  
In this language, I'm not really, there are no declarations. So I can use any names. I'm not saying like in this expression, only a and b are available.

15:16  
This is nothing like I would declare an A and B to be integers. So in principle, any, any name could occur in any expression. But in order to evaluate an expression, what we need is that

15:29  
we know values for at least these variables that are around. So for example, to evaluate this one, I don't need to know what b is. To evaluate this one, I don't need to know what c could be if C were another name. But surely I need to know that NPR.

15:44  
So an environment is an assignment of values to variables, at least those ones that are important for us that in some sense, are in the global scope, although we haven't introduced this concept yet.

15:55  
So

15:57  
what is it really,

15:59  
so a way to represent this, that is also very reasonable, it's kind of a dictionary data structure. So in the simplest way I could, I could write it down as a tree, perhaps you would want to do it as a search. Or as at least, you could also do it as a kind of a search tree.

16:17  
But for the moment, at least, we'll do. So we could say that the environment to have an environment is the same thing. So this is a type synonym declaration as to have a list of pairs of strings and integers. And the idea is that I just tell

16:33  
which names I'm associating to which values, people also often say you bind values to names.

16:41  
Not that they like this word very much.

16:48  
Because you use the word binding also in another meaning here in this context, but people often say this.

16:57  
So this could be, for example, one particular environment. So indeed, like, if I type check this thing.

17:06  
The next stop agrees This is a list of strings and integers. It didn't tell me it was an invalid invader. But then there is a synonym for this thing. So this is fine.

17:19  
So in computer science, we use very many different names for this kind of data structure. So strings of sorry, lists of pairs like this, I use dictionary here, some other people would call this thing Association list, which is exactly the same thing.

17:34  
And you could also say that, like key value pairs, which is kind of reasonable to hear, we use variable names as keys. And these integers as values is a little database where you can look at things.

17:47  
That's what it is.

17:51  
In order for the environment to be helpful for you at all, you have to be able to look up

17:59  
values for keys. Yeah, here values for names.

18:04  
So at the very least, I would need to write

18:10  
I mean, to write an interpreter for expressions, I surely need

18:14  
to be able to look up values for names in an environment. Do we agree this right? I mean, if I need to calculate this thing, it would be so nice to know that A is actually three in this environment, and B is 111. Because then I can work it out that the value is worried 11 Plus, sorry, is 999 plus three, which is probably 1002.

18:40  
So let's write a quick look up function. And then we can go on to more interesting things.

18:47  
I'll do this.

18:49  
So what comes in, where is the variable whose value I'm interested in? There is the environment that is given to me, and I just want to get an integer, this thing may fail. If the dictionary is too thin, it doesn't contain the word right, it doesn't contain the variable name, then well, then you simply have to lift up your hands and say, Sorry, I couldn't do it. So this happens,

19:14  
like this here. So we do look up by pattern matching on the environment. If the dictionary is empty, you can find anything there, including you can find x.

19:25  
But otherwise, we reduce the bigger problem to a smaller one. So if the dictionary is some first variable name and value pair, then it's nice to check maybe the first entry already matches.

19:40  
If yes, then I extract the value otherwise, I get go deeper into the dictionary and look it up. Right. This is a particularly silly dictionary, which is not ordered lexicographically like ordinary dictionaries are so it just, you know basically you have to browse through it and hope you find your your your your variable name

20:00  
So

20:02  
let's do a few examples. So this is an example of an environment Actually, it's already loaded. But I can do it again anyway.

20:10  
So here's a dictionary called n. And now I may be interested in looking at that various

20:19  
names in here, actually, this order is wrong.

20:27  
So I could go

20:29  
look up a in here, in this environment.

20:33  
And the thing nicely, it tells me it's three, I can look up the value of buff should be 666.

20:43  
And it is,

20:45  
I have the, I may have the bad idea to look up D.

20:50  
And I just get a lot of swear words, but the main point is somewhere here.

21:01  
This, this is actually the error messages, I wanted to provide D not found, right.

21:07  
And the rest is more information, which I really shouldn't.

21:13  
Now at this place, you should ask a question,

21:18  
which is the following suppose my environment was a little different?

21:23  
Maybe I had another eight here,

21:29  
which was five perhaps?

21:34  
What do you think will happen if I now look up a

21:42  
ticket both for just first one?

21:45  
Yeah, unfortunately, I only get the first one. Why?

21:52  
Well, I could do something so that I could retrieve them all. But then I would have to write a slightly different type of a function, right, that would basically take in a name and an environment, and would return perhaps a list of integers, which would be the list of all possible values,

22:08  
that would be quite a nice thing to do in the sense that then actually, I wouldn't need to raise an error here. Because then if there is no value, say, for D, I would just return the empty list to see this.

22:19  
Which is nicer to work with, you don't get this danger of runtime errors. But somehow, morally, this is the wrong thing to do.

22:27  
Because it turns out, it's quite useful to work with such a structure, where it's possible for a dictionary to have the same name twice.

22:37  
Namely, you can later use it to model the idea of scope.

22:43  
And things will end up in your dictionary, if you do it right, in such a way that the names that are more local, or say, you know, are in more inner scopes,

22:55  
will appear in these environments like these. So they're more toward the front. Whereas

23:03  
names from outer scopes, which may coincide, right, they can be the same names would appear deeper in the list. And then when you get a free lunch, which is an extraordinary thing, right? In the sense that you then don't need to do anything, you don't need to put any extra care into getting this sort of shadowing thing. When you reuse the name you, you you, you start to local scope where you have a different definition of a name.

23:36  
You don't need any unique don't need to do anything to to make sure that the shadowing works properly, because things just work in your favour without any effort.

23:47  
from your side, isn't this nice? No, you won't see this right now. But but it will come later today. What you could think this was the locally and this was maybe the A from the you know, from the next outer scope or maybe from the top level or so.

24:05  
But for the moment, we don't have in the language, any scoping mechanism. So we think this is just a flat list. So if I happen to have some the same name place, then bad luck, the second occurrence is just useless and the third as well.

24:21  
But what we've done for now is actually great, because now I have a very simple interpreter for my language, just by modifying the one from the last time by adding one single new line

24:36  
and the rest is literally the same.

24:55  
So let's remember how did we do running

25:01  
expressions before,

25:04  
or evaluating them. Before I had a little function eval, which was defined recursively, because I needed to pass two cases, to do case distinction on the expression, but also

25:15  
recursive calls in the more interesting cases, and expression comes in, and an integer should come out.

25:24  
And I already said this won't work. Now, if we have names because solely an expression doesn't contain enough information, because you have not, you know, nothing what to do at variables. But if we provide an environment as an extra argument, so this thing will now be a curried function with two arguments coming in one by one,

25:46  
when an integer comes up,

25:51  
let's see what to do.

25:56  
Let's actually look at the old cases a bit, because they're not exactly the same as before there is a minimal modification. See, because I make these recursive calls to eval, formally eval to one argument. But now of course, it has to take the extra argument as well. So suppose I want to add together two expressions.

26:17  
And then I want to know the value. So find eval of this thing up? That's my big problem. What could be my two smaller problems that helped me to solve this one?

26:28  
If, if recursion manages the smaller problems?

26:32  
Well, it's, of course, obviously, to evaluate v one and v two.

26:36  
But these guys need to know some environment, they need to know the values of their variables.

26:42  
Which environment should they use?

26:46  
Well, there is only one to play with, which is the one that comes here.

26:51  
So if I want to evaluate the whole thing in the environment, and then surely,

26:57  
I mean, that the variables in the sub expressions should also be interpreted in exactly the same environment, right? So this n is passed down, was handed down to all these recursive calls.

27:09  
do agree? And they don't have to change it in any way. I mean, it would be very stupid to say that, on this level, I know that A is nine. But I don't want to let you want to know about this. So just remove it from the dictionary that doesn't feel right thing to do.

27:25  
Then if you have to evaluate the normal expression, like nom, 17, it's just 17.

27:31  
And then there is only one

27:33  
really new line, which is this. So if you if you are at the leaf or abstract syntax tree, you see a variable.

27:40  
What is its value?

27:43  
Well, it doesn't have any absolute value. But there is something that we've decided in the environment, we just look up text in the environment.

27:53  
Let's see if it works at all. So if I want to do eval, what can I have? eval num 17

28:02  
then this can be done in under any environment. I mean, I don't really need to know the value of any variable for that week.

28:09  
So this is 17. By the way, it's 17. Also, if A is 13.

28:17  
It's also 17. If, if b is also nine.

28:26  
Hmm, but what are some more interesting expressions, maybe something like var a.

28:34  
This one is 13. Because we can look it up in the dictionary, we can also look deeper in the dictionary. So for example, B is not the first entry in the dictionary.

28:44  
The thing will find it if I want to evaluate C in this environment,

28:50  
then just just swear words.

28:54  
And the expression can be complicated, right? So it can be very interesting to use this machine as a little calculator.

29:03  
So I do

29:05  
plus

29:07  
apply to these two things. Variable a variable effects.

29:13  
92 parentheses 22.

29:18  
Does it make sense?

29:22  
Anyone? There's still questions.

29:28  
Hello, hello. Hello. Hello. Yes, so we haven't done a lot. I just introduced one new notion to you and vironment. This is very common, right?

29:38  
And if I'm in a language, which is functional, so variables, don't ever change their values during the course of the programme. And if there are no local names, then there is one very little thing here that you work with, which is basically like one fixed dictionary, which you pass into the recursion

30:00  
Every one can see, you know, the lower the lower levels of the ASD so to say nothing else can happen. But of course, this will change a lot when we get to more complicated things.

30:13  
Now let's do something a bit more realistic. So what?

30:17  
What sometimes happens, what very often happens is, you of course, think of your environment as something stored in memory, isn't it? Like, you know, you've got your memory, yes. And then there is a little symbol table, which will tell you that maybe a is located at cell,

30:35  
whatever

30:37  
1011 and maybe B is located at cell 1012.

30:42  
And when you actually evaluate the programme, then you don't work with these names anymore, you actually work with these these cells or locations.

30:52  
Yeah.

30:54  
So

30:59  
we could do that.

31:01  
So let's, let's play a little game.

31:09  
We will work with two kinds of expressions for the moment, for the time being, they're going to be source expressions, which are the ones that we just saw. And there are target expressions

31:18  
that are like expressions in a little intermediate language, which is almost the same as those be the one we had before expert. But now we have the expert. The only difference is that, when you see the type T bar, you're not told the variable name, you're directly told where this variable is in the memory. So it's going to be. So here, we model it simply by a number, of course, realistically to be a word, like maybe two to the power of 16, or something, or 30 to

31:45  
some number from zero to that minus one. But here, we just model it with integers for simplicity. And that is that is all the reason. So variables are numbers, rather than the name, and you can think of them as kind of addresses in memory, which is a useful way to think.

32:06  
So now I'd like to play this little game that we look at two workflows for source expressions, I either interpret them directly, which we already done, but then I could play the game that I translate target expressions,

32:22  
sorry, translate source expressions into target expressions.

32:26  
This works if I somehow decide which variable goes where in the memory. And then I can get rid of variable names in my expressions, I just replaced the variable names by the corresponding addresses.

32:38  
And then I could interpret this this target expressions directly.

32:43  
So again, that is like interpretation versus a little compilation followed by interpretation of a slightly different language. Yep.

32:50  
You see this target expressions, source expressions. And then sorry, source expressions, target expression, either interpret source expressions directly or compile them into target expressions and interpret those.

33:05  
So let's do this. This actually all fits on the screen, there is nothing more.

33:11  
Maybe there is a couple more lines below. So target expressions are the same as expressions except that every variable comes together with

33:23  
with a with a with an integer. And just to just to be able to tell F sharp whether I mean a source or a target expression. I renamed the constructors here. Now they're not called var lumintop. But they're called to our teen on the up just for default target.

33:40  
Yep.

33:43  
So I can write

33:45  
what what can I write? I can write like Keenum.

33:50  
17. This is now the target. What happened?

34:02  
Yes, thank you.

34:07  
Tina, I'm 17 is the target expression, but also for example, fever one

34:14  
plus t num 17

34:18  
will be which I can write down like this

34:27  
is correct.

34:32  
This also has to be cut.

34:34  
So that is a target expression to see this.

34:38  
And

34:40  
then what do I need for interpreting target expressions?

34:45  
I also need the notion of an environment but now we can be slightly different. I don't need a dictionary, it suffice is just with a list of integers.

34:56  
And my idea is that

35:00  
You know,

35:02  
the value at address zero is at the head of the list the value at address. One is the next one in the list, the value at address two is the next one in the list. And you can basically extract variable values simply by indexing into the list.

35:18  
Yeah, if you do this, then this is exactly what we need. So I will say runtime environments are in there to just to distinguish them from these invaders that we had before. They are just lists of integers.

35:34  
And then I can evaluate the target expression with respect to a runtime environment and I get the value. The programme is exactly the same as the evaluator before except that I need to do a different thing in the T var case.

35:46  
So I don't do look up by name.

35:49  
But I do sort of look up in memory, which is organised by addresses. So of course, you know, in a real implementation, you would want to have an array here with direct access rather than list. But just for a sort of simple exercise with the model. Lists are just fine.

36:07  
So this is what we do we just use NF item in the list to extract the value of a variable, and then we're good. So now can evaluate things. So for example, the last

36:19  
the last one, which is called it at the moment,

36:25  
I could try to evaluate it in the environment where I have these numbers 17 1730 1342 and 1011.

36:37  
Now, it is a target expression, you can see it is the last guy here this one sorry.

36:43  
And this is a runtime environment names are gun. But the idea is this is the value at address zero, this is the value at address one, this is the value at address two, does it make sense?

36:55  
Then what do we expect back? So can you beat?

37:04  
Anyone?

37:06  
No, not really, if the target, like the list you're making here, the 13 and 42 and 1011. I talked about the state tax of some list or

37:18  
Yeah, these, this argument here

37:22  
corresponds to this runtime environment that I provide as the second argument to

37:29  
all evil is of course wrong. So I should say t ever let's just push the wrong type there on P. But so so this is the environment and they you should see this environment that's kind of just the dump of the memory.

37:44  
Wouldn't you get?

37:46  
Pardon? Wouldn't you get an error? Because index 17 isn't in the environment? Well, no, no, but 17 I don't have as an index 17 is a constant in my expression.

37:57  
Okay, all right. Maybe I should write it somewhere on the site here. My expression at this moment, morally, is, yeah, something like,

38:07  
I don't know how to write it, maybe like,

38:10  
write it with a kind of pointer. dereference notation, if you wish.

38:15  
Bang one plus 17 in the sense that 17 is just the numeral I get. But t bar here, I want to get the thing from the address one in the memory, right? And 42 is there. Yep. Is this fine?

38:30  
Yes. So the results would be

38:33  
59. Right? We expect but if instead say I wanted

38:39  
what did you know?

38:49  
For example, we looked at the second variable, and maybe we we just studied five twit, or something like this, we should get something different, right? So if I now do the same thing,

39:02  
I'd expect that I do get 1011 plus five, which should be 1016.

39:08  
Okay.

39:11  
This might seem really silly, but it is to illustrate the idea that when you work with names generally in a series implementation, you do Institute some sort of

39:26  
mapping of variable names to memory

39:29  
addresses. And then you have to keep track which variable went where. Yeah, like perhaps should know that this 13 is actually meant to be my a and my B went to sorry,

39:41  
is position zero which happens to have value 13 is is a and maybe B was located position one pepinster value 42 etc.

39:53  
Okay, and that is actually going to be happening next. So suppose my

40:00  
Again, we're now to combine expressions to target expressions.

40:06  
So the idea now should be that I give you something like x plus 17. And maybe I expect that this compiles to say,

40:16  
you know, local variables zero

40:19  
plus 17, something like this. So this is I bang just for this little dereference here.

40:31  
How could I possibly do this?

40:34  
Well, I cannot sort of on my own,

40:37  
because somebody has to tell me that I'd quite like that you put x at address zero. And I'd quite like that you put w at address 45 or so.

40:48  
So again, you need

40:50  
a sort of an environment. Basically, you want to say which variables go where,

40:58  
in terms of addresses how to model this.

41:02  
So one simple trick we could do with is we just work with something that we call cn, we're here C for compile time environment. So it's just something that only exists in compiled time. When you've combined, you can throw it away.

41:17  
And this could be just a string of lists, sorry, a list of strings. And then the idea is,

41:24  
by taking your environment to be a string, like, sorry, a list of strings like a be

41:33  
the boss,

41:36  
I expressed my intent that he should go to address zero and B should go to address one and pH should go to address two while I compile.

41:50  
Right?

41:53  
Yep, makes sense. Makes sense.

41:56  
So how would you then do the compilation? Let's see, let's look at that one first. So an expression comes in what should come out a target expression.

42:05  
And now to link the two up, I need to decide which variable wants to go to which address, which is the CN thing here.

42:14  
That's a little recursive programme. Obviously, every numeral I have in my expression just becomes a numeral in the target expression. So gnomes become genomes.

42:24  
Because we use different data constructors, but it's really the same thing in terms of concrete syntax, write an op similarly, go to T ops. And of course, if you have to compile an op,

42:35  
which has two sub expressions, you run into e to the task reduces to be able to compile the smaller expressions, right? As always, in recursion, this is going to be my slogan, until the end of March. Yeah, reduce bigger problems to smaller ones, until they go away. And so if you can trust recursion to make them, make the small one go away without you having to care about it, especially specifically, when you've set up things, right.

43:04  
So that's almost good. But then, of course, there is one little clause to write. So var x where x is a string has to become t var, something where that something is, is of type int. Yeah. So names have to turn into addresses.

43:21  
I agree.

43:24  
So how do I do this? Well, basically, if somebody gives me a compile time, environment like this, so then when I am asked to compile B, then I have to say, Okay, yeah, B has to go to address one. Why? Because B occurs in this list, at position.

43:45  
One. So what I need to write is a little function that given a string, and the list of strings, finds out if the string occurs in the list of strings and tells me at which position this happens.

44:00  
So you do it by recursing on the list.

44:06  
If there is nothing in the list, you're at the end of the list, then you say, okay, sorry, cannot allocate it to any address, because, you know, you haven't planned anything for that particular string. Otherwise, if the compiled time environment is a string, followed by more strings, so why is this string cn is a list of strings? When you check if the given string agrees with the one that you currently see? If yes, then you say, well, it's zero, because with the head position, otherwise, you'll have to, you'll go deeper into the list. And you'll find if your string occurs there, if you find it there, at a certain position, so now then in this list, it has position one deeper, yeah, if something occurs here, position five, it will surely occurred here in a position six. Yeah. Because instead of looking at the list, cn, and I'm looking at that at a longer list, why consider

45:01  
That's the programme. Maybe I should show it to you in action. So if I do like get index

45:09  
of what? D in this thing here.

45:21  
There's no t in the

45:23  
wrong order of arguments, right? Yes.

45:29  
Then these not found, but when I look at for something reasonable, then I'm told what it is. So this is, this tells the compiler where to put bar when you see in your code.

45:44  
Okay, and now we can do some little examples. There is this example e three that is already loaded. I've got no idea what it is, but we can look at it what it is. So it is actually this one.

45:55  
So it is b times nine plus a.

46:01  
And now we can for example, say

46:06  
compile it.

46:08  
Yeah, into a target expression.

46:14  
What happens we should get an expression that looks pretty much the same as this except every op has become a de op, every norm has become a genome simply because these are sort of tags for a different expression language. but crucially, B and they should be can. And he had a he has become zero, B has become one. Why? Because I decided, so to see this.

46:37  
Of course, I could have decided something else. I could have said this is not at all how things are things are maybe like this,

46:46  
oh,

46:48  
sorry.

46:51  
Press the wrong key.

46:57  
Maybe, maybe I want to say things are like this, which actually makes it even more interesting.

47:06  
Now, what do we expect.

47:08  
So this is the expression I want to compile again. But now in a different environment.

47:16  
I'd expect that this var B becomes actually

47:20  
D var one again, because b is still at position one. But a is at position three, isn't it

47:28  
0123.

47:34  
And, of course, when I just don't give the compiler idea, an idea what I want to put this in variable, like I say nothing about a then compile the compilation phase with a lot of complaints.

47:51  
So previously, we talked about correctness or combination, let's play this thing here as well.

47:58  
So when you have two different workflows, it's very important

48:03  
to be able to say

48:06  
what you mean for them to be the same. And then to make sure that they really do the same thing.

48:19  
I would say we want the following thing.

48:22  
So, if I evaluate a source expression directly in some given environment,

48:29  
that should really be the same as

48:35  
compiling e with respect to some compile time environment, which is just the list of streams

48:43  
then I get the target expression right and then target evaluating it in some runtime environment. Now, of course, these things will not always be equal, but n C and n Rn

48:57  
have to agree suitably to agree.

49:06  
And in what way suitably Well, let's figure it out.

49:12  
The idea of course, is that you know, for for corresponding names here in the environment.

49:19  
You'll find the same values here at the corresponding addresses.

49:25  
So the idea should be that

49:31  
at whichever address, sorry, whichever address you work with, the following should be the same thing.

49:39  
The value at that address according to the runtime environment,

49:45  
but also what you would get, if you look up the name of that address, in the compiled time environment.

49:57  
And then you look up the the name you found up

50:00  
In the original

50:03  
dictionary, which was with associative values to

50:08  
two names, right. So you can always make these kinds of statements is important to make sure that they are actually upheld.

50:20  
Let's, let's build now one more level of a language. So we had a source expressions, target expressions, let's have a yet lower level language, which now can be a state machine again, because we already had the nice tech machines, we should simply be able to adjust it somehow.

50:37  
That so that

50:44  
so that it also works with with these names and expressions, global names and expressions without any specific scope story.

50:55  
So what do I need to do,

50:58  
I again need to revisit the bit of code. So it looks like a bit of code. But it's a whole lot of code. I mean, but, but really, the changes are super minimal compared to what we had.

51:09  
This is the old art answer language. But I've added one new

51:14  
command,

51:27  
which is

51:30  
called our load, it takes one argument, an integer, and this integer, you should read this as an address. And the idea is, you take a value from an address morally than

51:42  
in some sort of a heap.

51:45  
And you place it on top of the stack to move thing, don't move action to copy a thing from the heap to the top of the stack. So the load here is, is from a runtime environment, I should stress it. So this is like memory represented in a list. Yep. And then all these things

52:07  
that we already had before.

52:09  
So that's a single instruction. And, and a piece of code is just a sequence of instructions with a list of instructions.

52:18  
And like before, when you interpret or run stack machine code, it also doesn't work alone. So previously, what we experienced it. So we run when you run stack machine code, you need to know what the current stack is. So at least you need

52:34  
a stack argument to your evaluator.

52:38  
Of course, you need the piece of code that you want to evaluate. But now in addition to the stack, you also need to know what this runtime environment or heap is. So both of these things come in. I have not said here, but what comes out is an integer.

52:54  
So the code is correct, it's just that I put in the annotation. And for clarity, we could put it in it also works without.

53:05  
So now we should be able to run run stack machine code

53:11  
that was done like before. So you basically work with with a given piece of code. With a given stack, there is also the given environment that you can use.

53:22  
With pattern match on the instruction sequence and the stack, we don't pattern match on the environment. But it doesn't mean that we don't use the environment with

53:31  
the code is like before in all cases. So like when you have some instruction to do and some more instructions, then what you do is you do the first instruction, you work out the new stack with which you want to do the recursive call with the rest of the instructions.

53:48  
And the for all of these instructions, you'll never change the runtime environment actually here. Similar to the evaluation expression evaluation, I've never changed the memory only read from the memory read from

54:00  
the runtime environment.

54:03  
And also, these two pattern matches are exactly the same as before. So if you're at the end of your piece of code,

54:10  
then you're actually at the stage where you don't need to recurse anymore, you're in a base case and then in this case, you should just try to return the top of the stack. So, if the stack is at least one element, you can do it if the stack is empty,

54:25  
then you can do nothing but complain

54:31  
here is the extra

54:34  
in the situation. So, our code is first load and then do some more stuff.

54:41  
And load from address and

54:44  
and the current stack is or the stack with which we work is SDK.

54:49  
This reduces to of course executing all the remaining instructions from the same environment. But now we provide to this recursive call.

55:00  
The different stack, which is obtained by taking the old one, but adding

55:06  
the result of looking up the element at address in, in, in the heat in the memory in the runtime environment, as we call it.

55:17  
Do you see the only changes, we go on with recursion, we go on with the evaluation, the runtime environment hasn't changed, we still go on with orange. But we have a new stack, which is the old stack plus something new on top, which was directly obtained from the runtime.

55:34  
And one

55:37  
maybe I should give a small example of this actually directly, not with any long piece of code. But suppose what we need to do is the following.

55:48  
What do we need to do?

55:52  
I do our eval. And my piece of code is just one single or load instruction.

56:00  
Our loads, say three.

56:05  
Yeah, so this is my whole programme very short.

56:10  
The stack is maybe empty at the beginning.

56:15  
And maybe I work with a memory which has these values, like 2357 1113, which happened to be the prime numbers, but plays no role. So at address zero, I've got two at address one, I've got three others, too. I've got five, others three, I've got seven, etc. But there's four, I've got 11. Now I want to evaluate this.

56:40  
What happens is,

56:42  
first, we do the lookup of at address three, where do we find the value seven, because agitation starts from zero, not one.

56:55  
So this is pushed on top of the stack. And then a recursive call is made with the empty sequence of instructions. So we end up here with seven on top of the stack, and then seven should be returned to us.

57:10  
And that's what happened.

57:18  
Let's do something more interesting. What is more interesting.

57:25  
Let's load free.

57:29  
Sorry, one single semicolon, let's also load

57:38  
zero.

57:41  
So this doesn't mean that zero goes on to the top of the stack, it means that the value in in my little memory here at address zero, which is two goes onto the top of the stack, maybe I should here show you how this works

58:00  
as a kind of animation field.

58:03  
So if we were to do that,

58:07  
then what happens initially, we've got slash zero, then we push

58:17  
the thing from address three, which is seven on top of the stack, now stack looks like this. Then we also push the thing from

58:27  
address zero, which is to on top of the stack. Now the stack looks like this.

58:32  
The stack top is the front of the list. And then we say maybe then we say sub actually this is what I want to write is it called arsa. for subtraction, what should then happen

58:45  
to top most elements of the stack should be extracted.

58:50  
The first subtracted from the second and then the result returned on top of the stack, which then will be a stack consisting of a single element which is fine.

59:04  
Which is fine.

59:06  
And it's not this five here that happened to be in the memory. This is just a coincidence. But it's really the find that came from subtracting does it makes sense?

59:19  
What's the happiness index?

59:23  
Yeah, make sense? Does it make sense? Okay.

59:28  
Once we've done this, we can actually now complete our cycle. So we can we are now able to compile target expressions into stack machine code by just doing the very smallest possible tweak in in our code from Tuesday.

59:46  
So this was the compilation. So for example, we kind of saw subtraction in action already, right? So, for example, if you want to compile here, basically the code that says take something

1:00:00  
From address three, take something from address,

1:00:04  
zero it was and then subtract. So minus between them, then what you all you need to do is to combine the one, combine the two, you get two pieces of code, you just concatenate them together. So this is least append. And then finally, you're also concatenate the singleton list consisting of simply our, our sub.

1:00:27  
And you actually get a piece of code.

1:00:30  
And then if e one and E two happened to be these variable things, just t bar zero and T var three, then exactly, we get this piece of code. So let's do that. So

1:00:42  
suppose I want to do our comp

1:00:45  
of the following target expression, what should it be? What was the one that we had here in mind? Was

1:00:55  
t var three?

1:00:58  
I'm not writing them in the right order, even t var zero. And then subtraction, P sub i, sorry, it's called T.

1:01:08  
And then there were then we had minus,

1:01:14  
then this thing

1:01:17  
should give us the correct

1:01:21  
stack machine code, isn't it?

1:01:26  
Because we are basically in this case, and we have to compile t var and tes, t tr three and P four, zero, and they just become the corresponding our loads. And then we get our sub at the end. So let's cross our fingers.

1:01:43  
Am I doing it right with my parentheses? I suppose Yes. And we get the exactly this piece of code that we had before you see this.

1:01:50  
That's how it works.

1:01:58  
What else could I know? To

1:02:05  
know I can.

1:02:10  
Now I can paste together these pieces that I have in all sorts of ways. So right, so we could, for example, start with expression.

1:02:21  
What could it be? I could start with an expression say

1:02:27  
that's an expression.

1:02:29  
The nice expression is

1:02:32  
maybe

1:02:34  
var d?

1:02:38  
bar, a.

1:02:43  
That should be a legitimate expression in our language. It stands actually for nothing else than T minus A in concrete syntax, isn't it?

1:02:53  
I can see I don't like this because it has these numerical.

1:02:58  
I'm sorry, he does these.

1:03:02  
He has these named currying variables, but I'd like to see addresses here. So maybe I say

1:03:13  
maybe I say I want to compile it. How can I compile it, I can compile it to pocket expressions

1:03:20  
to compete, but that doesn't work alone.

1:03:25  
decomp wants an argument

1:03:39  
Let's call t co D confronts an argument which is an environment okay. So let let us give it some environment I give the environment a the.

1:03:57  
So this is my idea of what I want to map variables in the memory age should go to either zero B should go to address. One c should go to others to D should go to others three, it should go to address four. If I do the compilation,

1:04:13  
I get this guy.

1:04:16  
Yes, which I can further compiled to

1:04:23  
machine code

1:04:27  
which I've already actually seen happening. So I get here.

1:04:32  
Yeah, of course. Now I can put together pipes of these things. So right so I could for example, let's give things some names. So let my code be

1:04:41  
my expert,

1:04:43  
which is this one there.

1:04:50  
Now let's say there was this workflow my expert

1:04:54  
I can apply the function

1:04:57  
t

1:05:00  
Come

1:05:02  
to my expert and all these things.

1:05:06  
Oh,

1:05:08  
that's not what I wanted to do.

1:05:11  
Go in the wrong direction as well.

1:05:19  
We've done quite a bit today.

1:05:21  
I have no idea what it is. Oh there.

1:05:25  
I start from the beginning.

1:05:31  
Let me give some more names. So I don't make the same mistake again. So this is a compile time environment, cn.

1:05:44  
Now, this is my expression, this is my compile time expression. This is my compose that means

1:05:51  
I can do the following thing to my expression, I can first tee compete

1:05:59  
using this compile time environment. And then I can further submit this thing to

1:06:05  
the to the further compilation to the register machine to that to the stack machine, which is called arco.

1:06:11  
And we've actually seen both steps. So I've just put them together.

1:06:17  
And we get here in two phases, right? Did I tell you about this nice syntax, you can you can you can write these things with with pipes. And it's kind of maybe even more understandable. So I could say,

1:06:27  
which does exactly the same thing. So take something, apply something, apply something get more to it, but to write it in a different order. So you start with my expert, I pipe it into

1:06:41  
Ah, okay, should they hear the argument all the results are great.

1:06:48  
Okay, I could write it, but it's not so pretty. I can pipe it into T comp.

1:06:55  
It doesn't work.

1:06:57  
The older with the arguments is not great.

1:07:05  
All right, I would have wanted to write t comma C and pipe it in there. And then I further type it into our comp. But you see t comp

1:07:17  
doesn't want C and V as the first argument and my experience the second argument, but the other way around. So to write this pipe notation, I would need to define tea cup with the arguments in the other way. In the other order,

1:07:32  
which you can do with lambda notation or with full

1:07:36  
maybe not now.

1:07:38  
Anyway, this is one possible workflow. But you could you could also go in all possible different other orders right here. So we've got three language source expression stock is target expressions, stock machine code, we can compile between the two, between the three different languages. And we can also interpret each one of them directly, provided we give the requisite additional information so that the connection

1:08:07  
does this.

1:08:10  
Feel was this?

1:08:13  
Okay.

1:08:19  
It's a little hard to understand, but I just think it will come with time or something.

1:08:25  
What I what I want to get across to you is not so much the concrete code, but but sort of the general principles that are here, right? So when you work with programming language, there is always layers, maybe you don't see so much of them, really, you see just the top level, which is the language given to you.

1:08:40  
But underneath there is

1:08:44  
there is usually a power the finite power. I like to say like

1:08:49  
in this old story. Yeah, who upholds the earth and then you say there is a there is an elephant that is carrying the earth. But who is cutting the elephant there is another elephant

1:09:00  
cutting that one.

1:09:02  
And yeah, but what does he finish his elephants all the way down here is not the case. Here

1:09:09  
is not an infinite our elephants there is always something at the bottom, which is like the the actual processor code, right? You can't possibly go beneath that. Maybe again, I mean, you can go to the physics beneath it, but that's not what we do. As programmers or computer scientists, we see, you know, the lowest we sees is processor code, but that's always there.

1:09:30  
And then there is the idea that the different levels, they have to talk to each other in terms of some agreements like here, when I go from

1:09:40  
source expressions to target expressions, at least I should know, what is the correspondence between names and addresses, which was my compile time environment.

1:09:50  
And there are sort of similar kind of agreements that now and then you need to know.

1:09:55  
But otherwise, there is not much else happening. So

1:10:02  
The key concept in this part of the lecture lecture really was powers of languages. And the idea that you often work with environments, which typically are some sort of dictionaries associating something to something. So here, we could directly associate values to names. But we could also go into levels of So first, for an A to A name, you associate an address, this thing is often called the symbol table.

1:10:29  
And then to an address, you can further associate the value. So this kind of mapping is just a memory. Yeah.

1:10:37  
Oh, okay. I've got

1:10:41  
20 more minutes to go. And I'm afraid I have to torture you with more interesting things.

1:10:50  
Which is sort of more of the same, but it gets more complicated.

1:10:59  
I only want to add one little feature, which is local names, which comes together then with some idea of, you know, names aren't one of the same name isn't sort of valid throughout the whole code. But but then it turns out a

1:11:15  
block of the code are here in a sub expression of an expression.

1:11:21  
You can also have top level names that the valley sort of throughout so to say that, but there can also be local names. Yeah.

1:11:31  
So you've seen it in every programming language. So so there is basically two kinds of places where they tend to occur. One is when you simply declare local names for hygiene, I mean, you want to have some privacy of names, you don't want to show your names to everyone, because you use too many, and many of them don't mean anything to anyone else than yourself for them for your piece of code. So that's typically done with, with with block constructs, or maybe with modules and module system has, has its own

1:12:03  
little private namespace.

1:12:06  
Another typical place where you also introduce local names, and that's very important is is functions or procedures, or methods, whatever word you use, for our purposes here that are more or less the same. So there, you typically get two kinds of local names, where are the parameters, so when, when you define a function, there is the idea that

1:12:31  
you have these parameters of formal parameters that actually get matched against the real arguments at a function call or procedure call or method call.

1:12:40  
And then Moreover, it typically also have some local names that are completely local to the function procedure method, isn't it? So that's why you've seen so in in F sharp, we see it in led constructions. And here we model a little expression language. And here we do the same. So the idea is, we will have little LED constructions

1:13:00  
in my language of expressions. So it's expressions as before you do arithmetic, you have numerals, you've got like plus minus times,

1:13:08  
you've got names, but then you can also have local names.

1:13:16  
So let's not even look at abstract syntax. First, let me introduce you to the concrete syntax on the level of equations to start with.

1:13:26  
So here, for example, is a typical kind of a let expression.

1:13:32  
It always consists of two parts, there is some new name that you introduce together with its value that may be given directly as a numeral or maybe as another expression. And then there is what is called the body. So the general form is like, let some name equal some right hand side erhs RHS here stands for right hand side, I often use it here in this type of code. And II bodies is another expression, which is for the body.

1:13:58  
And the idea is, you've introduced a local name.

1:14:03  
And it has value 17.

1:14:07  
In the body.

1:14:11  
Yeah. So if, you know, we were to evaluate this thing in some global environment that had the idea, that's that is five. Then when you add that plus that you don't add five and five, because it's not the global set that we're talking about here. In this sub expression, we've introduced the local debt. And actually we've said what it is is not five it's 17. So the result should be 43.

1:14:40  
Is this clear?

1:14:48  
I mean, this lead in is an expression form like any other like operator application, or like just the human or like just a variable. So in particular, you can nest them inside each other

1:15:00  
So here is maybe one example.

1:15:04  
So this whole thing is an expression.

1:15:08  
And there is some nesting of lead expressions or let constructs here. So the whole thing is a lead, where this is the definition part of a new name, like name and right hand side. And this is the body of the outlet. Yeah,

1:15:25  
the body itself is not another lead, the body itself is plus something plus something else.

1:15:33  
But the first summoned of this addition is another left where stupidly, I introduced another name that they call their prime here

1:15:46  
whose value is 22.

1:15:49  
And

1:15:52  
the body is set times their prime Does that make sense?

1:15:56  
There is nothing that says that you need to define values directly as numerals, I can very well say variables directly humours I can very well say a variable is another expression,

1:16:06  
like, defines that as five minus four in 100 times that?

1:16:11  
How do you think this is evaluated? If you evaluate the lead expression, you first find the values of all local variables. So here, you get to know that you've got the local set that is one and here the 100 times one.

1:16:29  
Uh huh.

1:16:33  
And these examples are similar.

1:16:36  
It's just to show you different ways in which lead expressions can nest.

1:16:42  
Are you happy with these?

1:16:45  
Now, what is not shown here is that there is this phenomenon of shadowing,

1:16:51  
which maybe I should tell you as well.

1:16:54  
So let's play with that again. So if I say something like, let's eat Zed equals

1:17:05  
17, why not?

1:17:09  
In

1:17:12  
Zed,

1:17:23  
Zed plus six,

1:17:29  
plus, plus.

1:17:35  
plus,

1:17:36  
then what is happening now is really important to understand the idea of scope.

1:17:42  
This big thing is a lead expression.

1:17:48  
I'm making a local definition here, which means that in all of this body, whichever was defined globally as the value of seven opposite isn't, is no longer visible. I've got my local set, which is 70.

1:18:01  
So in particular, when I do the addition, the second

1:18:05  
summon is 70.

1:18:09  
But the first summons is interesting, because here I introduced another set, which is five. So that set here is five.

1:18:17  
And the fact that I had just declared or defined that to be 17 is shadowed out. I don't see it here, because I've got my own set, which is five. So here we get five plus six, which is 11 plus 17, which is 28. That's fine.

1:18:35  
Yes.

1:18:36  
Okay, these kinds of things happen and and you know them and one. One final thing to show is, of course, you can also have let's not only in nested let's in the body, you can also have nested let's actually in these definitions. So I can very well also do something like this, let y be

1:18:58  
maybe three

1:19:00  
in white times two.

1:19:03  
Yeah. Now, the scope of this, why is just the definition of the of the death of that left.

1:19:13  
And anywhere else is invisible. So if I were to also use y here, it will have to be a different global y that will get its value from the global environment. It's not locally defined. Yep. But this way, here is three.

1:19:28  
Okay, on the level of abstract syntax is not complicated. So let's, but of course, syntax is the easy part.

1:19:36  
May or may be okay, parsing syntax is not is not easy, but abstract syntax is very easy. You just need to say what you're, you know, what your ingredients are in expressions, you don't have to worry about how you actually lay them out in concrete syntax, like you don't have to worry about lead this whitespace and whether it's mandatory or not, and then these white spaces or other separators none of these nonces lead fundamentally just

1:20:00  
needs

1:20:01  
a string and two expressions, the string is the name being defined locally.

1:20:07  
And the two expressions are the right hand side of the definition. And the body.

1:20:14  
Okay, then it's not difficult for you to work out, for example, this one is now illegal expression in this extended language. And you can work out that it means exactly this thing. Because let's take three arguments. The first is the name define. The second is the expression, which is the definition. And the third is the body which is set by set etc. So I trust that you can work this out,

1:20:41  
we can already do a cool thing.

1:20:48  
Oh,

1:20:50  
I promised you a free lunch. And I suppose the free lunches is as far as we

1:20:56  
more or less get today, and then I will have to continue with this, okay?

1:21:03  
It will be okay, then I have to continue next time because this is really subtle. And it's important to get right.

1:21:11  
I promise your freelance I said local names will work like

1:21:15  
will work like clockwork, without actually us us

1:21:19  
having any effort and that is true,

1:21:23  
they will cause us some trouble when we work with the machine etc, we have to think more. But here they they will come to us really, really cheap, namely free. So to interpret expressions with respect to an environment in these extended language, you need to change very little.

1:21:42  
And so the environment is exactly the same thing as before. So it's a dictionary, it's a list of pairs of names and values associated to them. Because right now I'm doing evaluation, I'm not doing compilation to, to a target to target expressions or are further down to the machine. I'm just doing evaluation directly. I work with these environments, somebody has to tell me what the values of my variables are. And I don't care anything about addresses or show

1:22:09  
the lookup is the old one, I could have actually hidden it in the module and loaded here, or included imported the module here.

1:22:18  
This is the evaluator very little has changed.

1:22:23  
Previously, what changed was that we added these environment arguments to all these cases, but we've already added them. So I didn't need to do this. Now. The only new thing is is this here.

1:22:41  
Yeah.

1:22:46  
So when you want to evaluate

1:22:51  
a let expression

1:22:55  
that has a name, then the definition for the name and the body, what do you need to do actually told you how a lead is evaluated. So intuitively,

1:23:05  
you have to work out the value for the new name, first of all, or maybe they're used only anyway, the name, you're defining the local name.

1:23:16  
I do it by just recursively, calling the evaluator with the same environment that is passed in.

1:23:24  
And you know, just the right hand side as he is.

1:23:28  
And I just locally remember it now this is not the length of, of my expression language, that's the length of F sharp, which also has less. So I define locally that this is the value of x.

1:23:40  
Then I also build the new environment, which is the old environment. But at the front,

1:23:46  
I put that I now want to say that the value of x is x, well,

1:23:52  
I call this environment as and one.

1:23:56  
Okay.

1:23:59  
And then finally, what is the value of the lead, the value of the lead is not the value of the right hand side. But the lead returns, of course, is the value of the body. That's that's that's the purpose of the lead construction. The body definition is kind of a local extra here.

1:24:14  
So I need to evaluate the body. But where do I need to evaluate it in end of

1:24:21  
in the original environment that was passed in?

1:24:26  
No, I have to complete end with the new binding, which was excellent, excellent. So we really have to call it with no one.

1:24:34  
You see this. So there is some global dictionary with which I work. But each time I go deeper

1:24:42  
into nested nets, nested less, less deep nets.

1:24:47  
nested less each time I go deeper into nested let's I grow my dictionary by the new bindings which I put in the front.

1:24:57  
Why do I put them in the front not anywhere else?

1:25:00  
Can anyone tell me?

1:25:06  
Yeah, just think of this example where I had multiple zeds. Like, there may be a global set, and I have a local set, and then I have a yet more local set.

1:25:18  
The global set is perhaps 17, the local set here will be six and the yet more local set is five. All of these values are in the dictionary, but in which order. So if I'm deep down here, and I'm interested in doing that, plus six,

1:25:33  
surely I show that when I start looking things up first, the innermost things should come my way first. So I better put them in the front of the dictionary each time I extend it.

1:25:47  
Does that make sense? This is how I look wrote up my lookup, I always just find the first matching key, the first matching name, and look up the value from there. Yep.

1:26:03  
And now I could, in principle, even provided that declared all names, I can work in an empty global environment that was not possible before. Because before when I wanted to have any names at all, I had to provide an an environment from outside to the evaluator to actually evaluate the expression. But now I can define if I want like a specialised evaluator that evaluates in the empty environment, this one works well. provided all names are defined locally.

1:26:35  
Yeah, let's try and then stop. Through them really want to stop.

1:26:43  
To think we can do all of this today?

1:26:46  
No, no way.

1:26:52  
What is your favourite take some evaluate expression you want to evaluate? Maybe like this one is reasonable. So that should be Let's set is 17 in that plus set.

1:27:03  
But let's start for something simpler. Let me evaluate. Just for sanity. Let me evaluate var Zed

1:27:12  
in an environment where y is 15. And set

1:27:19  
is

1:27:24  
when it's two.

1:27:27  
But now, let me evaluate e one e one is this guy.

1:27:35  
In the same environment?

1:27:50  
What's happened?

1:27:52  
Val is 70.

1:27:57  
Do you think 17 plus 17? Is 17.

1:28:03  
I was expecting for 43 to come back. Let's see what the wonders.

1:28:09  
Oh,

1:28:11  
I've redefined the one that's not a good idea. So let's let's just use this one, of course.

1:28:21  
What's happening now?

1:28:28  
Don't you think I should work in the right fine.

1:28:34  
Let's do load.

1:28:37  
Think it's a better idea. Yes, I'm in the old fight.

1:28:48  
So that was funny.

1:28:50  
This is the one that's my new one. And now I want to evaluate it wherever I wanted to evaluate.

1:28:58  
Namely, here, and the result is 34.

1:29:04  
So the point I want to make is the expression is really this, right? I'm providing a global environment where I say that is true.

1:29:13  
But the result is not two plus two is not four. It is actually

1:29:19  
34. Because while the initial environment is this, at the moment, when I get to the body of the lead,

1:29:29  
it's no longer that it's gonna be this one which is extended. Yeah.

1:29:34  
With 70.

1:29:36  
And that's why it works. And then there are more complicated ones. Let me check if it's correct. It was this horrendous thing, but we can think what it is. So whatever that is, on the outside, inside it is 17. So this is 17. Here, I just do 17 times what 22 which is a humongous number. And then what will come out is

1:30:00  
is the result, which will be 17 times 23. So that is what I expect. And then when we evaluate the two in this environment,

1:30:11  
it will be there.

1:30:13  
And similarly with all of those, but the important one is to one with shadowing can we do one was shuffling

1:30:25  
these ones, I think I've modified them when I explained it,

1:30:36  
we can maybe do it by just modifying one.

1:30:41  
So let me do my expression again.

1:30:50  
Let's put in another left, maybe this one here is is not what you see.

1:30:56  
But it's like,

1:30:58  
let that

1:31:02  
be.

1:31:04  
And number three,

1:31:08  
inverse.

1:31:09  
So justifying the local set, which is three, and I'm adding it together with the outer set, which is 17. So the result should be twin Fie. When we evaluate this

1:31:26  
pair of parentheses missing, of course,

1:31:29  
we're actually in the wrong place I should run.

1:31:34  
So that's an expression. And then when I evaluate it,

1:31:44  
when I'm in the situation when the outer the global set is too, but then I'm not using it at all, because I immediately define a local set, which is 17.

1:31:54  
And then I add that one to a yet more local set, which is three. So I expect not to not 17. Not any of these things back I expect 20. This is 20.

1:32:11  
Now that's exactly time.

1:32:18  
What did I tell you in the second part was

1:32:21  
lead constructions are sort of a generic way of doing local names. So in any specific programming language, it might be called a different thing. Maybe it's curly braces with some declarations in the beginning or something like this. Or maybe it's a function, procedure or method body, or maybe it's local arguments, but morally local names are about such a thing.

1:32:44  
And then working with bigger code that has that has blocks in it with local names, means that you have this idea of environments that extend

1:32:56  
and sort of shadowing out that happens when names are reused in the sense that declare the same name or define the same name again, in a in a more inward scope.

1:33:08  
How is this?

1:33:12  
Are you?

1:33:15  
Are you on my page?

1:33:18  
Happy?

1:33:20  
Yeah, I think it's

1:33:21  
too easy, too difficult. I think it'll just take some time to process. But yeah, it's pretty understandable.

1:33:32  
Yeah, and then try to map it to whatever programming language you actually have in mind. I like to bring concrete examples. But I mean, there is something like this happening in in Python, there is something like this happening in Java C, wherever. There's always the same idea of locality as well as copes, right.

1:33:51  
Okay.

1:33:53  
But then, if there is any, not anything, I can stop here. I, I published the solutions from the of the problems from yesterday. I'll publish the exercises for next Wednesday. But I also published the first set of assignments, I mean, the the hand in assignments today in a few hours. So you'll see those, they will not yet concern this programming language part. They're really about this Crash Course F sharp Crash Course part. And then you'll have I don't remember the deadline, but something like two and a half or three weeks to complete.

1:34:32  
The group is the group assignment or you can do in teams of two, maximum or one, then.

1:34:41  
Yeah, so it's

1:34:44  
up. So for this to make it to work smoothly. I'll create these sort of template

1:34:51  
Canvas groups. I mean, if you make your own groups, the graders won't see them so they will grade the same work twice and everything. So it has to be real groups, but then you can

1:35:00  
freely sign sign sign up for those groups. Or if you just do a thing alone, then you don't have to go via group you just submit.

1:35:09  
But that will all be set for you when I opened the assignment and

1:35:14  
then the upload is just you know, a file and.

1:35:21  
Okay.

1:35:25  
Request. Yeah, thank you as well.

1:35:37  
Thank you.

1:35:39  
Thanks.

Transcribed by https://otter.ai
3:49  
Okay

3:52  
let's start with today Let me check

3:57  
if you can hear me and if I can hear you can someone assist? It's working it's working very good

4:09  
someone says there is no audio but I hope

4:13  
it okay

4:16  
okay good

4:19  
oh no

4:21  
I can hear you. Okay.

4:24  
Works for me someone cannot hear but I think then it's a problem

4:31  
not on this site out okay it's not for everyone okay perfect. We can then get going

4:38  
Today the topic is gonna be lexing. So this is about how to get from concrete syntax to, to abstract without first have to finish something that we didn't quite finish last time, which was the discussion of, of the expression language with

4:59  
with local

5:00  
names. So I showed the syntax, and I showed how the relation goes. But we didn't get discussed

5:09  
the stack machine and the compilation for for this extended language. And now we'll do it, we'll go back to the same file expressions three To start with, and only then to Alexa.

5:22  
And actually, I'm gonna go to show you two different stack machines. So let's go there. And let me share my screen. And then let's recall where we stopped.

5:46  
Thank you.

5:51  
Okay, I told you about the little expression language in in sort of three stages.

6:07  
So there were

6:11  
simple expressions with

6:13  
no variable to the names, whichever you follow.

6:20  
Then we had

6:24  
expressions with global names only.

6:30  
So your expression could contain some variables, like I could have written x plus three, or y plus seven.

6:39  
No declaration of names, all the names that are there are in the top level scope, they are not declared in any particular way or defined in any particular way. So in particular, if you want to evaluate an expression, an outside environment has to tell you what you want the values of your variables to be. And then the last thing we started to look at was

7:02  
Global's names on sorry,

7:06  
the last thing I wanted to show you was expressions with local needs to

7:16  
go, then, of course.

7:19  
Okay, let's, let's recall what the syntax was.

7:24  
So in the simplest case of expressions, we said, our expressions could only have been numerals or little operator expressions, which are of the form some operator symbol, and then two expression arguments to that one where the symbol could be plus times minus typically, then in the next stage, we introduced variable names.

7:47  
So expressions could use variable names, but there was no means to to declare variables, or even to define them in the sense of also giving the variables a value. So for that one, then in the last page, in the first stage, in this file expressions three, I introduced this,

8:06  
this fourth kind of option, or our case here in the data type expressions,

8:14  
within concrete syntax corresponds to something like this. So the idea is we say,

8:20  
the whole thing is an expression. The part the main part of interest is is is here after in, and that's what we call the body of that expression. But then there is this definition part in the expression. And the idea is, I'm defining locally a name.

8:38  
Together, I also indicate an expression whose value is then the value of the name and the scope of this name is exactly this body,

8:48  
and nowhere else.

8:50  
And this sort of usual game of visibility appears here in the sense that you can reuse names, I can already have a name in scope, I can introduce it again with let construct

9:05  
and then I sort of have two versions of the same name and in our scope and in an outer scope.

9:11  
And the inner scope shadows out the definition of the name in the outer scope and the near the name from the other scope is not then not reachable from the inner scope. And then we looked at quite a few examples, both in concrete and concrete syntax and abstract syntax. I will not revisit them. Let's just straight go where we finished off.

9:35  
And then let's go on.

9:40  
So this is as far as I got. I stopped here last time.

9:47  
I gave you an interpreter of these sort of expressions with respect to an environment

9:55  
and an environment is something

10:00  
I also introduced last time,

10:03  
when we were discussing this file expressions to where we only have global names. The idea of an environment is some expressions don't make sense alone, but only to sort of in the outer world they're embedded in. And here, this outer world that we might also call the be calling environment should be

10:24  
sort of information on top or outside an expression that says, Well, if we use names here, global names, and we haven't defined them, something should should fix what their values are. And this data structure that does it is called an environment.

10:43  
You can implement it in various ways, you could do a search tree, here, we do the simplest possible thing, I just formed a sort of list format, a dictionary, a list of string, and integer pairs, where the strings are variable names that I want to map into integers. So the idea then was that

11:04  
if I do something like x, three, y, five,

11:14  
this is a two element list of pairs.

11:19  
This is of the appropriate type that we also call an error here for environment.

11:26  
This is a little dictionary, where I can say I want to look up what the value of x is. And you just walk down the list and see that the first occurrence of x here is associated to value three, in fact, there is only one occurrence of x, which is sort of good for y, I get a similar thing. And if I was to look at that here, I will be told that this name is not found in the dictionary. And if a name appeared twice in a dictionary, or three times or more,

11:55  
then this lookup function only finds the first occurrence.

12:01  
And the trick here is what I also already managed to show last time was that we use this facility

12:09  
that VLOOKUP only finds the first occurrence to actually implement shadowing at no extra cost. So this was a kind of a free lunch phenomenon of the last time. Yeah, free lunches is very uncommon. But it happens today, there will be actually a bit more of it.

12:30  
So what was the trick, the evaluator was quite a bit like before.

12:36  
So it's, it is a function, defined recursively the function is called the Val.

12:42  
The main thing that goes in is an expression E of type expert. Yeah. And what comes out is the value of that expression, then under evaluation, which has to be an integer. But then there is also the second argument and of type n where, so an environment that helps us.

13:01  
So we've got a whole number of cases here, but this one will help us in the variable case. Because if my expression is a variable, I have no idea what its value is.

13:12  
You are the environment to me, and you have to tell me what it is.

13:20  
And then it's possible.

13:23  
Okay.

13:26  
All the other cases here,

13:29  
work by

13:32  
the numerous cases, utterly trivial, but the operator cases worked by evaluating each of the arguments, and then just applying the appropriate operation,

13:44  
where the important point is that object language, so expression, language operations, plus times minus here, which are just strings, get implemented in terms of what a meta language here, F sharp gives us.

13:59  
This one, I'm not inventing a wheel, I'm not writing my own multiplication, F sharp has it.

14:08  
And that's all pretty familiar. Okay, n is important to be passed down, it's important to pass it down from the main call to two recursive calls. Everyone wants to see our values of variables. So not only the top level, so this is actually the way that the environment reaches the, you know, the leaf case of the expression, which is an abstract syntax tree. So we can actually do some look up there.

14:36  
And the only interesting extra case, which will do the free lunch for us was this one. Let me go through it once quickly, again, because this is the most important

14:49  
thing to understand here.

14:52  
Well, it's written in little small steps. Actually, I could write it in one line, but but maybe these local names x Val, and then one

15:00  
Help us to read what is going on.

15:03  
So what's the situation? Suppose I need to evaluate an expression, which is specifically a let expression.

15:12  
So I know some variable that is defined there some local variable, I know what the definition is in terms of the right hand side of the definition. And I know what the body of the left construct is, or let expressions.

15:26  
Also the environment is passed down to me, I have some environment to work with.

15:34  
Fundamentally, what is interesting to us is the value of the body, that's what we want to return.

15:41  
So, we need to evaluate the body.

15:44  
But in which environment. So, in all other cases, except this, the environment in which you evaluate sub expressions is just the same in which you apply or evaluate the given expression.

16:00  
Not so here.

16:02  
Why? Well, because the body can contain variables beyond those that are known to the environment that is passed down to us. Why? Because the body may also contain the newly introduced variable x, or maybe that reintroduced variable x if x was already in the scope before. But now we want to have a local

16:25  
sort of similarly named variable

16:30  
with its own scope.

16:32  
So, then, actually,

16:35  
I can't use the environment I'm given, I should use a modified environment that is called anyone here. So From where does anyone come? So let me just read this thing backwards here. And one is actually the extension of the given environment that comes in

16:51  
with an extra entry in the dictionary, which says, well, the value of the new variable x is going to be x Val.

17:06  
Is this okay?

17:08  
And then, then we need to say, okay, so from where does x Malcolm X well, has to be given by whatever the definition of axes, which is this right hand side here, so that is an expression

17:21  
erhs or it's just the right hand side E for expression. And that needs to be evaluated just in the environment that was handed down to us not they're not the extended one, because then I would go in a circle right?

17:34  
I'm about to define x, but then I would already assume that I have a definition for x No, I just use the environment that is given to me. So, the right hand side is evaluated in the old environment or the environment from the outside

17:51  
whereas the body is evaluated in a in a sort of extended environment that also knows about the value of the

18:00  
of the newly defined local

18:03  
variable.

18:06  
So, in some cases, we might be very lucky in that all variables in my expression e

18:12  
are local to that expression, then we need nothing from outside to actually evaluate an expression. So, this works for closed expressions.

18:45  
evaluations, especially if

18:53  
they can be evaluated

18:58  
in the empty environment.

19:14  
Okay.

19:17  
Let me give you an example of this and then we go on and look at the new

19:25  
material.

19:31  
So let's work with

19:35  
something like this actually, let me slightly modified

19:43  
let me just do this. So, here it is, here is an expression but let me do it slightly differently. So the expression really is let x be 17 in Zed plus x. So now you see this is an expression

20:01  
That

20:04  
has x as a top level variable that is not defined inside the expression.

20:10  
But the zap here is local. Yeah. Because 17 is the definition of that contains no variables. But in the body, I already used that. But this is just as that that I defined here. This is a valid expression.

20:27  
What do you think? It's very easy if I try to evaluate it in?

20:35  
Maybe I'll just try to evaluate it in the empty environment.

20:42  
Let me give it the proper name.

20:45  
Let my expert be this one.

20:50  
I mean, it will be called it's called it now. But the next time it won't be any more. So this is my expression. So what do you think? Where can I evaluate it? If I evaluate it in?

21:04  
Let's try to evaluate it in the environment, what do you think will happen?

21:11  
Any suggestion.

21:16  
So I've got an expression with one global variable, and one local variable.

21:22  
And if we return everything right, then the value of the local variable in its scope should be 17.

21:30  
To see, we know, we have no value for the variable x. So maybe it doesn't work like this.

21:35  
Indeed, when I tried to evaluate this,

21:41  
I goes to places in my evaluator, but fundamentally, at some point, I want to look up the string x and the string set, which are the names here, this this with Zed, there is going to be no problem because I will only need to look it up in the invalid extended environment. Where is that is 17. But with x, I'm in trouble. because x is not introduced locally. And you can find it here either.

22:10  
So let's try something better than I can maybe try to evaluate it in the environment where x is one.

22:18  
What am I doing wrong?

22:24  
Maybe I should put x in quotes what you think?

22:28  
When if the value is 18? Why is that? Well, because I'm adding together as an index. That is fundamentally the value I'm after. And I do this in the scope where the value of 3017 for x, we don't know the value based on the expression alone, but the environment tells us is one. Okay?

22:51  
I don't like that. It's one Let it be 100. And then I get worried 17? Because I'm adding 170.

22:58  
I don't like 100. I want 200.

23:04  
What do you think will happen now?

23:10  
101 on something. Yeah, exactly. Because this is the x that will actually find in the dictionary, right? And the longer dictionary would kind of be useful. If it was not given from the top level, if it's given from the top level, you will never reach the second occurrence of x. But if if a dictionary like this arose locally inside the expression, then it makes perfect sense because I may

23:39  
declare x with lead as well. And there may might be an alter x and then maybe I have a local x which is 100. And then there could be a top level x which is 200. Right.

23:50  
Let's do one more thing here. So let me try to

23:56  
let me try to influence the game. So I don't think that is 17 I think that honestly is 42

24:07  
what do you think will happen now?

24:11  
Still 117 Yes, perfect. Why? Because

24:17  
the other new set will be pushed in front. Yeah, exactly. So we don't see quite here. But if we if we were able to step back, then at one point

24:28  
there will be a different environment

24:31  
with which the

24:34  
with which the body is evaluated or with respect to which the body is evaluated. And that will look like this.

24:40  
Yep.

24:44  
So that would be this kind of n. So if the if this guy were n at one point, or maybe these sort of on the top level, as we pass it in here, then the end one

24:56  
at the point in which we evaluate the inner guy

25:00  
Here, this one will actually look like I wrote here. Yeah.

25:08  
Is this fine? with everyone?

25:14  
Say something. I can't see you any of you. I only see my screen.

25:24  
Did you all go to get coffee?

25:28  
No, no, that's good. That's good. Thank you.

25:34  
Yes, I, I think this is fine. I guess I think there's just a little bit time to sink in. Yes. And I will give you more stuff, which hopefully will pile on top of these things. So it will make the whole load levier heavier, and it will sink in. So

25:55  
So yes, let's see.

25:58  
So here is a little exercise that's kind of useful.

26:02  
It would be nice to be able to determine for given expression, whether it's closed. And closed really means exactly this thing that,

26:11  
you know, an environment that I could basically,

26:15  
sorry.

26:17  
Closed is an expression that I could evaluate in the empty environment. So this means that then the expression really self contained, it doesn't need any outside definitions, every variable used is already locally defined on some level inside this expression.

26:34  
How would we implement this?

26:41  
Well, if we didn't have the local definition facility, then it's very easy to do a check whether

26:49  
an expression is closed. So if an expression is not allowed to use left,

26:57  
then it's closed precisely when it doesn't use var either, right?

27:02  
Because if I'm not in the position, to define any local variables, then all the variables I can use are, are, are the global ones.

27:14  
And if I then forbid global ones as well, then then I shouldn't simply be able to use any variables, right.

27:22  
So that's a nice situation. But if we want to keep track, whether an expression is closed, in the presence of lead constructions, that's actually not so easy to programme. And you may need to think about

27:37  
how to do it at all.

27:40  
And the trick is, you could recurse over the expression.

27:47  
And wherever you are, you could try to see

27:54  
if the variables that are used.

27:59  
They're all defined in the lead constructs that sort of enclosed you. So imagine you're somewhere deep in the ASD. And you see at the leaf that now here is the use of a variable.

28:15  
So this use of a variable is fine in the sense that you don't need an outside environment if between this leaf

28:24  
and the root of the tree which the expression is there is no lead on the way that

28:30  
sorry, there is a lead on the way that defines this variable, right? So if somewhere you see var x, then you expect that you're part of some lead x in blah.

28:43  
Okay.

28:45  
So then the idea is, when I process a tree, I could I could work with a little accumulator, so that when I walk down the tree, I record the names that have already been defined on the way to wherever I am in the tree.

29:02  
And then when I hit the leaf, when I when I, when I hit the var leaf in the tree, I just have to check whether my variable is in the accumulator. Okay,

29:14  
then that's not so complicated. So what do I need, I first need a trivial helper function that just checks for any given value and the list where the value is in the list.

29:26  
I call it contains, sometimes it's called the curse. Maybe it's called, maybe it was called the curse in in one of the problems, that's actually Anyway, here is a very simple definition of it.

29:42  
We could say, if my given list is empty, then it surely doesn't contain x is false. And if my given list is y followed by some rest of the list, then there is only two ways that x could appear in this list. Either x is the head element, or it's somewhere in the rest

30:00  
The list right, you can only be in the list if you are the tail. Sorry, if you are the head of the list, which is this check here. Or if you're in the day.

30:10  
checking if you're in the tail is a smaller problem than the main problem of checking if you're in the whole list, so you reduce the bigger problem to a smaller problem.

30:23  
Once we have this helper,

30:27  
I can actually write the function. I think here I've done some anything you can also write contains with the help of a built in function list exists. But if I've already defined contains, I should really say contains

30:41  
x axis here, which is the same thing.

30:46  
Okay, so. So what's the idea then checking if an expression is closed, so the top level programme will be called closed.

30:56  
And it takes an expression, maybe I should give you the type.

31:00  
And it returns a Boolean, which just says whether the expression is closed or not. So true for closed, forms for not closed.

31:09  
And this is defined by calling a helper function called closed in,

31:14  
which actually, strictly speaking, doesn't check if is closed, it just checks if all variables in E appear in the given list, which is this accumulator here.

31:28  
Okay, the definition of closed in is here.

31:34  
Thanks any expression, and takes this string here, the accumulator returns a Boolean.

31:41  
How does it work?

31:44  
In the variable case, I just check if the variable is in the list that I tolerate.

31:50  
By the given sort of pointing the tree,

31:54  
I mean, at this leaf of the tree,

31:57  
probably because along the way, I sort of accumulated this list going through the lens. So these are all the variables that are defined somewhere in the tree.

32:09  
Above us,

32:13  
numeral is clearly just closed. And then operator term

32:18  
is closed, or has all of its variables occurring. The next is if both of the sub expressions have their very well contained indexes.

32:31  
And of course, all the work well the interesting work happens in the lead case.

32:41  
So when can I say

32:46  
that all the uses

32:50  
of variables in a lead expression are contained in a given list exists?

32:57  
Well, I need two things. So first of all,

33:04  
the data definition, the definition of x doesn't take effect in the right hand side, right, the definition only takes effect here in the body. This is where you can use the newly defined variable. So

33:15  
So here's a list of variables where my uses of variables are allowed to be

33:21  
for E, and exact the same variables are allowed then for the right hand side of the definition.

33:30  
In the body, I can use one variable more in the body, I can actually use not only the variables Xs, but I can also use the newly defined variable x.

33:44  
Okay, let's try what this means.

33:49  
Let's see.

33:51  
What is my expression? Let me remember, remind you what my question is.

33:57  
So that's my expression. It is let Zed be 17 in Zed plus x.

34:05  
Let's check if it's closed or

34:12  
not closed. Yeah, well, indeed is not closed, because that is defined in the expression. But x doesn't have a definition inside the expression. So to evaluate this, we need the definition from outside in an environment.

34:29  
Let's check if it's closed in the empty list.

34:39  
No, of course, I mean, closed in the empty list is exactly the same thing as being just closed.

34:47  
Maybe it's closed in the list consisting of x only. And that's true. So basically, this says, As soon as I know the value for x, I can already evaluate my expert because this

35:00  
is the only variable

35:03  
which is not defined locally?

35:06  
Surely I'm also closed in excellent. Why?

35:14  
What did I do wrong?

35:21  
Don't

35:25  
know I'm in some bad mode.

35:34  
I don't know what that press sorry for this.

35:38  
Mr. Mr. Comma

35:41  
what is the comma?

35:44  
But on the way?

35:48  
Here, let me see Yeah, okay, I completely confused it because there is a quote

35:55  
that is unbalanced. Okay, too bad.

36:06  
Even worse.

36:14  
Yes, thank you. No.

36:19  
Okay, that was not meant to happen.

36:31  
Oh, my No, I also managed to lose it.

36:34  
Oh, lucky.

36:43  
I think it was this.

36:50  
That was my impression. And the check that I wanted to do was whether this was also closed in now let me do it properly.

36:58  
So this was the missile

37:02  
close in.

37:05  
And it's true. Why?

37:08  
Because all of the variables in this expression that are not local, namely, just x is contained in this bigger list x and y. So I'm closed in that list. Excellent. I'm already closed the next.

37:26  
Okay, do something more important. Now, we are ready to compile.

37:34  
So remember last time,

37:37  
I had sort of two languages that we went through. One was combined expressions name cutting expressions to expressions, where instead of variable names, we use sort of memory allocations for variables. So instead of var of string, data constructor, we will have a T bar of int data constructor, what are the entities is like,

38:07  
location rather than an or address. So we say

38:19  
the idea was that as we

38:23  
I can I can combine my my expression with global names

38:31  
into this kind of target code that have

38:35  
number what number these named Germans? Yes, that's the a number of variables, provided I have some compile compile time.

38:44  
environment, which tells me which variable i want to put that which address.

38:52  
We can play exactly the same game here.

38:55  
But actually, there is an interesting aspect now. And that's important. That's also maybe the reason why it makes sense to discuss this intermediate language as one in its own right.

39:06  
So

39:11  
remember, our left

39:15  
so the left here works with

39:18  
a variable name. That's the new variable that I'm introducing

39:24  
its definition and then the body of the lead

39:27  
here in the target language, I will have a slightly different lead.

39:32  
This may look frightening from the beginning. For some reason t lead only takes two arguments. So there is one expression. So this corresponds to

39:50  
to the right hand side of the definition and this one corresponds to the body.

39:54  
Why am I not saying at which address I want to put the local variable

40:02  
And here's a trick,

40:06  
I can always put it in the same place,

40:10  
provided I move the other things around.

40:13  
I mean, we may discuss whether this is a wise thing to do or not with the real heat. But for modelling, it actually makes perfect sense. So what I could do is a new variable always gets numbers zero.

40:28  
But there might have been

40:30  
older variables, right, that had their other that had their own address numbers, and one of them could also have been zero. So what I can do is to shift all the other addresses up by one

40:46  
address.

41:00  
I could do that, right.

41:02  
So this is often costly. I mean, you don't want to move things around. But suppose you implement it, you implement it, the memory actually also by a stack, and then it makes perfect sense, because these numbers then just correspond to positions in the stack. And introducing a new variable just corresponds to pushing a new value on the stack, and keeping all the other values in place. And then there is no associated cost. I mean, it looks like there is a cost it would be if you were to move things around in a memory. But if you work with a stack data structure, there is no associated cost. Do you agree with this?

41:42  
And, and then that's the language. Otherwise, it's just the old one.

41:50  
Let's see if I can interpret these target expressions.

41:54  
Well, let's first write one target expression. So what could be a reasonable target expression.

42:02  
Let's, for example, take this one.

42:08  
So here, maybe I already have some

42:13  
variable, maybe it's variable two.

42:17  
And here I'd like to use variables zero.

42:21  
And here,

42:24  
I'd like to use the lead and then of course, these are t let t non

42:29  
t up

42:31  
to our T bar.

42:33  
That should be okay.

42:36  
See, t let now has one argument as opposed to let which had three.

42:41  
So that is a valid t expert, we're good.

42:45  
I should be able to interpret this one with respect to a runtime environment.

42:54  
So previously, an expression is sorry, an environment was a dictionary. So it was a pair sorry, it was a list of variable name and value pairs.

43:05  
variable name and integer pairs where these were integers. Now it suffices to just have a list of integers. And the idea is, the zero with value is to address zero is sort of the beginning of the list address. One is the next position in the list address two is is yet the next position in the list, etc.

43:53  
Okay, and here is the evaluator. The evaluator is exactly the same one as before.

44:00  
But I need to change to cases, the bar and let the rest is like I let I write capital T's and little things everywhere. Because I'm changing eval to give the eval and all my data constructors have different names.

44:15  
So when I want to know what the value of the variable

44:22  
and ease, what do I need to do? Well, I simply have to look up the NF element in the list list item just indexes into a list here and AR n is a list of integers. Simple.

44:36  
When I do let 10, there are only two arguments. This is the definition of the new variable, that's the body of the left.

44:43  
The idea is exactly the same as before you want to return the value of the body in the extended environment. We extended the environment is the old environment extended within your value. And look what happens here. The new value on purpose

45:00  
As I placed a position zero at the beginning of the list,

45:04  
and the positions or the addresses of all the old values have been shifted up by one. So whatever was at position two in the list before is now in the new list this one, Lauren is at position three.

45:20  
And From where does the value come? The value comes by evaluating the definition, or the right hand side of the definition in the, in the environment passed down, not the modified one.

45:34  
Okay, that's interesting. Now let's do a little evaluation of my expert. This is the new expression, right?

45:43  
We need a bit of environment to do this. So we need some numbers.

45:50  
Let me give you some numbers. They are always the same, like 40. Cool. 1011 2021.

46:04  
What else do you want?

46:12  
Running out of numbers?

46:16  
Maybe minus three?

46:21  
Question.

46:25  
This is a quiz.

46:27  
What value will I now get from this expression?

46:31  
So I'm adding together

46:34  
the zeroeth variable.

46:39  
And the second variable.

46:49  
So any guesses?

46:56  
How much

46:58  
2063 2063 2063. Okay, so what you did was you added together a very good guess, but not completely correct. You add it together this one?

47:16  
And this one? Yeah. Or like this? Second?

47:23  
This should be 17 plus 1010 11.

47:29  
That is actually correct. But why was the first one almost correct, but wrong? And why is yours? Correct?

47:38  
Because it's the inner scope environments. Exactly. So.

47:46  
So the point is, by this stage, we reach here,

47:49  
my environment, my environment is slightly different, right? My environment is actually already 1740 to get to 2021 and minus three.

48:02  
Right?

48:04  
So yes, 17 plus.

48:09  
So after I think Tina,

48:12  
approaches you bring up Tina is the shito. element.

48:17  
Well, not so much processing, Tina, Tina itself doesn't change anything. But it's the fact that we are in the Tila.

48:25  
And the whole thing here is the second argument of Tila. So this is one of these he bodies here, it's this 114, right? To see this.

48:37  
So if we pattern match this one against this, then the body is this one.

48:43  
So it's not so much the team that matters. Well, the TNM gives us the value that goes in in front of the dictionary. But But what really affects us is the t let the fact that we are the second argument. So everything here gets shifted, but very good guesses. So we could also do another one. Namely, let's do t eval.

49:05  
Let's just take the new one. This one here.

49:09  
Let me see if I can get my parentheses right.

49:15  
Did you just do the no 1am? I good? No. Yes. In the same old environment here.

49:25  
And now, we will actually have one of your suggested before. Too bad. I can't see yours here.

49:32  
So this will should now be actually what you just said. So 42 and 2021, which is 2063.

49:42  
Yeah.

49:45  
And then you can imagine how this game goes.

49:48  
So this is the idea of how sort of scope mounts and accordingly these dictionaries grow

49:56  
or just naked environments grow here.

50:02  
Let's do compilation. compilation is fun. So we want to go from source expressions to target expressions.

50:11  
What do I need here?

50:16  
This is again a variation of a simpler piece of code that you had expressions to. But the new aspect is that we have the lead construct here, and we have to worry about it.

50:29  
Okay.

50:32  
So when I want my game nowadays, I want to compile a source expression, the one that has sort of name carrying variables to target expressions, where my my variables are just addresses.

50:50  
I can do this move provided that someone gives me what we call a compile time environment, which is for the global names, someone should tell us where do we want to see them

51:06  
at which addresses. So this is kind of an agreement between the the compiler

51:13  
and ourselves, so to say,

51:19  
but that we only need four global variables, because for these ones, we need to decide where they are in the environment. As soon as we get local variables, they automatically get their own addresses. And actually, the fact they do get some addresses pushes around the other variables addresses, they will get shifted up.

51:39  
So let's see.

51:42  
This function we also had before, it is a thing that takes a variable name.

51:50  
And the list of variable names and it finds the position of that variable name in the list if it's there at all.

51:56  
Actually, the function is a bit more polymorphic. doesn't even matter that this works for strings, it works for any type.

52:06  
So long as it's type supporting the quality check which we need here.

52:12  
So the idea is very simple. If you want to look up the variable name in a list of variable names, you just go down the list, if you're at the empty list, you didn't find it.

52:23  
If you're looking at name up in this list, you check if it's the head, if not,

52:29  
you check if it's the head, then you if it is the head, then you know it's at that position zero in the list, or at index zero, or at address zero, these all synonyms. Else, it's somewhere deeper, if it is anywhere at all, then you can just go down with a recursion and whatever recursion tells you, you just add to this

52:49  
add one to this

52:51  
compilation, how did it go.

52:55  
And number is compiled to a number an operator expression is compiled to an operator expression. But you have to go sort of recursively deep into the sub expressions and you need to compile them. Why? Because somewhere deep down in the expression, you actually have the uses of the variables. And your source syntax uses names, but your target syntax uses numbers. So, when you read the use of a variable, you better check where this variable name is in the compile time environment. And this one will tell you an address and you just replace the name Korean variable with that sort of address carrying variable

53:40  
something happens

53:53  
and again this kind of again about extending an environment.

53:58  
So when I compile a let expression, it has to go into a t let t let doesn't even give me a possibility to indicate any number here. The reason is the number is the default one is zero, the new variable is always zero.

54:16  
The right hand side is compiled using the same compile time environment environment as the whole lead expression. Because the numbers haven't shifted there.

54:27  
The body has to be compiled in a new runtime environment in which x is at position zero at address zero at index zero whatever you call it

54:38  
and all the other variables have shifted up by one

54:43  
Is this good? And then we could play the compilation game this is the this is the this is the story. Suppose now

54:53  
what

54:55  
maybe I want to compile

54:58  
first, this one

55:07  
My ex,

55:18  
sorry, this is just, if I want to compile it,

55:23  
I need to provide some idea where I want Exocet to be, maybe my idea is

55:38  
maybe my idea is the following. So

55:42  
why?

55:54  
Now you can guess what the compiled code would be?

56:07  
Anyone?

56:18  
So, the inner set would be t voir cirro.

56:24  
And the x would be t word to?

56:31  
Well, for the moment, it's not even intersect, right? I mean, the answer is correct. But, I mean, I'm just looking at the sub expression here. And from the point of view of this sub expression, everything is global, right? Yeah, exactly. But But you do get 1012. That's exactly right.

56:51  
Let's try to do something else. Let's now try

56:59  
the real one of interest.

57:03  
So how do I fix it? You fix it like this?

57:09  
Surely I do something wrong with the parentheses?

57:17  
Yes. Now, I'm back at the old expression to agree.

57:21  
Maybe now let's play this game here.

57:27  
So I don't have a set in my sort of environment that is passed in the compile time environment.

57:35  
What do you expect will happen now?

57:54  
t var. Shiro I guess.

57:58  
And t var. Two again?

58:03  
Yes. And all this is in a T land? Yeah, no. 17. Right. Exactly.

58:10  
So is everyone with me on the same page? I mean, this is excellent. So in the environment that is posting, the idea is one is either a zero and x is a dangerous one.

58:24  
But the point is,

58:27  
this sub expression has a different view of the world. Actually, not this one. Rather, I should say this one has a different view of the world, right? This one will already see a compile time environment, which is Zed y x. And then basically the old thing will happen.

58:46  
Just for clarification, the number 17 there. Haha said

58:52  
its significance there. As in if the said gets acetal. If that's the value, or it should just not map to the Ah, no, no, no, no, no, no, no, that's an excellent question. But But the answer is a bit different. So

59:14  
Well, the answer we will see when we actually start to evaluate this thing, which by the way already occurred, right? Because this is exactly the environment at one point, I was working here.

59:27  
Yeah.

59:29  
So So let's do this. You agree that these two are exactly the same, this and this was in whitespace.

59:37  
And here, we actually we call it my experiment, we tried to evaluate it.

59:42  
And the interesting thing was, it should add together the variable 012.

59:50  
But when you look at the values that are passed in from the top level to the evaluator,

59:56  
they are

59:58  
42 2010

1:00:00  
11 and 2021. And I'm not adding together the zero with and the second

1:00:08  
position in this list

1:00:12  
to get

1:00:14  
2063 rather, as the answer, we got

1:00:20  
1028. And the reason was exactly this genome. So this, this 17 is pushed in front of this list

1:00:30  
when I reach there with my evaluation, so therefore, I will get again,

1:00:41  
yeah

1:00:43  
17 plus 1011, which is 1028.

1:00:49  
Okay, so this may be a bit difficult to wrap your head around at first, that is a very

1:01:01  
I mean this this trickery with addresses.

1:01:05  
I understand that this can be counterintuitive at first, but this is really the mechanics of this kind of things.

1:01:12  
I mean, whatever you do, so here I'm showing you a very naive implementation of things. But actually, the real stack frames

1:01:20  
work exactly the same way.

1:01:24  
What we got there.

1:01:26  
Now, I need to do one more thing, before we can get to our actual lecture, which is a simple, simpler thing,

1:01:33  
I want to show you that we can go one level deeper, and we can do a stack machine.

1:01:41  
So, remember the one that we had before,

1:01:45  
where we worked, like we did little calculations, like three, plus two times five, or whatever. And we worked with a little stack of intermediate results to calculate such things here is exactly the same. This is our old stack machine instruction set.

1:02:03  
Except

1:02:05  
various,

1:02:08  
three more instructions.

1:02:17  
There is one that is called our load. And the idea is

1:02:22  
this stack machine will actually work with sort of two stacks. One is the stack for intermediate values like we had before.

1:02:29  
And the other one is, let's do kind of a joke. It's like a stack implementation of heap for variable bound values or this environment that we have.

1:02:40  
So I have all these local variables and the global variables as well. And they are in a data structure, which is this list or stack that we saw.

1:02:49  
And now and then I may want to look up things from there, this is like loading from heap to my intermediate value stack. So you load from the environment,

1:03:00  
I should say, to the top of the stack and

1:03:12  
to the top of the intermediate value stack.

1:03:17  
Our story is kind of the opposite. And this is an an instruction you will use to actually reorganise your environment. So this is the one that you will use that the new variable definition.

1:03:29  
So you push a thing into the environment a value into the environment, which means that the addresses of everything will also move one up, but they go down in their stack, but their addresses will be shifted up.

1:03:43  
It's not my fault that stacks are usually drawn sort of from top to bottom. So the highest level is called zero and the lowest This is a big number.

1:03:54  
And arrays is what you use to sort of garbage collect. So when you're done with your local scope, you want to go back to the to the outer scope, which means you want to shift your

1:04:11  
your environment back so you want to get rid of the zeros position. And you want to move all the other positions down which corresponds to sort of shifting this environment

1:04:23  
back up again.

1:04:27  
Okay.

1:04:29  
Now there is very little to show. I want to show how you run the state machine code, but this is pretty much the old thing. And then finally how to compile a target expression into state machine code.

1:04:45  
The interpreter looks big,

1:04:48  
but it's the it's the same one that we had in

1:04:54  
in expressions to except for these new two instructions.

1:05:01  
which allow us to sort of grow the environment and shrink the environment again.

1:05:09  
So remember, when you load from a certain position in the environment, then you just look up

1:05:17  
at the right position in the environment, and you push the result on the stack. So the recursive call happens within your stack, for the next instruction that you're gonna interpret.

1:05:29  
And the only new ones here are stored in the race.

1:05:34  
So store works with something on top of the stack, and you move it into the environment to the beginning of the environment, this is a thing that we will use

1:05:46  
to implement a local definition

1:05:49  
of a lead. And the race is something that we use at the end of a lead.

1:05:55  
So if you try to run an eraser to execute an erase instruction

1:06:02  
with a certain state of the stack,

1:06:06  
you will go on with the same stack.

1:06:10  
But your environment will be just the tail of the given one. So you throw away the head element,

1:06:18  
which means positions are all shifted

1:06:20  
down again.

1:06:23  
Okay, if this is the mechanics, how could I possibly compile?

1:06:30  
It's the old compiler.

1:06:32  
So what are we doing, we are compiling an expression,

1:06:37  
the target expression, the one that has address getting variable deceivers into the stack machine code.

1:06:47  
The code is exactly the old one. With the exception of the only new clause here, the D lead, which is our new thing.

1:06:56  
So remember what we did there, some of the things were not so hard.

1:07:01  
Remember, also, the idea of the SEC machine is that I want to find the value of my expression

1:07:08  
at the end of the execution of the stack machine at the top of the stack. So if my expression is just the T num,

1:07:16  
my only instruction should be put the number on top of the stack, this is our NumPy.

1:07:25  
Also, if my expression is just the use of a variable, then I just want to see the value of the variable at the top of the stack, so my single instruction here will be load that variable from the environment to the stack.

1:07:43  
For an for any operator, you do a similar thing, you'll compile the two parts, the two sub expressions, and they give you two instruction sequences that you just concatenate together. The idea is this one will produce you the value of a one on top of the stack, this one will do some more work with a stack, but at the end,

1:08:04  
it will have added the value of IE two on top of the stack. So finally, the two values are the topmost element of the stack. And then you just need to concatenate the our ADD instruction, whose effect is to pop off these two elements, add them together and push the result back.

1:08:24  
Now, the only interesting part is here, what's with my tea left, though?

1:08:33  
This is a clever thing.

1:08:37  
So let's think what the idea of Pilates like the T lead here.

1:08:43  
If I were to

1:08:46  
evaluate this thing in which order did we do this and how to compile it to stack machine code, the idea should be your first so there is two expressions involved

1:08:57  
the definition of the new variable

1:09:00  
and the body of the lead.

1:09:03  
So you should really first

1:09:06  
process the definition of the new variable, this will give you a bit of code that will produce the value of the new variable on the top of the stack.

1:09:16  
Hmm, very good. I could do that.

1:09:20  
So combine the right hand side so this is a bit of code that will produce the value of the new variable on top of the stack. Actually don't want this on top of the stack. I want this in my in my environment in the zero position Aha. This I can implement by just

1:09:39  
adding a little our store

1:09:43  
instruction here.

1:09:46  
So this will place this value at the zero is position in the environment and will push everything down in the environment or shift or others is up if you wish.

1:09:58  
So now

1:10:00  
I will go to compiling the body.

1:10:03  
But the compiled code for a body will actually work with an environment which is shifted. But that's great, because this is also how these addresses work in compiled code for.

1:10:15  
For bodies, I mean, they, the moral is you already think everything has been shifted. And now this guy actually gets the real environment with all the value shifted.

1:10:26  
So we do that.

1:10:30  
And this is almost good. So after that, I have exactly the right thing on top of my stack, which is

1:10:40  
the value of the body.

1:10:42  
But somehow, I need to do one more step I need to put also at the end of this instruction sequence, one final instruction, which is called array arrays, why is this?

1:10:58  
Well, because the T lead could be part of a bigger expression.

1:11:05  
So maybe my whole expression is some t let

1:11:08  
a plus y.

1:11:12  
And the why, of course, will have to be interpreted in the global scope or in the outer scope. So I better when I leave processing, the T lab, I should restore what my environment was before before the extension, so therefore, they are arrays. So get rid of the value of the zeros position, which is no longer needed, after all the definition was local.

1:11:36  
And shift

1:11:38  
shift all other addresses down.

1:11:42  
Yeah.

1:11:44  
Okay.

1:11:45  
And then then we can actually compile a thing like this to,

1:11:51  
to target to stack machine code. So here is one example. That's already an expression. Let me just compile it. So I'll take our concrete or combo, it is the last thing here.

1:12:04  
Let's see what happens.

1:12:08  
Huh?

1:12:11  
What is this?

1:12:14  
It says. So this is how we actually evaluate the thing.

1:12:22  
Our exercise is to push

1:12:27  
number 17 on top of the intermediate value stack,

1:12:32  
and then immediately pop it off and move it to the environment. Aha. So whatever environment came in,

1:12:42  
if I were to execute this compiled code,

1:12:46  
this environment is now shifted, and 17 is at the beginning, and the rest is further down

1:12:51  
in that list, which is the environment, then I load zero. So I take the zeroeth element from the environment, I put it on top of the stack, I also take the second

1:13:07  
position, or the value from the second position in the environment from address to put it on top of the stack,

1:13:13  
then I pop both off, and I add them together. So therefore, now the result of the addition is on top of the stack. And that is actually what I need to see at the end of my computation. But moreover, so here only for hygiene purposes. But of course, if this thing we're concatenated with more code is really important, I also make sure that I establish or that I restore my old environment at the end.

1:13:39  
So now I can take this code,

1:13:42  
and I can actually run the register machine. So I can do Ravel, it, it is now this code

1:13:54  
on some environment and let the environment be the same one that we keep working with here. So I wanted to be well exactly this thing.

1:14:10  
And now let's see what happens. Now.

1:14:16  
What arguments does it take Ravel also wants to have a stack argument the stack is initially empty.

1:14:22  
So, Ravel takes what it takes stack machine code, which is it, it takes a stack for intermediate results, which is initially empty and at the end I want to collect the value there. And then it takes this environment which has the values of all global variables numbered 0123 originally, but they can get shaky.

1:14:44  
And then when I evaluate it, I get the old thing again.

1:14:49  
We which is 1028. Why? Because by the time

1:14:55  
I get to our load zero and our load two I've done

1:15:00  
Our store, which actually store 17, but also shifts around all the addresses. So what was

1:15:10  
01? Is no one and what was to what? Sorry, what was zero before is no one. And what was to before is now free.

1:15:17  
And instead, what was one before is now two.

1:15:23  
And the zero position is simply 17. So I'm adding together again 17 Anthony,

1:15:28  
Is this good?

1:15:32  
I think I want to the last part, which is compiling

1:15:38  
to work with a different stack machine, which is a clever one in that it has both intermediate and variable bound values all in a single stack. Maybe I want to return to it later, but just to let this part sink. Let me

1:15:54  
let us pause a bit. So

1:16:02  
do you have questions?

1:16:04  
Should I repeat something? Should we take stock and just see where we are?

1:16:13  
No, I think we are all a bit out of breath here.

1:16:17  
That's good. Yes.

1:16:21  
That's that's what it's called agile programming. The idea is, you do everything quickly and together and you can only think after because there is this competitive situation and someone wants to show off. So in this case, me.

1:16:37  
But the big picture is this we looked at three different Okay, we looked at three different levels of expressions, very simple ones, no variables and global variables and local variables. And for each of those, I well not each of those, but at least four already with a situation with names.

1:16:59  
global or local, we had three different levels of language that was the source language with name carrying variables, there was kind of a little intermediate one where straight in the expression syntax, you start writing not variable names, but the address is where they happen to be at the given moment

1:17:18  
in your implementation of the heap, which is that like,

1:17:22  
and third there is a register machine. And then there is or stack machine, stack and register machine I should say.

1:17:30  
And,

1:17:32  
and then the idea was to demonstrate how you work with scope.

1:17:37  
And also how you work with multiple levels of languages, right, you can, you can either do an evaluator directly for the source language, maybe for the intermediate language, which are here these target expression, maybe for the lowest level of a language, which here is this tech machine code.

1:17:53  
But you can also combine between these levels. So there is like, so here, there is really how many,

1:18:00  
I will say there is three workflows to actually evaluate an expression either evaluate directly a source expression, or you compile it down to a target expression and evaluate there, or you compile it further down to stack machine code and run that one.

1:18:18  
Okay.

1:18:22  
I leave you with this burden. But you have to bear with me for 20 more minutes, which is exactly right.

1:18:30  
To

1:18:32  
throw the Lexa on you, and I have to tell you, this is a much simpler thing.

1:18:42  
We'll do it also just for a very

1:18:47  
well more or less for the same language really.

1:18:50  
So I want to consider this language war let know instead of up I have separately plus minus times, but otherwise is the same.

1:18:59  
But we're not doing anything deep semantic or evaluation or compilation or something like this. All we do is

1:19:06  
we want to think how to not write such unreadable stuff. But how should we able, how should we be able to just write what we ordinarily write

1:19:17  
like concrete syntax,

1:19:25  
which is to say, I'd like to write

1:19:30  
Let's set equal 17 in that plus x

1:19:36  
rather than

1:19:43  
the horrendous thing here.

1:19:45  
That's the game now.

1:19:49  
You must agree with me

1:19:52  
that this is more human friendly.

1:19:56  
And this would actually be quite nice if it were written down as a tree like

1:20:00  
In a, like drawing on a paper two dimensionally, but like this linearly is really difficult to read.

1:20:07  
So this thing is a flat string is called concrete syntax. This is called abstract syntax. Abstract Syntax is easy to process by pattern matching. That's really the beauty of how you normally do language processing and functional languages because of pattern matching, in particular, perfect for this.

1:20:27  
But this is what you want to write, you want to get from here to here, we already talked about this a bit. So getting from here to here is called pretty printing.

1:20:38  
Going from abstract syntax to concrete syntax, going from concrete to abstract, which is what you want in a language process, the front end

1:20:46  
is usually called parsing. But if you look into it closer,

1:20:51  
parsing is used in two meanings. Its main, either used for the whole workflow here.

1:20:57  
Or maybe just the second face, other sort of a bit more refined workflow.

1:21:05  
So what's the game, you start with a flat string like this.

1:21:11  
And rather than going from here, to here directly,

1:21:18  
there is an intermediate thing you could do, which in this case would be to, you know, this is like, you're listening to a foreign language, like, I don't know, French,

1:21:30  
I hope not so many of your can, French. So the first problem you have when someone speaks French is not so much to understand the sentence structure or so you just want to cut the flow

1:21:42  
into words, people out there, right, isn't it.

1:21:46  
And then you hope you can look up these these words or recognise them or, you know, repeat them to pair up them to some sort of online translator, word by word. So here is a similar game. So when we are given a string, the first thing you may want to do is to lexer tokenize. it these are synonyms, the result is a list of tokens. And this is a nice sort of intermediate level from which to then actually go and parse to an abstract syntax tree.

1:22:27  
So in our case, the list of tokens could be something like lead. So I first recognise that there is a keyword here, then there is a white space white space below, it plays no other role other than telling us that

1:22:42  
something new is gonna start. And here the thing that is going to start is called forgot name.

1:22:51  
So the next thing we'll find is a name that is that.

1:22:55  
And then we maybe find an equal sign, what is the phone call?

1:23:04  
Let's call the call.

1:23:10  
And then I'd like to find that Well, here I have a numeral.

1:23:15  
So it's just an in 17.

1:23:20  
So I'd like not to worry about one and seven, but just to see as characters, but I'd like already to work with a number 17 in F sharp, then I'd like to see okay, there is a keyword in then maybe I'd like to see there is a name again.

1:23:36  
Then I'd like to recognise there is a plus sign. And then I'd like to recognise there is a name again, which is

1:23:44  
which is

1:23:49  
does it feel reasonable. That's what you do. And from here, you want to go to here. So the first step would be called lexing. And the second phase is like parsing proper.

1:24:03  
And the point here is not to worry about like, is it whitespace, maybe three white spaces.

1:24:09  
Maybe there is no whitespace at all. I mean, he right here, it's okay not to write the whitespace. But here Surely, the story here, it's not okay to not write the whitespace you need the whitespace. But here it's not needed. Because

1:24:23  
a name is a sequence of characters and maybe also numbers. But as soon as you see the equal sign,

1:24:29  
this works just as well as a separator, you know that the next thing is already a thing on its own

1:24:35  
usual stuff. And maybe even new line is allowed, maybe multiple are allowed. So we shouldn't worry about this. I just want to see a list of sort of

1:24:46  
atomic building blocks for for for the process of

1:24:53  
actually parsing is this good. So all I want to do in the remaining 30 minutes is to get

1:25:00  
I'm here

1:25:01  
to hear.

1:25:04  
And believe me, this is not so hard.

1:25:08  
So first of all, I should clarify myself, what is it that I'm after? Well, I'm after a list of tokens, a list of tokens is literally a list of tokens. What is a token? These kinds of things are tokens.

1:25:21  
Yeah, so I bet they're first ticks what I want to collect, I want to collect tokens like this. You go, yes, good. Thank you.

1:25:30  
This is my data type of tokens.

1:25:37  
You're you've already seen almost everything.

1:25:40  
You haven't seen parentheses, but left and right parentheses can come up minus can come up times can come up.

1:25:47  
error is a good special token to have for something incomprehensible that may occur in my expression. So if such a thing occurs, of course, it means that the lexing already failed, but then I can also indicate why.

1:26:05  
Okay.

1:26:08  
I should also say, the integers I collect are not the real integers, they are unsigned integers. So we'll separately deal with negation.

1:26:20  
So you have to find out minuses, they will come up like this, actually, and it's later our job to to distinguish the binary minus which is subtraction from the unary minus which is

1:26:32  
negation of a number.

1:26:37  
In F sharp, there is a type car, chair, character, whatever you call it, char

1:26:45  
four characters. Character values are indicated in single quotes. As opposed to strings, which are in double quotes.

1:26:53  
We can write some easy nonsense to recognise digits, lowercase letters, uppercase letters, or something that is a letter, which is then lowercase or uppercase. And that's done simply with comparison, because

1:27:09  
comparison for less than or less than equal is available for characters. And then you can easily define what the digit is by just using an interval. And similarly for lower and uppercase letters. Finally, you can easily convert the character to an integer if it is a digit. So if a character is in is in the right range, then you'll find it out what it is as an integer. And for that, I don't even need to know

1:27:40  
what the right offset is, because I can ask F sharp to convert characters zero to an integer

1:27:52  
then

1:27:54  
it's clear that if I have some other character, say for example, four seven, then I can find its numerical value simply by

1:28:06  
subtracting the position of seven in the alphabet from the position of zero in the alphabet that gives me the actual value of a number seven.

1:28:15  
Um, I can do another thing, this is useful. So

1:28:22  
one of the things we will find in in these concrete so in strings, we will look for three concrete things, either special characters, like equals, or parentheses, or plus, or we look for numerals or we look for names. Words, there are two kinds of words that are keywords, let them then

1:28:42  
everything else that looks like a word qualifies as a variable name. So we use these as names.

1:28:49  
So whenever I have a string, that is a legal world word, I can convert it to a token like this. So the string length goes to the token length, the string int goes to the

1:29:02  
token in

1:29:04  
and whatever other string, maybe even illegal ones that contain spaces or numbers or special characters that should not be allowed. Or maybe start with a number of digits etc. I can I can just say they are named string because the convention for calling this function is I only call it with with strings that qualify as words.

1:29:51  
So these are not good words, but we will never call Berta tokens with this one.

1:29:57  
So we're all set up. All I need to do is to

1:30:00  
Right Alexa for you.

1:30:03  
What should the idea be? Let me explain it on this string. The idea should simply be that you walk down the string, which you have actually converted to a list of characters for your convenience that you can easily do.

1:30:20  
And then you look at every single character, you're either kind of in a default mode, when you look for the next thing to begin, like I'm at the whitespace, then I know that I'm in the middle of two tokens, I can just go on maybe there is another whitespace or so

1:30:35  
when I see a letter, this is a clear sign that I'm at the beginning of a word, hopefully.

1:30:43  
Then I go into the mode of recognising a word or collecting a word.

1:30:48  
Yeah. And then later, I'll determine if my word was a was a letter in keyword, or if it was just some name.

1:30:58  
So what was it I've got a default mode are working working down in this in the in this list of characters, which makes a string, I can be in the mode of collecting an a word, but I can also be in the mode of collecting an integer, an unsigned integer.

1:31:15  
Any moment,

1:31:17  
I see a digit after a separator, or after a special symbol, but not in the middle of a name. I start looking for a numeral

1:31:29  
right? And I just keep looking for digits until I find the next special symbol or separator. So so this is 17. Because

1:31:39  
a whitespace follows, right?

1:31:42  
If this was 17 plus three, then this would be 17. Because plus follows and I don't even need a whitespace here.

1:31:49  
But if I have like set one, or is it Tuesday, then I know that two is a name because it starts with that these two doesn't know start the numeral it's just part of, of a name.

1:32:01  
So I'll detect this when I look forwards.

1:32:04  
Does it make sense? I mean, what else could you do even

1:32:09  
if you think about it.

1:32:15  
So the important thing to realise is lexing, also called tokenizing is is really about always a little state machine, where you're sort of where the states are the sort of modes in which you are.

1:32:29  
And this state machine can actually collect some data as it as it walks down the string or list of characters. Like when I detect this is number one, I have to remember it. Because when I now see seven, I say, Aha, this one maybe needs to be multiplied by 10. So it becomes 10. And then I need to add seven to get 17. And then I've converted the sequence of two characters, one and seven to the number 70.

1:32:58  
I've told you everything we need.

1:33:01  
Did this happen?

1:33:08  
How can I control this? Okay, I define three functions by simultaneous recursion. So they implement this little state machine traversing the given string.

1:33:18  
And the idea is wherever I am in the top level string that I'm processing, the machine is in one of three modes or states, there is the default mode, which is corresponds to the function tokenize, which takes a list of characters into a list of tokens.

1:33:34  
I can be in the middle of lexing, an unsigned integer. So this will be done with the function tokenizing which actually collects digits as it goes and accumulates the result in some integer.

1:33:49  
And I can also be in the middle of lexical word, which means I remember the, the symbols I've seen, the sequence of symbols has to start with the character. And the idea is I want to, I want to, you know, I want to collect the word.

1:34:06  
And then what happens is, you just inspect characters one by one from the string or list of characters, and you switch mode based on what you see. Or maybe you keep in the same mode, keep going in the same mode and then you go to the next car, nothing else.

1:34:22  
So here are the three functions they actually were fit fully on this part of the screen. They are defined all simultaneously you can see his left rec, and and so a simultaneous recursive definition of three functions they call each other.

1:34:40  
So this is the main one. It calls some helpers, but the helpers also go go back to the main one.

1:34:49  
Oh, okay.

1:34:51  
Am I really

1:34:54  
this this evil correct?

1:35:00  
This is even not true. I could not define these ones first.

1:35:04  
And then this one, because tokenized calls these two, but these two don't call tokenize.

1:35:10  
It's really like, Oh, no, no, it's not right. Of course. No, I was right. They do call tokenize. Yeah, when you finish tokenizing, an integer tokenizing the word of course you call tokenize. Again,

1:35:22  
how do you tokenize you're given a list of characters, you want to produce a list of tokens. So here are the possible things that can happen. You have no characters at all, great, no tokens to produce.

1:35:36  
You see, plus you say, Okay, I found a plus and you just tokenize the rest, the same for minus times equals

1:35:46  
you'll find a whitespace.

1:35:50  
You just ignore it. So keep tokenizing

1:35:56  
you find the tap symbol, you're, you're good, you just keep tokenizing you'll find a new line, you keep tokenizing. The rest?

1:36:08  
Well, these things should play some role.

1:36:12  
But not here, they actually play some role when you when you want to finish tokenizing an integer or word, but you'll see we'll get there. When you see a left parenthesis, you say okay, I found the left parentheses and you tokenize the rest. When you see a right parenthesis similar

1:36:33  
when you Okay, so here's something you haven't seen before. So we this is a combination of pattern matching with a when clause. So when there's like, if

1:36:45  
a bit like if the nails tibbett, except that there is no else, and you use it together with a pattern, the idea is

1:36:52  
this clause is applied or this branch is applied when the pattern matches and the condition is true.

1:37:00  
And if the pattern matches, and the condition isn't true, you just go to the next line to the next case, if the pattern doesn't match, then of course, you also go to the next line. So this is a gives you some economy in writing case distinctions. So if your first character is a digit, then we actually go to the,

1:37:19  
to the tokenized. Int mode.

1:37:22  
And tokenizing actually works with an accumulator. So it gets in both a list of characters, but also an integer. And here we call this tokenizing with the rest of the characters that are still to be read. But also with a little seed value. This is the initial accumulator, which is just the integer value of this digit, which is a character. So say, if it's a character seven, then digit to int, we'll take it to the number the integer seven.

1:37:55  
Does it make sense?

1:37:57  
Then, what is another possibility, another possibilities, I'm hitting the beginning of the word over word, a word here we agree has to begin with a lowercase letter.

1:38:12  
And if I see such a thing, then I just tokenize the rest of the given string, the rest of the given list of characters.

1:38:20  
But I also remember the characters that I've seen, and I've already converted this character to a string, as you can see.

1:38:28  
So C is a character string C is a string made of that character.

1:38:33  
In all other cases, which is like I'm in the default mode, but all of a sudden, I see a special symbol that I don't recognise, or maybe I see a capital letter, then I see.

1:38:44  
I saw something that was not tokenized double, but I could go on what I could stop here, doesn't really matter. What we wanted, depends on what we want to do. Here we just carry on, so we tolerate some noise in the

1:38:58  
in the syntax.

1:39:01  
Now, tokenize input and tokenized world are similar to each others. Let's look at tokenizing.

1:39:07  
So what's the situation I've got some characters still to process, but I've already collected some integer in the accumulator.

1:39:17  
I look at the next character. So I match the list of characters with with the head and the tail.

1:39:24  
If the head is still a digit, then I have to continue tokenizing an integer.

1:39:35  
But

1:39:39  
what is my accumulator? Well, I can convert the part of the integer I've already seen to the integer as I go. So what is suffices is to multiply the current accumulator with 10

1:39:55  
and add whatever the newest digit is that I saw

1:40:00  
And then carry on with that accumulator. So for example, if you see the string 124, maybe you've already processed one, then the moment that you go and look at two, you say, Aha, I've seen one times 10 plus two, which is 12. Then 12 is your accumulator, you see four, I say, Oh, okay. 12 times 10 plus four is 124. And then you ask, is the next thing, perhaps another is sorry, digit, or maybe it's now like a special symbol also.

1:40:34  
So what are the other cases that can happen? The other cases is, you find something that is not a digit. So whether the next thing is now a character, or maybe a space, or tab, or new line, or an illegal character, even you say, I found a token, which is an integer, and its value is whatever I accumulated, and then I go back to my default mode. So I call the rest of the list of characters. Sorry, I call tokenized. With the rest of the list of characters, which is this Yes, here? No, no, no. Which is not Yes. Which is this Yes, is the whole of CES, including the first character.

1:41:16  
Yeah. To see, this CES here with which I go further is the tail. But here I've used the underscore

1:41:25  
pattern. So the CES, I'm referring to is the one from the match.

1:41:34  
Cause construct, so I'm tokenizing, all of the rest, and we the word is exactly the same. So you've already accumulated a string, when you see another character, you check whether it's a letter or a digit, if it is, that's okay. that qualifies to be part of your string. So you carry on with the rest of the list of characters, and you add the character to the string you already have. So plus is concatenation of strings. But they first have to convert my character to a string as well, I can't come catenate the string and the character directly.

1:42:12  
When I find the thing that doesn't fit anymore, which is not the letter, not the GG,

1:42:17  
I just

1:42:19  
basically apply my helper back, which looks at the word I collected that depending on whether it was led, or in or something else, it says this was led or in or if it was just the name, ack, and then I tokenize the rest.

1:42:34  
That's all you need. You also need a little helper, that course that convert strings to chars, that's not very important. And then finally, on the top level, lakhs of a string is just tokenize. The list of characters given by the string,

1:42:50  
no, I better load what I want to load lexer

1:43:01  
that's my thing. And that, then we could take

1:43:06  
my

1:43:08  
expression, which was here.

1:43:12  
And I could like see it.

1:43:20  
I hope it's good.

1:43:22  
Oh, opened, of course, open what open lesson.

1:43:31  
And this is what comes back.

1:43:34  
And see this is pretty insensitive to various nonsense you can do so I can, for example, do something like this.

1:43:41  
And I still get the same thing.

1:43:44  
But if I was silly enough to do this, so I remove the space between left and zette

1:43:52  
then the guy doesn't recognise lead anymore thinks I've got the word let's

1:43:58  
sorry, a name let's a variable name. Let's followed by equal followed by blah, blah, blah. Of course, if you try them further to parse it, you will fail.

1:44:07  
And it's also okay to

1:44:11  
to insert things that shouldn't really belong anywhere.

1:44:16  
Right, like I think I can put the capital letter here at this place.

1:44:22  
And I still get something.

1:44:24  
So basically, this capital letter is ignored, but the rest is still tokenized.

1:44:31  
correctly.

1:44:36  
Okay, let me very quickly just illustrate one of these additional functions. Like suppose I was in the middle of or something like I'm perhaps in the middle of tokenizing.

1:44:50  
So

1:44:53  
I could be at this stage when I do

1:44:57  
Lex

1:45:02  
That thing here. So I've already went through the I've already gone through this part sorry.

1:45:09  
And then maybe I

1:45:15  
actually have to call tokenizing.

1:45:18  
Those so I can't quite work with this

1:45:21  
string here, I want to work with a corresponding list, which is string to chars.

1:45:29  
If I call tokenize, in then with a suitable accumulator, so maybe I've already figured out that I've seen the number one,

1:45:37  
based on my seeing the digit one, so I've accumulated number one, then what happens?

1:45:44  
Let's see if the right thing happens.

1:45:49  
I think it is.

1:45:51  
So you see. So this illustrates what happens if I'm in the middle of something I had already accumulated number one,

1:45:58  
but when the when the rest of the string is this, then I and then since the immediately next thing is seven, I sort of read the one and the seven is one thing.

1:46:09  
I accumulate the value 17 since the next thing is face, I finish here and they say, okay, collected 17, and the rest is as before in nine plus nine.

1:46:22  
And that is it.

1:46:27  
Does this make sense? Do you think you know would be able to write your own lexer?

1:46:36  
resume been? Maybe not write it?

1:46:41  
Completely, but that would be the ideas, right? Yes, because it's a similar mechanism. Of course, you may have multiple things, more and more modes in the machine, like maybe you have a default mode, you can be in the middle of recognising the word, you can be in the middle of recognising the name, maybe there are further things that you can be in the middle long recognising. Like maybe you have complicated operator symbols, maybe allow operators symbols, like plus plus, for two pluses like F sharp, when you'd like to say okay, I've seen one plus, but maybe I'll see another plus. So it's not a single plus, but plus plus. So then you just introduce another mode for collecting this kind of information. For example,

1:47:24  
recognise complicated operators symbols that aren't simply one single character, the idea will always be the same.

1:47:33  
Go down symbol by symbol. In more complicated cases, maybe you need to do a bit of look ahead here, this doesn't happen. So it's a very straightforward thing

1:47:43  
I once liked slightly over time, but I covered

1:47:47  
what I wanted. lexing is really easy. You will see when I have to compare it to parsing next time, but parsing is more interesting. In some sense from here to here.

1:48:00  
It's not so far.

1:48:03  
Both are kind of flat things you must agree right? This is a list of characters, this is a list of something else. But here all of a sudden, this becomes a two dimensional things. This is a tree

1:48:13  
that is more complicated

1:48:17  
than the whole thing is a topic of a compiler construction course, but I just want to sort of naively show you some principles rather than go deep into the theory for it. So just let you get a feel for what the challenge is.

1:48:31  
Isn't this similar to DFS and NFS like the concept of this st again, is it the concept of this lexing and parsing this is

1:48:45  
this is similar as in, in discrete mathematics, the dfas and nfas. But you're

1:48:54  
What?

1:48:55  
That's perfect. So.

1:48:57  
So lexing, you can always do with,

1:49:02  
with an automaton. So here, it is a DFA strictly, if you look at what I've done,

1:49:08  
except that

1:49:11  
Well, maybe not completely in the sense that if there weren't these accumulators, it would exactly be a DFA. Because that is exactly three states right default, in the middle of tokenizing, an integer in the middle of tokenizing word. But now here, actually, in the way that I've implemented it is not even the F in the DFA. It's not the finite state machine, because I can actually collect any integer. And here I have arbitrary sizing integers, if you notice properly, right?

1:49:40  
Because I'm not putting any limit on the length of the integer. So it could be like any number of digits.

1:49:48  
And honestly, if you calculate it, this the number of states of this machine you should say it is, you know, from here to get exactly one state default state. Here you get one state for every possibility.

1:50:00  
And there are infinitely many, and you get one state for every possible stream. But it is like, you know, the most part is a finite automaton. And then there is the kind of data part of the state where we are infinite.

1:50:15  
But it's exactly that concept. Yes, you're absolutely right.

1:50:19  
Okay, yeah. And of course, then there is a correspondence, I don't know, if you see in discrete math or not to regular expressions, you can basically characterise,

1:50:29  
you know, valid concrete syntax in terms of a regular expression. And one way to systematically construct the lexer is take this regular expression that describes the concrete syntax, and just turn it into this machine to the DFA.

1:50:47  
Maybe I should say there is a bit more because Okay, there is one more aspect normally in a DFA, you just want to accept or reject the string?

1:50:55  
Yes. Do you want to say yes or no? Is this good? A good string or not? Here, apart from you know, saying whether it's good, we want to say yes, it's good, but it translates to this. So these kind of things in this machine theory, are often called transducers. So they get some input. So the read characters one by one, but every now and then they spit out something. So here are these tokens? I mean, after every after, after each some number of characters, we've learned another token.

1:51:24  
But it's precisely that, it's a very good question. Keep asking questions.

1:51:29  
In the tokenize words, I think it is

1:51:36  
see where you go, when is letter or is digit. And then after that, you do the accumulator plus string C, is the reason why you convert to a string, is that just in case it's a digit? Otherwise, you wouldn't have to come? No, no, no. The reason is that the characters and strings are not the same thing. So character is not the same as a single character string.

1:52:06  
Okay, so a single character is something like this.

1:52:12  
But if I apply a string to it,

1:52:15  
then this is the string.

1:52:18  
Okay. Okay, so you need to do that, if you want to use plus, of course, you can write your own function that takes a string and the character and makes a new string.

1:52:27  
But then just use plus lately, I need to do that.

1:52:32  
Now, okay.

1:52:35  
So string is a kind of a general helper, that is able to convert many things to strings, when not every time, but almost every.

1:52:45  
Like, it converts characters to strings, integers to strings, floats to strings, if we apply it to a string, with doesn't do anything with it, it just returns the same string.

1:52:58  
And of course, this apostrophe here is a type variable. And this is a character, they look very similar, but they have nothing to do with each other.

1:53:10  
And also, this string is a function, I should say, where does this string here is of type.

1:53:17  
Purchasing.

1:53:19  
That's kind of a general principle. So also, you have a thing float,

1:53:25  
that will take many types to a float, like you can convert an integer to a float like this doesn't work for every type, but for many types.

1:53:38  
Okay,

1:53:39  
so maybe, perhaps we should stop here. What do you think?

1:53:44  
This went much over time?

1:53:47  
Now with the questions.

1:53:50  
So let me stop sharing.

1:53:54  
Yes, I think, at least if I'm speaking for myself, I, I grasp the contents pretty well. But the code itself, I will need some time to let that sink in. Yeah. But also, I mean, the course is not so much that you need to learn this code. But this is more like, you know, I want to show you the concept, the idea, you don't really need to recreate any of this or the exam, but that's not the idea.

1:54:19  
But okay, that's the thought but the best thing to do in such a way that we don't sort of only explain the theory of it, but every little thing that you do, you can actually you're not, you know, you can take a piece of code and then then you can play with it. I know I'm not sharing any more but

1:54:34  
but you know,

1:54:36  
I'll tell you what the tokenizer is and then you can just apply it in the middle of a string and you can see what happens to get you know, to make your hands dirty that is

1:54:46  
that is somehow the idea. So

1:54:50  
you may hate it. You may like it, but it's a compulsory course you have to go through it.

1:54:58  
I think it's just I think

1:55:00  
It just helps a lot. If we just try it out ourselves, get the solutions and try to, you know, mess it up a bit see what affected? Yes, I think it is helpful if it's just try the given code on on like random inputs, try to see how it works. I showed you some example inputs, but you could try to put in your own and see what happens. And this will give you some feel of what it's like. Yeah, getting the getting the code, or being able to get the code and trying it ourselves has been pretty helpful, I'd say.

1:55:39  
Yes, you're starting is complaining that it's difficult to grasp the theory using F sharp as a tool to demonstrate I do agree.

1:55:47  
But this is kind of a necessary evil. Because if I were to implement the same theory, for you, in C, or Python,

1:55:58  
we wouldn't get anywhere,

1:56:01  
anytime soon, because you either need library functions for which you don't know what they really do.

1:56:08  
Or you need to do a whole lot of work to even get anywhere close to getting off the ground. Because things like pattern matching or high orderliness or, you know, these kind of obstructions that FP gives you, they give you this ability that you can write down these things in 20 lines rather than hundreds of lines of code. So it just is like this. I know it's the hard part about this course. So I've got my full sympathy but

1:56:36  
yeah, it just is like this.

1:56:39  
I mean, I wish I had more time to do all of this, but I don't. So

1:56:45  
parts of it are going to be a bit rushed. But

1:56:49  
I promise I will actually go slower as we get to more complicated things because I know these are more difficult.

1:56:58  
Okay, then

1:57:02  
perhaps.

1:57:05  
Good. Okay. I will stop here. See you

1:57:11  
again soon. Yeah, thank you as well.

1:57:17  
Thanks. Bye. Thank you.

Transcribed by https://otter.ai
Unknown Speaker  0:27  
Hello, let me start the next lecture. Last time we talked about lexing. So getting from a string to a sequence of tokens. Today, I'll talk about parsing, which is about taking a sequence of tokens and extract an abstract syntax tree out of it. And we do it for the same language of expressions that we've now been discussing

Unknown Speaker  0:59  
for a while.

Unknown Speaker  1:02  
So let me share my screen and let's get going. So, I'll do like this. Or the same way as we did last time. So I don't introduce, I won't introduce any deep theory of parsing, like I didn't also do for lexing. And I just show you one concrete example. And based on this, we'll try to develop a methodology and also notice what the issues are when you try to build a parser. So let's remember where we were. So this is our little expression language that we liked with variable uses lead expressions where we define a variable for local use, and then you have a body expression, numerals, and then operator expressions, just as before. Last time, I showed you how to take a string, maybe something of the form, let that equal 17, insert plus x and extract from this sequence of tokens. So you look at this flat string, and you try to see you try to break down the string into sort of smaller sub strings and convert these things to for information about information that is relevant for recognising what expression disease. So here we want to, for example, understand that there are two keywords involved. There's an operator symbols involved, there is a numeral involved, which is 17. I don't want to see one and seven separately, but but 17. And then there are a few names that, that and x. So names are just strings here that start with a small letter. But two strings that start with a small letter aren't our names, they are keywords, namely less than 10. And there are no other keywords in this little language. So suppose I've already transformed this thing into a sequence of tokens, how can I further extract the correct expression tree here the abstract syntax tree, which should be something of the form really as lead here, the first argument should be seven, the second should be non 17. And then the last one should be plus bar.

Unknown Speaker  4:01  
Bar.

Unknown Speaker  4:06  
How we do how do we go? How do we get here? Yeah, we go through this sequence of tokens that we already saw. So from the sequence I can get, I can get from the string I get a sequence of tokens, which in this case will be something like let first

Unknown Speaker  4:27  
and then we say the next thing we see is names that are the next thing we see is an equal sign. And then we see an integer which happens to be 17. Then we see a keyword and then another keyword in then we see a name. Then we see a plus sign. Then we see name.

Unknown Speaker  4:57  
Last time we wrote a bit of software To get from the concrete syntax as a string to this a bit more analysed sequence of tokens. Now I want to get here

Unknown Speaker  5:15  
how to do this? Well, we first have to understand that there is something like grammar behind our strings. So we can talk about the syntax for concrete expressions. So which strings are valid. This is fixed by the following grammar, this is not F sharp, this is sort of an informal explanation of what is going on. We've got exactly one sort of interesting syntactic category in our language, which are expressions. And expressions are really of five possible forms. Here, an expression is a variable. Length expression is something that in a string looks like this sort of a sequence less than some separators. And then this variable name, maybe some separators, optionally equals again, some separators, or perhaps not. Another expression separators in separators expression, is a numeral. And to make our task simpler to start with, let us make an assumption that, in order for parsing to be simpler, let's agree that every operator expression has to be enclosed. In parentheses.

Unknown Speaker  7:03  
This is not fully satisfactory, really, we want to use parentheses the way we want to use them. But it's kind of okay on this level. But you have to then be precise. And understand what what is meant so. So when I say that parentheses can be only around operator expressions, this is what really what I mean, in particular, for example, it means that I cannot put parentheses around the whole thing where I should really put them around each time I use plus, so. So that I'm sorry. So this one is a correct version of an expression according to this grammar. So why am I putting in these parentheses here? We'll see in a short, while, but there is a reason this makes writing a parser simpler. But then, of course, we want to actually have more freedom, and we'll get that as well. And then we see we need a slightly different design. Okay, so this is what we have, I start with a list of tokens according to this grammar. I want to produce an abstract syntax tree. And I'm guided by the knowledge that the tokens must have come from this concrete expression syntax. Yeah, these are the possible sequences of tokens that I'm happy with. So, the type of parser I'll explain here is actually called a recursive descent parser. The point is, in this grammar, you start from the start symbol. So I say, Well, whatever I'm seeing as a string has to be an expression, let's see if I can justify it. And then you go down in the grammar. At the same time you pour, you consume the list of tokens. And, and see if they're, you know, if the next things that I see in my list of tokens sort of agree with what is what is possible, what is allowed here, in particular, what I see should determine what I will say My my, my, my past three E's and you can already see that you know, a variable expression is specific in that it starts with a name. A lead expression is specific in that starts with the keyword lead. And numeral expression is specific in that it actually starts with in some integer. These ones are all similar in that they start With the same thing of parentheses, so I've really got four cases here, a name, the keyword left, an integer, or a left parenthesis indicate what type of an expression I have. But then I have to read a bit further to determine what kind of operator or two to see what kind of operators symbol pops up, for which you need a bit of luck. That is, that is somehow the idea. So let's see this. So the parser of expressions takes a list of tokens from the lexer. And then it tries to identify a prefix of this list. So some initial part of this list of tokens as an expression, while traversing and sort of consuming it, it may happen. And it often often does that, you don't need all of the list of tokens, there will be an unconsumed part. That's very important for the organisation of the parser. So then you return both fixed expression, the abstract syntax tree that you determined, but also the left over have the list of tokens. The whole programme is really not so big at all. It almost fits on one slide. And the important are the simpler parts are here. And then when it comes to the operators, we have to do a bit more work on this. So what is the functionality, at least two tokens comes in. And what comes out from the function is a pair of two things, the abstract syntax tree recognised or returned, and the leftover tokens.

Unknown Speaker  11:58  
Let's see what is a reasonable thing to do. So given a list of tokens, I've got two sort of top level options, either the list of tokens is completely empty, in which case, we can just say we didn't find an expression. That's an erroneous case. If my first token, in a list of tokens is a name, and then there are more tokens. Then I've seen a variable. So I say, var x, and I just returned the rest of the token. So I returned this pair, the first expression, the abstract syntax tree I extracted. The second is whatever I didn't consume. Similar easy case, is the one where the first thing you see is a numeral. So the token there is of the form in Thai, and then there are more tokens, then we say, we've seen the numeral and then the rest of tokens are on consumed. So what's the role of these unconsumed talkers to come? The next case which concerns then these lines is the case of us finding or almost finding, but then failing to find a lead expression. So, a good lead expression

Unknown Speaker  13:32  
is of the following four, the first token is lead, then there is some name, then there is equal sign. And then there is more things. So the more things are an expression, the keyword in and the body, but first we need to see these bits. So these are a good sign of us finding a lead expression. What do I need to do in this situation? Well, I cannot directly already return an abstract syntax tree here because I need also three the bit of the rest of the tokens. So let's try to parse the rest of the tokens, the rest of the tokens must surely contain the right hand side of the definition and then there must be more tokens left. So I call parse, this is my main function on the given list of tokens here and what should come back is an expression and maybe some more focus then or some more tokens will come but if if this list is not sort of satisfactory, then we will face problems. So what can happen if the rest then after having found an expression is an keyword in then we continue to be in good shape that I mean, we were still sort of on the path to success, because in is the next thing we need to see. And then after in some leftover tokens. What do we do with the leftover tokens from the leftover tokens, we need to extract a body their body of the expression, its abstract syntax. So why do I again parse the rest, which now is this Ts from here, when there is many Ts is around this Ts is this is this, this is this. This is fish. So, I get back a body, and then something may still be left. And then what we say is okay, we found this let expression collected from their name, the right hand side I found and the body I found, so this is what I returned. But I also return sort of the final leftover. If I found the right hand side, but didn't find the end keyword, this means that the lead expression sort of was well formed up until this point, but then after that something went wrong, and it didn't follow. So that's a bad situation, then we say, we've got a lead without the name. There are some other bad situations possible,

Unknown Speaker  16:33  
which need more space here.

Unknown Speaker  16:37  
Namely, it's possible that I don't even find an equal sign after I seen a name. So then it's a lead without an equal sign. So it, it is good until this point. But it can be even worse, it can be that I only find the lead keyword, but then what follows is not the name. So then it says the left hand side of the definition in lead is not the variable name. So do you see this, so we just go further down in the given token list, if everything forms with what we expect, then we just go further down as we need like, if we've if you've got this far, this already looks like a very good lead expression, then the only thing that I need to do is to extract the body from the rest of the list of the tokens. But I may fail earlier, because something may be wrong in the input stream, like I perhaps get to this point, but then I don't see an equal sign or maybe I get to this point, I see an equal sign, but then the rest of the list of the token is is empty, then I get this missing expression error. And then finally, there is the case of a left parenthesis, the left parentheses is a symptom of that something like this will now be there. So what should we do then now. So in the last case, it was sort of, we had one possible sequence of things that we expect let a name an equal sign and expression in and body here there is a bit more of very activity in that the operator may be different. But I mean, this thing put apart the rest of the shape of an operator expression is deterministic, there has to be a left parenthesis token and expression. And one of the tokens plus minus times and then another expression and finally a right parenthesis, we repeat exactly the same ideology there is, there is not even a lot of difference in the rest of world we need to stop here. So if the if the first token in my list of tokens is left parenthesis, this is this situation, then we go and parse the remaining tokens. From there, we get an expression and more tokens. So this part is done. Then I have to ask what form is there is the rest of tokens. So if it's a list that starts with plus or minus or times, then I'm in good shape. If it's now not an operator symbol next, then an operator symbol is missing in a list. Each of these cases are exactly similar. So let's just look at one if I see a plus symbol, and more tokens, then I should parse those further tokens, I should get another expression. And then well, the remainder of the remainder, that one must start with the parentheses. And then that may is there are more things left and what I return is a plus expression and whatever was finally left, if the expression is not sorry, if the operator expression parses well this far, but we don't find the right parentheses, then we say with a, but of course, failure can come earlier. Yeah, something can go wrong in each of these parts expert,

Unknown Speaker  20:45  
as well. And also this parse expert can go wrong. Now, this where all the code cases, so a valid expression starts with a name, or lead, or an integer or a left parenthesis. But of course, in a random sequence of tokens, I may start with a bad thing. Right away, like if the whole list of tokens starts within, then it's like an end without the lead. If it starts with equal, it's like an equal sign without let, if it's plus or minus, or times, then it's like an operation symbol without the left argument. If I start with a right parenthesis, then it's like a right parenthesis without the left parentheses. And if it's any of the illegal symbols, then of course, I should also be unhappy. What is a tableau parser is the following thing. So it's similar to this one. So I'm trying to parse an expression. The only difference is I don't tolerate it if at the end, there aren't consumed tokens. So it's a function that takes in a list of tokens. I expect back an expression, this is what the functionality I want. how it's done is you parse the given list of tokens, what come back is an expression and the rest of tokens. If the rest of tokens is empty, then we say, Great, we return this expression. And that's the right thing to do. Otherwise, we we, we raise an exception, we say there were unconsumed tokens, sort of, for the top level call of parse expert. This is not satisfactory. And we signal about it. And finally, we can put our lexer and parser together by just taking a string lexing deep, getting a sequence of tokens and then parsing. Let's see this in action. So I'm loading both the lexer and parser. Now, I also need to open the lexer the names available to me

Unknown Speaker  22:53  
parser.

Unknown Speaker  22:56  
And we can play a bit.

Unknown Speaker  23:01  
What

Unknown Speaker  23:04  
can we possibly parse? So we've got this function parse expert. It's called one because we will later improving it. What's the simplest thing to type to parse would be perhaps the empty sequence of tokens to start with,

Unknown Speaker  23:24  
let's start slow. Of course, the complaint is that the expression is missing.

Unknown Speaker  23:31  
If I have some expression that starts out, not in the best way, so maybe like within with the right parentheses. After we'd say maybe you have a name, then I get to know that there is a right parenthesis without the left parentheses. So the only good ways to start, as I said, an expression were to maybe start with something reasonable, like an integer like 17. Let's try that. So pars expert one will tell me this is it found the numeral and then there is some remainder unconsumed tokens. Of course, I can have more of those I can have yet what at the end, maybe something like this. And then all of this is unconsumed. But the start was very good. The parse expert one is happy but my top level function is not happy. The top level function was called parsable. This one says there are unconsumed tokens on the top level. Let's do some Anything else meaningful? Like, if I do a simple simple addition, if I do alpar

Unknown Speaker  25:15  
name,

Unknown Speaker  25:19  
last name,

Unknown Speaker  25:25  
bar bar.

Unknown Speaker  25:29  
This should be just set plus x with enclosing parentheses as we've

Unknown Speaker  25:35  
agreed,

Unknown Speaker  25:42  
then we get exactly the right thing. So this is how it works. But you have to understand that sometimes you have to work with leftover, right? So how does how does parse one even work? Well parse one works because parse expert one worked. So this is what part one called it actually called parse expert, one that looks at exactly the same list of tokens. But it's, it's sort of its domain is the driving parser function here. So this is the one that tells us this one is the expression I find. But there is also some, some, some leftover tokens. left over tokens are important for the case that you're in the middle of a process, like when you call parts expert, one on this guy. So which part in the programme handles it? I called power expert with a list of tokens. And I tried to match Ts with all of those attacks, I go here, L bar. And some somebody stole tokens. So suppose I've found l par, I call pars expert with the rest of tokens. So let's mimic the game here. Suppose I already found the L par pas expert is called with the rest of the tokens. What happens now? Then I'm sort of in the middle of the process. The parser finds my variable name, and then there are some remaining tokens. So yes, II one here that comes back. Is this var? Is it the new tiers? Are these guys? So what am I supposed to do in this case, I say, Okay, let's look at cases. One of the cases is this starts with plus great. In this situation, I have to look at what is after plus this thing and apply the parser to it again.

Unknown Speaker  28:05  
So let's see what the parser does here. Now, at this point, it's not correct to call parser one on this thing, because this one will complain that there will be some leftover, but it's perfectly good. And this is the whole idea of this parser. to to to just start at the left end of this list of tokens, try to extract an expression that is perfectly okay at this stage, that there is some leftover. In fact, we want some leftover to be there, we expect what we expect that we do get back an expression. But we do this, we expect that we do get back an expression, very some left over a list of tokens. And this list of tokens is not allowed to be an arbitrary thing, it better actually be the right parentheses. And then we can see, plus comes back and whatever is left over now is left over on the top level. Let's see if this actually happens. Yes, it does. We extract var x and then the right parenthesis is there. And at this stage, we actually collect plus e one e two, which is what we already saw here. So the total result is is this. So let's repeat the strategy. We have to understand that we have to write it down. What my concrete expression syntax is. This is written down as a little grammar. These things are called context free grammars. So for every syntactic interesting syntactic category, these things are called non terminals in context free grammars, but I don't really want to introduce the full terminology here. You say what are the valid sort of string forms? What are the valid lists of tokens, these kind of things. interferes with with the syntactic categories. So here for example expressions again. And then you just given given a candidate expression, the list of tokens, you try to match it against one of these, and then you go deeper and you see, okay, yeah, but you know, these things are these also properly and expressions. And your work from the left to the right in your sequence of tokens. feels almost perfect, right? And if it wasn't so hard. The trick is to reverse the list of tokens. collect things from there. Always work with, you know, the current remainder, the rest of tokens. And you're fine. But are you? assumptions not because we really would want to have this grammar right, this should be a sensible way of organising expressions. I like to say the expressions are the variable, Aled expression, the numeral than any of these plus minus times. And then I may want to put parentheses around my expressions in arbitrary places. So maybe also around the variable, maybe around the top level expression, maybe parentheses around some plus expressions, but not around some times ones, because the times times has a high precedence. That's what would be so nice. But the trouble is a grammar rule like the one thing and expression is allowed to be another expression plus an expression, you're the problem. Why? Well, our grammar how it would work is given a list of tokens from where it tries to find an expression, it tries to see whether it's this form of an expression, this form an expression, this form of an expression. And for that there are clear, so the signs, this one has to be a name, here, you have to see a keyword, the keyword lead first, here, you have to say, see an integer. But in this case, you just need to see an expression.

Unknown Speaker  32:43  
And then you don't know. Because you will have to, you basically have reduced your big problem of finding an expression in your list of tokens into a problem just as big of finding an expression in your list of tokens.

Unknown Speaker  33:06  
And then

Unknown Speaker  33:08  
if this is the case, your parser or expressions will try to recurse infinitely. So you can write a parser following the ideology that I showed you here, the well, but it doesn't actually work. So unless your expression is is is a name or less expression or a numeral if it's not one of these three forms the force case will be trying at and this is a problem immediately. Because you will try to do the following thing you will try to understand he as morally you know a plus operator expression, but then you will also try to understand this one as a plus operator expression. And then also this one as a plus operator expression in the case

Unknown Speaker  34:12  
when when the first things don't apply or maybe they do apply right. So suppose your actual expression is something like x plus y. If this is the case, then surely we can see we are in the first case. But that's not the satisfactory solution because then parsing will tell us this is just leftovers.

Unknown Speaker  34:48  
Okay,

Unknown Speaker  34:49  
but then what can you do? Then your possibilities to move this case, past all the other cases to the front. Like here who Your grandma. And now you directly go into an infinite recursion immediately. So you can't really know you cannot put these cases first. But you can't put these cases first either unless you introduce some extra cleverness. So what is extra cleverness? Normally, when you have a grammar, or say when you have a language like ours, and we want to use parentheses freely in the concrete syntax, we have to organise the grammar differently. We have to stratify the bit,

Unknown Speaker  35:45  
so we have to introduce extra syntactic categories. And here's the trick. So let's now look at a modification.

Unknown Speaker  36:03  
Let's change the parser that we had the tokens the expressions are exactly the same. But we want to change the parser. There's two ways to do it. Actually, we could go in stages. But let's, let's let's jump over to one of those. So one possibility

Unknown Speaker  36:41  
would be to do something like this. We say an expression is either a summoned and then plus or minus and another expression. Or if one of these cases doesn't fit, then we could say it is just the summon. As some of the intern, now I'm trying to organise it. So that times has a higher precedence than plus and minus can be a factor than times as summoned or if times doesn't occur, then just the factor or if Yeah, if I don't find anything more, so that's one possibility to organise the grammar, and we do get rid of the left recursion, then this is okay. But we get a little problem then then all our plus minus and times will be right associative. However, this is not the normal practice, you want them to be left associative. In particular, for example, when it's something like x minus y minus Zed, you don't expect that they should be understood like this, we do expect that they should automatically be understood

Unknown Speaker  38:27  
like this,

Unknown Speaker  38:28  
but this is not what happens if your grammar is like this is the grammar is like this, you don't want to see here in the sort of recursive position immediately on the left you want the seat in the in the remainder. So, then, you extract from an expression as summon which is will be this thing and then you try to pause the rest as an expression, the result will be this. So that is a bit unsatisfactory.

Unknown Speaker  39:05  
How to get around this. Well, we can reorganise the grammar, then like this sort of even finer

Unknown Speaker  39:21  
we can say the following thing. So instead of working with one summon in an expression, then a plus or minus sign and then the rest of expressions we say the rest is like more summit. So what does then the grammar be like? What is the grammar like sorry, then the grammar says an expression is first of all, as summoned and then it has to be a list of summons list of summons are a separate syntactic category here. A list of summons you recognise by seeing Either plus sign another assignment. And yet a further list of summons, which can again start with us, but it can also start with minus because another form of a list of summons is first A minus, then a summon, then more summons, list of summons can also be empty, which means that an expression can really be just a simple summon, and this thing is empty. And that basically caters for this case, but with properly taken care of left associativity on the level of summons, that is exactly the same game you don't directly say a summons is a factor times another.

Transcribed by https://otter.ai
Unknown Speaker  1:04  
Hello, let's have a sound check. Can you hear me? Yes. And I can hear you as well that is very, very good. Let's wait a minute.

Unknown Speaker  1:17  
Can we get started here?

Unknown Speaker  2:51  
Okay.

Unknown Speaker  2:58  
Think about time.

Unknown Speaker  3:06  
So today we'll change topic we've discussed what during this course, I gave you a quick intro to F sharp that took two weeks and then we discussed a fairly simple expression language where the idea was to simply introduce the concept of having like a small hierarchy of languages and then to talk about the difference between compilation from one language to another versus interpretation which is in some sense executing or evaluation of programmes directly. And then I showed you the different kinds of workflows that can arise there. And the main sort of language feature that is common to essentially every programming language that we learned there was the idea of local names and local scope. Typically related to some sort of block constructions. Block constructions arise in languages in multiple ways, we mostly saw one which was basically you just form a block in which you introduce one or multiple local names, local variables, then there are also other types of typical block constructions like function definition is right hand side is a function by function definitions or bodies of function definitions are also an example we didn't look too much into it at all. And then what I'd like to do next, as we go further also in the book is to talk about some ideas concerning functional languages in general. So this concerns then languages like ml, oh, camel Haskell Scala, have heavier also Lisp and closure. Which are non strongly typed. And then that will take around four weeks. And then during the last four weeks of the course, we turn our attention to imperative language languages like Java C sharp, or c++ if you wish, which is even object oriented examples as well. So, and then we look at sort of typical constructions and issues there. imperative programming is very much about operating with memory. And we look at explicit and explicit sort of implicit sort of automatic memory management versus explicit memory management by the programmer, as you perhaps seen in a language like C. Versus in languages like Python, or Java is much more sort of behind the scene for you. In this functional languages part, what are the important aspects, we will talk quite a bit about first order versus higher order functions. So functions that take other functions as arguments are important. Also, polymorphism, or generosity is important. So, so functions that operate on multiple types. And then I need to spend quite a bit of time discussing type inference. So, many of you, I think, already working on the practical session problems or assignments run into this question of how does F sharp figure out pipes and why, why is the type information here like this or like that, and why doesn't it agree with what I think, then I'll try to explain how this works, in most cases. So, there are some, some sort of Central ideas that happened in most that occur in most type inference algorithms. And also, you see them in F sharp, so that is the plan. Today, we we start slow, I just want to take the expressions language, add a bit to it, so that we can not only have local names, but we can have local, not like local names for integers only, but we can also have local functions. However, the functions will not be first class, which means we can't write higher functions in particular, we cannot even return the function as a return value. So, let me share what we have here. And then we get started here should always slow me down if you find something

Unknown Speaker  7:55  
is unclear or very unclear. Yes. So, there is a chapter in the book that I've also

Unknown Speaker  8:17  
listed in the modules in Canvas. I can't remember the chapter number. But, but this introduction then corresponds to, to the first chapter on functional languages in the book. So, what should the functional language be like? So, so far, we were able to write the expressions like maybe four plus three, or maybe let x equals four in x plus three. And these things could have been nested in every sort of way. So, you could also do let x equals four in, let y equal three in x plus y, for example, or lots of other combinations. But the only things we were able to define here, and the only things here to which we could give names were were integers. So, here I have a local name x for an integer defined and here is the use of that name. Here we also have this local name x. introduced, we have a yet more local name, why introduced was only scope is this bit here, but still is an integer. So, with a syntax that we played around with thus far, all we could write is, is basically simple arithmetic expressions, plus a bit of sort of local name giving and then the facility That we can actually also refer to these local names or we can use them. no possibility to do function calls. So what do I mean by or even to define functions? What do I mean by this, I'd like to be able to say stuff like, let f of x equals x times three in F applied to five, perhaps, which would be a way to say that I'm interested in number 15. To start with, well, maybe you don't ever want to introduce a function, if you're only gonna call it once. So this is maybe not one of the most useful examples. But maybe you want to call it multiple times, right, we could do that. So I would perhaps want to do that to give an example. So this is how first order functional language should should be able to work. So we should not be only be able to define names that stand for something primitive, like numbers here integers, but also names for functions that we can further use. And when a use of a name for an integer just means that I want to recall what the value of the integer is. The only way that we can use functions here in the language that I'm going to define is we can call functions or apply functions, these are synonyms, you cannot pass out the function. So the following thing will not be allowed. In principle, this is not a silly thing to want. So I might be willing or I might want to define a function like this, and then just return the function. So make the function available to the general public, then the value of this expression would be the function and anyone could later applied to whatever if the whole expression is also given a name for example, but here this is not going to be allowed. So we only do things like this. Yeah. So what will happen, we will take the expression language as it stood and try to do a minimal extension. So the expression language becomes usable as a sort of portmans functional language. This can be done in multiple ways, but what we will do is the one that I sort of hinted. So we will add two constructs to the language we already have function definitions. So I should be able to define locally a name a name for a function, and I should actually be able to define the function at the same time. And then when some function name is in a scope, I should be able to call that function. And that's that's all the additions that there will be compared to what we've seen before

Unknown Speaker  13:11  
some some points related to it, then we do not allow today or we won't allow today an anonymous function. So a function must always be named, if you want to introduce a function, you must at the same time give a name to it, we cannot do the kind of fun construction of F sharp for example, in this little language, what is also called the lambda. And also you cannot ever returned functions when expressions value cannot be a function. So this is related to the point with as I said that, it's not okay to say that the whole thing's value is F here. So if we played it interesting, a function should be able to take any number of functions. So perhaps I'd like to say something like f of x and y equals x times three plus y. But for simplicity, let's say a function can only take one argument and in some way this is sufficient, because if we were to also introduce pairs, so the ability to form a pair an expression that is a pair of two expressions. And then if we also introduced projection constructs, then one place functions are as solution for any number of places you want to have for a function because to have a two place function is the same as to have a one place function working on a pair. That's one sort of approach to it, of uncovering functions and curried functions was a different one. So this language is going to be first order. Okay, what is the language like? The language is our own expressions language. What did we have there? So, there are some parts that that we know and love already has. So, I can use variables variables are represented as just streams, I can do let. So alette expression is given by three things a string, which is the variable name morally to the left of the definition sign an expression, this is the right hand side and the body of a left. So, this is our block structures for introducing local names today. And then we have all the goodies that we had before either in the lecture or in the practical session. So, I can I can write numbers, integer numbers, addition, subtraction times is possible, perhaps we can also do the negative of a number. And then some little logic as well. So, some Boolean values true and false, that can compare to arithmetic expressions for equality or maybe for less than. And then finally, if then else, which takes a guard into branches. That's all, what we've seen before. The only thing is we should add is the facility of defining names of functions. And using functions. And the only way that we're allowed to use functions here is applying a function, also known as calling a function with an argument. So, there would be these two cons, directions to call and let fun call is something that you would sort of in concrete syntax, right, simply like this. So F here has to be a variable. It's a function name, he can be any expression. So it's like a function applied to an argument. Normally, in a functional language practice, we don't insist that there are parentheses around the argument, maybe you would like to put them I don't like typically you don't require it. But then in abstract syntax, all we need is a name. And then expression, the name is the functions name. Yeah, we don't have an anonymous function. So it's not possible to write the function expression other than a name. And then the argument can be any expression. That's fine. This much about using function? So we've got this call construct. Now. That is good. How about defining functions? Well, the way that you would define a function should be something like what I wrote here above, so let a function some parameters, Well, here we are on low low, exactly one, and then the function body or function definition, and then the body of the left. So the general shape of this definition is something like this. So there is like let I write left, but this is actually going to be a recursive left. Let's agree. So I can define functions recursively, without having to say rec.

Unknown Speaker  18:12  
And then what I have to the left of the equal sign has to be the function name, then some names for the parameters, they are actually going to be local names to this definition. So they only make sense in the in the right hand side. So this right hand side is what is also sometimes called the function body. But then there is the other body. This is this guy here. That's the body of the whole let construct. So this is the little block, or the little expression within which the function definition makes sense. Here, define the function. And now anybody you can use the function, possibly making function calls and using arithmetic operations, Boolean operations, etc. So does it make sense? Let's look at some examples. Otherwise, these may be too abstract. So So here is a sort of a typical concrete syntax thing I might want to do very similar to what I already showed. So I'm defining a function locally, f is the name of the function x is parameter. This is the functions. definition, people also say the function body. So the idea of the function here is to simply return the value of x plus 11. And this is the this is now the body of the left, not the body of the function. And the only thing I'm going to do here, in this example is to apply F to three

Unknown Speaker  20:01  
So let's see, this is very defined this kind of expression, it's called a one here, let's see, what you want is like F sharp tells us, it's really convinced that this very same that I defined here is properly a legitimate expression. So it's a programme in our little programming language that we've now put together. So far on the level of abstract syntax that we have to write things in this horrible way. But you connect, you can connect it to a parser and lexer. modifying the parser and lexer we have. And then you can write programmes in a more reasonable way, more or less like strings like this. Okay, let me give you more examples. Here's a different one. What is that? So here's two let's nested inside each other. One is the kind of lead way that we've seen before, where I introduced a local name for a number. So I want that y means 11. So I say this. And the scope of this definition of Why's the rest here, so it's the body of the left. Now, the body of the left consists of another lead. But this is not the usual lead where we introduce a local name for a number. Now we introduce a local name for a function, we introduce a name for F, sorry, a name. For a function, the name is F. And here's the function definition. It works with a formal parameter. So that's a name, whose scope is only the right hand side of the definition, the function body, so to say, when we get to the body of the let fun, which is here, here, x is no longer in scope. But the new name for the function that I've introduced, this is the scope, so now can use the function. And maybe I want to apply F to three. If we call it up in our concrete syntax, sorry, in our abstract syntax, I have to realise that these are two different LEDs, they look the same. But they are different. Because see, here, there is one name to the left of equals. So therefore, this is a name for a number. Here, there is two names to the left of a function of the equal sign. So therefore, this is not introducing a local name for a number, it's introducing a local name for a function that takes a parameter, the parameter can actually only be a number as we will see. And, or at least, that's the intent. And x is just local here. Now, in the concrete syntax, these are both written let, but in the abstract syntax, one of them is let it takes three arguments, the name, the right hand side, the body, the other one is not lead, the other one is lead fun. And it takes four arguments, the name of the function, the name of the parameter, or the parameter, then the right hand side. So the definition of the function and the body of the whole, let thingie the body here of of the inner let the function lead is actually just a function call. So in our abstract syntax, this is the data constructor call or the tank call with two arguments, the function name and the general expression here, the expression is very simple, it's three, but it could in principle, be one times three y times 17, or something like this. So let's take that one, two. And that is okay. But if I were to mix up the two let's or let fun Of course, it doesn't work. So I might have the bad idea.

Unknown Speaker  24:10  
Either partially write it myself.

Unknown Speaker  24:15  
I might have the bad idea to think that the outlet is also the function lead. And then when I asked short to check this thing, then it says there is a problem, right? Let fun once for arguments. But we have only given it three, this guy, this guy and this guy.

Unknown Speaker  24:41  
Okay.

Unknown Speaker  24:46  
Now let's do something more interesting. Does it make sense so far? I've gone really slow and that should not be controversial. Let's do something else which we'll look Very simple, but it's actually very controversial, when you start to think of it as sort of deeper, is a little variation of the programme that we just had. But I've introduced one more or less. So is now is three fold nesting of LEDs. So first I introduced a local name for an integer why they need to use a local name for a function f, then I introduce a yet more local name for a number. Why, again, with the funny effect that now I have two ways in the scope, but only of course, the inner is accessible the the outer world has been shuttled out should be like this. And then here the body is again, f of three like before. Now if here the body we're not F of three, if it were just why it's pretty clear what the value is, then the Y is 22. It's not the level. Yeah, and that's the value of the whole thing. But that's not what the everything here. So we've written F of three. And here's the interesting question. Now what what should come back? Of course, I'm I've already written the answer here, but let's think about it.

Unknown Speaker  26:23  
So there's various ways to think of it. One way of thinking says, so let's just read the, the the expression sort of outside in

Unknown Speaker  26:38  
one way 3d is to say, Well, we know we've introduced the local y, which is 11. Then we introduce the function which given any x as x plus y together, where y probably is 11. So we could think this function f actually is a function that adds 11 to whatever comes its way. Then we introduce another y, which is 22. But that shouldn't matter. And then when we apply F to three, why shouldn't it matter? Because we don't mention y here. Then we apply f two, three, what was f? f was the guy that added 11 to

Unknown Speaker  27:21  
2x. Then we could say okay, yeah, the way this way here was 11. It's it's three plus 11. It should be 14.

Unknown Speaker  27:33  
But what happens things Speak louder? A bit louder? Yeah. What happens to the lower? Why, like, why is equal to two? We have a very good question. Indeed. Let me put the sound low.

Unknown Speaker  27:49  
What happens to the lower Why yes, indeed. And

Unknown Speaker  27:54  
so

Unknown Speaker  27:56  
I don't know. So let's, let's try to see if there is another reading. We could say we've just introduced y, which is 11. And let's read it outside in again. We save introduced y which is 11. Then we say we introduce a function, which takes x as a parameter and adds together x plus y. Now let's think differently. We know what x is x is whatever F is being applied to. So we get to know it when we apply the function with y. Let's wait, let's see what it is when the function is actually called. Then let's process this guy, we say Aha, we enter a scope where y is

Unknown Speaker  28:40  
22.

Unknown Speaker  28:43  
And then we call F of three, maybe we should say that the answer is actually three plus 22, which is not 14 is 25. And that should be a reasonable story, right? Do you agree? That is exactly the question. What does really the why here mean? Maybe it doesn't mean anything at the point when we make the definition. And it only obtains meaning when we actually make the function call. So that's one way to think about it. Another is let's fix the meaning of everything in the definition of the function at the moment when the definition is made. So later, when we call the function, it's completely clear what the function does. It's only just to see the argument that we need to plug in. So here are the three. So in that reading, of course, you will do three plus 1103 verse 22 is very unclear. Now what do you think? Can Can someone guess which is correct? Or and also, what is why? It would be correct this way or that way.

Unknown Speaker  30:04  
I think 2525 because in the lower scope, you override why we attended to

Unknown Speaker  30:13  
that we met. Yeah, it's not a bad reading. I kind of I fully sympathise with this.

Unknown Speaker  30:20  
I disagree.

Unknown Speaker  30:21  
You disagree? Why do this?

Unknown Speaker  30:24  
Because I think it would be better, maybe for performance to pre allocate. Why is 11?

Unknown Speaker  30:37  
Right.

Unknown Speaker  30:39  
But I might be wrong. I'm just guessing.

Unknown Speaker  30:42  
I think you're both right. And that is the trouble. So both are possible designs. And maybe the best thing to do is never to arrive in such a situation, right?

Unknown Speaker  30:53  
I guess yeah.

Unknown Speaker  30:55  
Best. So you, you somehow want that. There is never this kind of ambiguity. But But this is also not a satisfactory solution. So one of you was, was promoting this kind of static idea that we fixed the meaning of why when we make this definition, right, since y is not the parameter to the function, the idea is the meaning of y should already be fixed by the time we we make this definition. So So surely, if we've taken this static idea, I'm sorry, I said it wrong. So if we just take the idea that it suffices if if y is defined around ones, like either here or here, but not both. But But then if we take this static approach, and y is not around, then then we are in trouble, because y is not even initialised at the moment when we try to, you know, record the definition of F processing this. So it also feels like it's not great to simply say why has to be defined somewhere, because this would be very awkward from the point of view of language implementation, right. And also modularity. So if we have no idea if when when we make a function definition, whether we should look for the for the value of y in a scope further out, or further in. If it's not made locally, I mean, at this point, which is not when it feels like strange engineering. So actually turns out that historically, people had the idea that he should understand that, why is 22. And this was done by this by john McCarthy in the when he defined the Lisp language, which is one of the early ones of functional languages. And in a way, it's sort of intuitive, and it's even simpler to implement, I must say, bizarrely enough. This has to do with how you implement function calls all together. The idea is, you maybe have already seen it in some other course. The idea is somehow that if you make function calls, then you build a little stack of the calls that are currently active and sort of what is still the work left to do in this course. And in that stack, you simply would then look up the value of y and you will try to find it sort of closest to you. So closer to the top of the stack dynamically, that kind of makes sense. On the other hand, this idea that why is 22 here is sort of terrible from the point of view of software engineering, or like readability of the code. Because the point is, there are so many ways in a general piece of code. How the control can reach a particular functional application, imagine that I like if the analogies here on the way. So don't know which way you came to this programme point. And depending on which way you came, you may have made different definitions. Okay, if then else to make local definitions that would extend beyond the if then else but but but in principle, the control flow can be complicated, and you don't know how you arrived here. So it's very odd. If at the function use sight, you cannot really know which kind of environment you're using in the sense of what are the values of the variables in the function definition. It's also very strange for type checking, for example. So imagine, variables could take not only integer values, but say also say string values. Then we could do things that are completely bad, right, because this function definition is enclosed in this block. Here we say Y is an integer And we could say okay, so therefore this body should make sense. Before an integer like, okay, I can add together integers plus works on integers. Suppose then I go to the inner inner block, and think the very make a new local variable y, which is not an integer, which is maybe a string, or Boolean or a character. And then all of a sudden, the definition I've written doesn't make sense, because I've changed the type of y. I haven't even changed it. There is two ways around the outer y has type into integer and the inner y has another type. But how should the poor function definition know which type it should have?

Unknown Speaker  35:42  
Right? So sort of from the software engineering point of view, and dynamic scope, so the kind of scope rule where you only decide at the function call site, what the variables in the function definition mean, is, this is really, really difficult. It lives sort of on understandable code, which is impossible to maintain. Whereas static is very clear. It's all about like, syntactic nesting of blocks, and you just see what is your closest enclosing block? that defines the variable in question. So here, this is one block, and its content, which doesn't define why itself, and here is a bigger block that encloses it, or that encompasses it defines wine. So that sounds good. To see. So let's try to let's try to make this crisp, so that we have some sort of definitions to work with. The discipline, according to which the one that is used here, when we call F of three is 11, is called the static scope rule. It's called static, because before even running the programme, you can figure out which is the place to from where you need to take the definition of why that actually is relevant here.

Unknown Speaker  37:13  
Dynamic scope,

Unknown Speaker  37:15  
you can only determine runtime right here. Since there is only one possible flow, you go from here, here here. It's kind of easy. But but but with recursion, or other things in the control flow, as you'll see later in examples, you really can't figure out what is your closest place in the frame stack that defines why which would be the why event to use, which here is 22. So that's called dynamics GoPro. So the point is, with a static scope rule before running the programme, you can figure out which definition is relevant with dynamic scope rule. This is decided runtime, which feels like it should give you an overhead but it's actually not terrible. And there is a different type of overhead that comes from the static scope role that maybe I can explain at one point. Okay, so in some sense, both of these scope roles tell you that the variables definition should be looked, there's a word missing looked up in the current block or the nearest enclosing block. But what changes is the idea of what nearest enclosing means precisely. Yeah, with static scope, it means the easy thing, it just means how blocks are inside each other in the syntax like here is a big block contains a smaller block contains a yet smaller block contains this with dynamic scope, you have to take into account how function calls nesting blocks and in each other during evaluation, and here the idea is a bit different. So, by the time that I reached the call F of three, then of course, I have to look up the definition of of of f, I see this. So basically, I will be processing the body of the function so late. And I say this guy is contained in the body of this guy. Because dynamically It is like this. I mean, this is invoked while I'm here. While who invoked me here, it was the this guy, and who invoked me here was the big guy. So there is like a fourfold tower. And this guy is at the very bottom of it. And according to this tower, why is the closest enclosing block to x plus y is not this one, but it's actually this one f3 And here, this doesn't locally define y. So we go one level up, this does locally define y, and therefore we say it's 22. So it's really terrible, kind of how the dynamic scope works. So here I've written out the tower, exactly, the use of y is in the definition of F. And that we think morally, is in the body of the third leg, because this is where the call of f is. Now the body of the third leg, of course, is in the body of the second leg, and the body of the second leg is in the body of the first leg. And therefore, the order in which you make definitions away from outside in is the most outermost one is 11. Then he this one doesn't define anything, this one says it's 22. And by the time we get here, through actually the function call, we've already seen that, why is 22 that's what dynamic scope does. So then, as I said, static scope is sort of the correct scope rule from software engineering point of view. And what I didn't yet say is, practically all modern languages. Contrary to perhaps what you first might think, if you didn't ever run into this problem is nearly all modern languages use static scope. And the reason is, you get code that you can understand. compilation is a bit more difficult interpretation is a bit more difficult. In some sense, there is a little overhead if you do interpretation in a static language, versus dynamic language. But I can't go into the detail at the moment, maybe a tiny bit later. But then, interestingly, dynamic scope was invented first. And then when you would ask, you know what is a modern language that uses dynamic scope at all, then I would have to tell you, basically no language, you would use it, except for some dialects of Lisp still in use, they tend to use it. And it's also used in Perl, which is a scripting language, as you might know.

Unknown Speaker  42:22  
So

Unknown Speaker  42:23  
similar to, to the shell languages, like bash or C shell, there is Perl and Perl actually supports both static and dynamic scope, at the same time by some annotations that allow you to distinguish which is bizarrely enough, and I suppose it makes sort of a lot of sense in in some dynamic applications. scripting applications. Because they are sort of very, very, very low level. And you'd expect that the interpretation should be extremely straightforward. So there may be some natural principle to use dynamic scope. And then static is kind of a more fancy superstructure on top of it. Okay, we'll see both in action. But now that I've told you this, let's let's look at some examples. And let's figure out what we want. So this is a tiny variation on the example that we just saw. So the only difference is that the outside let the defined y to be 11 is gone. What do you think now, which, what kind of why would be used when we want to evaluate this whole programme, which in the end reduces to evaluating f a free which is also what is returned. With dynamic scope, it looks like the problem hasn't changed. Because immediately before we make the call to F, which takes us to the definition of f, we've introduced a local y. So dynamic scope, we'll use 22. How about static?

Unknown Speaker  44:17  
What do you think?

Unknown Speaker  44:19  
Unfortunately, I'm already saying it in my text here. So for studying there is the problem that for us to make sense of this definition here, we have to rely on an outside definition of why sort of outside in the sense of lack of syntactic nesting of things. So if this is a top level programme, then we cannot know why unless y is provided to us from the outside environment, which we could then supply. But otherwise, if you don't supply any outside environment, if you if you run this programme within With an empty within an empty environment, you would you should get a complaint that y simply doesn't have a value it hasn't been introduced. It's like uninitialized in a kind of imperative programming sense.

Unknown Speaker  45:14  
Okay.

Unknown Speaker  45:17  
And here is one last one. And then we'll have to think what all these things mean and how to implement them in the on the level of an evaluator. And I'm, I don't want to do so much more today. So this is just to illustrate that we write let fun, but the intent here is that everything is sort of by default recursive. So we could do the following. We could define them, we could do a nested let, but nested in a different way. So we've got a top level lead, which is a function that with defining a function, and in the body of this lead, the function is just applied. Nothing else is happening. But there is a nesting in that the right hand side of this function definition is a further left. Actually, this is quite interesting. So the function has a parameter x, this x is only usable here, right, which is the definition of the function. But now the function definition uses another function, which is something that you see in some languages, but you don't see in others. Like in C, you have function definitions, but you can't make function definitions local, you can have function definitions on the top level of your code. So you can define your main function, which is like the top level expression, which can depend on a bunch of functions. But those cannot use any internal local functions of their own here, very sort of no reason to forbid, local functions. And what we could do is we say, the value of f of x for any x that comes our way, is G applied to two times x, where g is our private function here in this definition of F, which only we know to be equal to x plus y. And hear why is in a different role than it was before here. Why was a local name that anyone can use here? Why is a is a parameter for the local function? So it is like low levels of locality? Let's check that all of us understand the scope of everything. So here's the top level programme. Where is the definition of f, the definition of f is here. So which is the area in this programme where I can use f? It will only be the body of this left, which is only this small bit? Yeah. So this is the definition of F. And this is where f is in scope. Let's look at some other names we have here. What is the scope of x, x is the parameter of f, therefore it only makes sense within the definition of f, the definition of f is given by its right hand side it's here. So x this x declared here can only be used in this part. Okay. Further What is happening? So, here is the definition of G. Where can this G be used that we have introduced not here. But only not in all of this either. That doesn't make sense. But it can be used here. Actually g could, in principle, be recursive, then g could also be used in the in its own definition. That's all that's also possible. But he had in particular, it hasn't been used. Actually, the same is true about F, if you could also use to define f itself. And then finally, what is the scope of y, y is a parameter of G. So it can only occur in the in the definition of G. And then you can code it up in our abstract syntax. That's, that's not difficult. It's just literally collect everything we've seen. Now let's see recursion in action. This is a modification of what you're seeing here. So I'm defining some function f with a parameter x. At the end, I will only apply to some y. This y is defined nowhere so it must be given from outside. But what is the definition of f? It's this bit here. Of course, it can use the parameter But now for the first time, you can see that I'm also labour able to use the function itself that I'm currently defining. So this is recursion, that's allowed.

Unknown Speaker  50:14  
Let's see if, if F sharp believes it. So that's e five. Yeah, this is correct. It's just types of expression. No, the lighting conditions change. Okay.

Unknown Speaker  50:37  
So we've talked quite a bit any any questions. Thus far, all I want to do in the rest is just to show you an evaluator for this thing, and nothing really else. And he, the evaluator is the one we've seen before, I only need to add two clauses, one for function calls and one for let fun. But there is a twist, in that. Now, we don't only work with integers and Booleans, there are also these functions around in some sense in the semantic domain, so we have to be a bit careful with this as well. And that will introduce a small twist into the code, we need to work with the idea of a closure, which is a very important concept in, in functional languages, it also enters imperative languages in a certain way. So I'll have to explain you this. So that will be the one of the main things today.

Unknown Speaker  51:48  
Okay, let's get right to it.

Unknown Speaker  52:09  
Yes, one thing is, is the same as before. So every now and then I need to work with an environment. So the evaluator is an interpreter, right? So we don't do any compilation today. So now I need to work with an environment for so for every variable that is not defined within the code, we need to store what its value is. So this applies both to the top level code and whatever is not defined there. But also, since we defining evaluate the evaluation recursively, then for some expressions, they certainly contain things that are only defined outside them. So they're also this notion of environment is important. This is a dictionary, as I explained to you. So for every variable name that we use, we expect to see a value with a list of variable name and value pairs. And we have this function for looking up a value for a name in a dictionary like this. This was defined before, nothing has changed here this, I've shown it to you a number of things. But now things get more interesting. So in the dictionary in particular, but also elsewhere, I need to talk about values. So what is the value here? So the things we can produce here are numbers, integers. So one possibility, or one kind of value are integers. I marked them with a tag or data constructor, ie, we can also get Boolean here, I marked them with B. So b two and B four. So values and I 17. And I 42 are values. But we've got one more type of a value and these are functions. And what is the idea? The idea is somehow, the moment you process a function definition like this, you should record in your dictionary, the environment, that now we have a function around so so to the string F, we have to associate the function. The way we do it, is we just record what the function definition is. So the important ingredients in the function definition are what is the name of the parameter and what is the body. Because you only evaluate the function or the call, you don't evaluate it before. So I need to remember these two things. But for static scope, maybe I need to know a bit more. Because for static scope, I should remember when I process a function definition what the environment is at the moment when the function defined definition is made, so for example, here when I make this function definition, I should record what y is in the current environment. And this is what is captured here. So, a closure, which is what the function means semantically for static scope is a triple of three things, I have to remember what the functions parameter is, I have to remember what the functions definition or body is.

Unknown Speaker  55:47  
And then I also need to remember what what the current environment is. So, this is an environment over values. We've defined environment polymorphically. So, I can in my dictionary put anything I want, but here in particular, we want to put values there.

Unknown Speaker  56:14  
Okay.

Unknown Speaker  56:18  
What does the evaluator do? I've shown it a number of times. So the main idea is we give it an in an expression, this is the main argument here of interest. And we just want to know what its value is. And this expression is closed, it defines every variable, every name that it uses internally inside it, then we don't need to provide it anything else, we can just give it an empty environment. But in the general case, I may accompany I may need to accompany and expression together with a little environment that tells me what the values of everything are. That that is not defined locally. So let's, let's remember this, how it works. So. So like, for example, when I want to evaluate number five, se, then it suffices to do it in the empty environment where nothing has any interesting value. And we get to know that the value of this expression is five, that's sort of easy. And, well, the value of five is fine, even if I happen to know that the value of x is 17. because x is 17, but I'm just not using it. So that's the same coupon, I have to write iE 17. Because now variables can take values of different types. However, if I'm using a variable, then such a thing doesn't have a value on its own. I mean, I'm trying to use the variable x, but I haven't introduced it, I haven't defined it. So surely, something should go sour. And indeed, We this lookup function tells us it tries to look up, eval tries to make an eval makes a call to look up look up tries to find the string x in the dictionary, it's not found there. And then we get this exception x no phone, that's not good. But if I tried to do it in this environment, again, where x is the integer 17, then we get to know for sure if var xc 17. And then I can write more and more more more complicated expressions. This is what we've done before on a number of occasions. That should now also work because 3x three and x according to the environment is 17. So I should be able to see that I need to add together 17 and three and that surely gives 20 that's the game. So eval gets in the interpreter gets in an expression it needs to return a value and as an auxiliary argument, we can take an environment we always need to supply an environment but can be the empty environment and this is sometimes useful. Okay, so how is the evaluator written? Pretty much as before, let me show you some cases that you recognise. So if my expression is is just the number, given number, like here, we had known five, then surely I can just say okay, it's value is that number. If my expression is addition of two expressions, plus of two expressions, Then this is a big problem, which I just reduced this to the smaller problems of evaluating e one and D two separately in the same environment in which I'm trying to evaluate the whole thing. And then all I need to do is to collect the results from evaluation, if both evaluate two integers, so I see these capitalised here, then it's great that the result is also an integer, and I'm happy. If either one of the two is something wrong, it's a Boolean or a function, then we just fail because we will have a pattern match today. I mean, I could have also written more patterns here and give, you know, raise my own exception of like, wrong argument type for all of these bad combinations of patterns, but haven't done this here. Similar for minus in time and negation. if you for example, see the expression to its value is just a Boolean, true false is Boolean false. When we do comparison for equality, we expect

Unknown Speaker  1:01:09  
we expect we expect to, we evaluate both expressions in the same environment that is handed down to us, we expect that both are integers. If this is true, then we can compare them. And the result is true or false, which is a Boolean, we return that Boolean. If one of the two guys here is not capitalised something, but it's capital B, something for a Boolean, or a capital C, something for a closure, now a capital F something for a closure. So then we just say. So these are the easy cases, var and let R just be just as before, almost, let me see exactly as before, what was the story, when you need to evaluate a lead thing, the main thing is really that the value of lead is the value of the body. But the body you have to evaluate in an extended environment, which is not the original one passed down to you. But an extended environment, this environment is given by what is already in the environment, plus we add a thing in the front. Namely, in this new environment, we don't not only have old variables have their old values, but we have one new extra variable, this x here, which has its own new value, which we get by evaluating the right hand side of the definition here in the given environment. So the right hand side is evaluated in the environment that comes down to us from the main core of the evaluator, the body, not the body is evaluated already in a new extended environment. The variable case should really be that we do look up and then we just return whatever comes back. Except in this language we want to allow the function is used as such, or that the function is turned as such. So we want to forbid this. So therefore, what we really do is we look up the variable in the environment. And if the variables value is an integer or a Boolean, then it's great. But if we see a function come back, then we see Ah, it's a function that we try to use as a value. That's not good. So here we get with a, that's the only difference from the old case. But here's Now the interesting part. We have to also define what what calls mean. And what led funds mean. Yeah, so, this is we have to say, what is the value of a function call here we have to say, what is the value of a lead construct, where we have locally defined the function and whose body is the body thing here.

Unknown Speaker  1:04:16  
And that is now the crucial important bit. Let me do let fun first. The value of any lead to just be the value of the body like we had here in some extended environment where we're taking into account the new like local names introduced. So it's the same thing here basically, evaluating let fun in the environment and should be evaluating the body of it in a new environment and prime, which is a small extension of ends. What do I need to add there is the meaning for the new name introduced. So I need to extend my dictionary so I can in the future, look up also. The name f that I've just introduced. Okay, what's the entry we put in the dictionary? We say, well, the name is F, because it is F. And then here I put what is called a closure. So we record the parameter of the function, we record the right hand side of the function. But then also this is since this is static scope, I should remember the environment currently in force, which is this guy here. So this is crucial. So you see envies used in two places here. So we on one hand, we say the current environment is is, is part of our dictionary. But now something interesting happens, the dictionary gets a new entry, which says the meaning of f is kind of a little data structure. And in this data structure, there is another copy of this end. And the idea is the big end keeps growing. But this little guy here stays the same throughout it when we grow the these that sort of when we keep extending them all along. Now, the interesting thing is, suppose I'm calling a function with an argument.

Unknown Speaker  1:06:41  
How should that be evaluated? Well, maybe we should first figure out what the value of the argument these anyway, because then we can apply the function to that argument. So but even before that, of course, we need to find out what the meaning of Effie so we look up the meaning of F in the environment, it has to be a closure. Yeah, because functions have to be closures. If f is not a closure, if it's an integer or a Boolean, then you should not be able to apply an integer or a Boolean to an argument that's nonsense only functions can be called on arguments, not integers or Boolean. So, in the bad case, we just say our programme is ill formed and that could actually be sort of aesthetic check that you can do independently okay.

Unknown Speaker  1:07:32  
But if

Unknown Speaker  1:07:36  
if What

Unknown Speaker  1:07:38  
if it is properly a closure, then we remember this closure. And also actually, we say this closure is has got a parameter name, the right hand side meaning of the function body, and then some environment, which is the environment that we recorded at the point where the function definition was made, when the closure was formed. And then what happens now The important thing is, we first evaluate the argument in the given environment, the environment that is given to us here in the recursion from the main call. Let's, let's sort of obvious so that when you apply a function to an argument, the argument is not a problem, you understand where you need to interpret it, you should interpret it in the current environment. So whatever the value where every name is, you should you should proceed from that. However, then what is what is the result of the function call? Like, maybe maybe this guy here, right? So three, when evaluating the current environment, and is easy, what it is, is three anyway, but then I have to, once I already know that, that the, the programme num three has value is three, then what's the value of this guy? Well, I better go to the expression, which is the definition of the function. And I just take into account that the parameter now is not just anything, but it is actually the given argument. So I need to work with with the right hand side here with the definition of the function with the extra knowledge that x is three, and should this thing here contained, recurring here, it doesn't, but the principle here f could occur as well. Then I should also take into account the meaning of F itself as already established. Okay. So that's done here. So let's extend the environment a bit. Let's form a new environment and prime and then what should that be? That should be the environment in which we will now evaluate Write the function body. We said, the function body, we evaluate in the environment that is there at the moment when we make the function definition. Yeah, time has gone on, now we have a different environment. But the closure remembers what the environment was at the moment when we made the function definition is no zero kind of initial environment. So we use this. But we also use that X has value v. And we also use and that is for recursion, that F has the value clo. Yeah. So this, this bit here takes care of the recursion. And then we evaluate the body in this extended environment. So long story short, the argument is evaluated in the current environment. Once this is done, the function body I mean, from the place where the function was defined, as recorded in the closure is recorded in almost the environment, as it was back then. Plus, the new knowledge about the value of the argument, which is specific to this call, right? In every call, the argument can have a different value, of course, plus, for recursion, the knowledge that, you know, in the recursion, the recursive call of F means the same thing as the main call of f is the same closure may look terrible. But let's let's try to look at at some examples. I don't even know how to best do it. Can I follow you for a bit? Sure. Yes. That's what I said. Okay, if we take a five minute coffee break.

Unknown Speaker  1:11:52  
We could have been talking about it in the chat and it would be really nice to both.

Unknown Speaker  1:11:59  
Let's let everything sink in. Yeah. And then I'll do the examples afterwards. So do you want like until What 17? Just Just four months? That'd be great. Yeah, something like this. Okay, let's do that. Yeah. Sure.

Unknown Speaker  1:18:01  
Okay let's, I was still there. Yes, sir. Thank you. So let's let me try to give you some intuition about this, because I need to do two things and then we can call it today. One is to give you some feel why this works. And second is to, to really try to show what is different in in dynamically scoped version. So in this code, there is really two versions. One is for static scope. And there is one that is sort of commented out, which is for dynamic scope. And the only difference is in the in how you understand call and let fun. And I should also say the notion of closure slightly different differs for the static scope, and dynamic scope. So for static scope, it is important to remember what the function

Unknown Speaker  1:18:54  
formal parameter is what the function definition is. And the environment at the point of the function definition.

Unknown Speaker  1:19:03  
Because we want to get back to go back to this old environment that fixed the meaning of the function once and for all. But as for the dynamic scope, and here, you see, this is kind of easier, implementation wise. You don't really care about what the environment was, at the moment when the function definition was made. What matters only is the current environment, so you don't need in the closure to even record this. You know, you don't need any sort of memory about what the environment once was. Okay. But then, let's see. So suppose I want to do something like a call of a function say F, on some expression, maybe num three again. In some environment, this only makes sense if f is actually a function, right. So as soon As I say, f is maybe a number five. The thing should simply shout at me, because that's really a bad idea. I mean, you should not when you make a function call, then environment shouldn't think that the function name has the value which is not the function, which is say an integer, a Boolean. So here, I expect, actually, several things are happening. But what happened? Now, he was writing them in num three. So this is not good. Because we get this section exception integer, a boolean variable used, called. And that is actually

Unknown Speaker  1:20:58  
my own exception that I introduced were so bad. It was just a little bit. A little bit lower. Yeah, sure. But this means that I happen to have not the one

Unknown Speaker  1:21:19  
on commented that I meant, let me just change this. So now the study scope should, should be the one. And it's really funny that I've given two different error messages, but it's good that it showed here. So because both both are the same thing. But it saved my day at the moment. And let me see if here, the correct one is commented is also not the correct one. So let's do this. So we want to work with aesthetic scope. So this is our definition of closure. And this is what I want to do. I just have to reload it now. So okay, we should be in a better shape. Yes. Now, of course, we don't know which function was called because I put the error messages in both case the same. But in any case, I think we're here, right? Now let's do something more interesting, where we actually have the function to have some value. So one possibility is that you know, the function is not defined in the expression, the function must be defined outside, it's defined in some in a dictionary, so you could say the function is actually the following one. The function just says the function as a formal argument, x, and its value is

Unknown Speaker  1:22:53  
var.

Unknown Speaker  1:22:55  
x plus was a mistake. Just last week, I was typing okay. f x, and then plus more fix, non 12, say.

Unknown Speaker  1:23:30  
But I also have to give an environment let's, let's pretend that at the moment when the function was defined, there was nothing in the environment. So and that's fine, because for F to be a function that just takes any x and that's x to 12. I don't need to know any more names.

Unknown Speaker  1:23:50  
Oh, no.

Unknown Speaker  1:23:53  
Well, this is incredibly sad. I won't make this mistake again. I'll do it here. Evo. Cold. Number three.

Unknown Speaker  1:24:17  
Sorry for this.

Unknown Speaker  1:24:19  
So in the dictionary, where f is one last time x plus

Unknown Speaker  1:24:30  
the empty environment shows this. Close that. That's what I wanted to know. I won't close it anymore. And we're going to complain about this expression was expected to have type expert but has to Why are you telling me this?

Unknown Speaker  1:25:11  
other parents are in the wrong place now? The meaning is this. Yes. What is your problem? This is not the closure. Okay, so this is a proper closure. That is good. So what else is missing?

Unknown Speaker  1:25:52  
Yes, this is a good dictionary. What went wrong than before? Evil once? which kinds of evil? Are we using? Evil takes an expression of value environment and returns a value. Yes. So, who was not correct? Do we want to put the parameters? Right? Yeah, exactly, yes. And it was correct before but because I made this mess at the prompt this happened.

Unknown Speaker  1:26:28  
And now I see 15. Why? Why is it 50? Because we are making a call of F on number three.

Unknown Speaker  1:26:41  
And, and this is what it is. As the expression, f is not defined locally, so I have to look for the definition outside the definition outside is here we are in a dictionary where f has this value. And it looks like this. Now, let's vary this a bit, I could say, maybe also do this here. So, let this one be a bit different. Let the definition of F actually be that we are adding together x and y.

Unknown Speaker  1:27:21  
Yes. Let's see what happens. Well, if we just do this, why is not defined anywhere, right? It's there is no like local definition in the expression. There is also nothing in the dictionary. So we probably will get the problem. But But let's see, we should be syntactically correct. So we should get the runtime error. We don't get the runtime error, which is why not found. So where can we provide the Why? So one idea could be to simply say we also have an author, why do you think this will work or not? Which could be say 42. Is this good? Or is it not good? Well, we can ask the system I should say I 42.

Unknown Speaker  1:28:21  
Correct?

Unknown Speaker  1:28:25  
We get stopped to error, we stopped you to error. And what's the error? Why is not found again? Why is it not found? Well, when we evaluate the function for where do we get the values of all variables mentioned in the function definition? Well, we get them from the environment that was recorded at the point when the definition was made, right. So suppose here, I also say Y is maybe I not 42? Like 1011. Let's see what then happens. Now the interesting question is, will 1011 be used or 42? Well, the indication is 42 didn't help us anyway. So maybe it's 1011.

Unknown Speaker  1:29:15  
And indeed, we get 1014. Why? Because when we make this call, the way it works is we evaluate this guy, this is just an integer three, then we say Okay, now let's evaluate f itself. They are they're actually the definition of F, which is this guy in an extended environment where we record that x is three. And we can also use the environment that was remembered that the moment when the function definition was made, which actually happened before we were born. I mean, it's already here in the dictionary. We don't know from where this came, I just wrote it. I made it up. Let me complicate it a bit further. Let's try to define a why locally here. So I could Very well say let y be. What's another number 85? In this call now, my situation, yeah,

Unknown Speaker  1:30:14  
I have a question. Are we using the dynamic or the

Unknown Speaker  1:30:20  
other mods? Because I want to change it to dynamic and then something should go different, right? Yes. So my point is now 2011, sorry, 1011 help us. This is the one that actually made things work, this one was ignored. Now, I want to show you that this one is also ignored. Why? Because this is some definition of y that is made after the definition of F has been done, f is defined already outside. And at the moment, when f was defined, it looks like the Y at that point was 1011. So the local definition shouldn't shouldn't matter. Do you agree? Although my expression now looks like let y equal 85 in F of three. And then when I do this, hearing, the prompt, of course is impossible to read, then we still get 1014.

Unknown Speaker  1:31:24  
So then we could internalise the function definition in the expression right now it's written outside. But a small variation could be that we say that the whole expression is say, what it could be that we do the whole thing in, let fun. What led fun f x, then this plus finger here, all of that in the other lap. And now I don't need this silly thing in the dictionary. Now it's all in the expression. And maybe I could make it even more interesting by putting another letter outside where I defined that y is 1011. Like what we wanted to. So when I say let y 1011 in lead fun, blah, blah, blah, close many parentheses. Even more. So what's the structure of this we've got the threefold nested lead various the outside lead, where we define y to be 2011. In that whole thing, then there is the next inside leg where we say f of x is the sum. In a further left, where we say that the neener y is 85. And then we call F at three. Let me just once more, check that my parentheses are all good. So this is that lead, then that lead and that lead Geneva that's all good. And from the outside, why is 42 so what is 42, then next one is 1011, then we make the definition of F, and then there is a further y which is 85. And then finally we call F with three

Unknown Speaker  1:33:34  
it's still 1014. Now we've got all of these examples, let's do dynamic scope, dynamic scope is exactly the same, but I have to change the common thing here. So in the closure, I need to remind remember much less So, let me comment out the one for static scope that we comment in the one for dynamic scope. So now my my closure will just only remember the parameter of the function and the definition of the function nothing else. I mean, I could still remember the current environment at the point when the function is defined, but why because I would not use it. So there is less to remember. And then of course, I have to change things here. So I want to comment this one out.

Unknown Speaker  1:34:27  
I want to comment this one in I should not forget to actually load the whole thing.

Unknown Speaker  1:34:43  
And then we will very soon be done. Thank you. Um so here's the dynamic scope version. Let me see if I can show you both at once. Of course I can't. So, so what was land let fun for the static case, it was simply that when you see a let fun, then you have to record the closure that you learn from this function definition, which consists of the parameter, and then the definition of the function. And then you also record the current environment. For dynamic, it's exactly the same. But since our notion of closure is different, we don't record the end anymore. I mean, previously, in the static case, we have n here. Now it's not here. Yeah, that's different. So this definition time environment is not recorded in the closure. Now, how does how does this thing differ? So the corner case, the only difference is really here. And here. So the good case is if what I'm trying to call is really a function, because if it's not, then I should say it's not the function. But if it is the function, then I should use what is the closure according to the dictionary. And Previously, we had this n zero thing here, which recorded what the environment was when the definition was made. Now this one is gone. So that's one difference. The other difference is, previously we used n zero here. So we worked. As soon as we went to the evaluation of the body, we forgot about the current environment. And we went back to the definition time environment. Here, we don't do this. Because we haven't even recorded it. So we can only work with the current environment, and we just extend it to whatever with whatever we learn is the parameter value. And then the closure just for making recursive calls. Yeah, so n zero is gone from this point, it's not recorded. So that's one difference. And the other one is here, we don't use them zero, because we don't even have one to play with. very minimal difference. And sort of the over I mean, the overhead that is now gone in this implementation is that you never have to store these definition time environments. You know, if you compile it into into stack machine code, there will also be a little overhead in the static scope version, which goes away in the dynamic version. Now we can we can look at these same examples, again, are these variations. So what were they?

Unknown Speaker  1:37:54  
This one makes sense, except I have to slightly modified because the closure doesn't know contain a dictionary. So this was where we started. Not with the wrong number of parentheses somewhere. Yes. Now, that's already different. Because with a static scope, we had that, for this function definition to make sense, we already had to have meaning for x in place when we made the definition of f. So I mean, with this dictionary, empty, nothing worked. We later put 1011 there, right, and then it worked. Now, I'm not even recording anything, but this guy miraculously finds out that this is 15. And why is this?

Unknown Speaker  1:39:16  
No, no, I'm running ahead of myself. So this is of course 15 because there is not yet why. But suppose I replace num num 12 with variable y. Then it will complain that the Y is not found, right. Why not found I can do a little modification. I can in the same dictionary introduced that y is any less 11. Now at the moment where the definition of f is made, why it's not yet No later I introduced that, why is 1011 and this will already work? Because the function definition of the function called here, the definition is here will be used in the current environment of the call. And when I evaluate the call, why is already 1011?

Unknown Speaker  1:40:23  
Yes, so we get I don't understand extra parentheses now. Did it print two lines on top of each other? What is this thing here? Do we?

Unknown Speaker  1:40:45  
Yes, sorry. So 1014 that works. And then finally, I can I can make this local. So we can, for example, call this one. That's the same kind of code as what we had before. But the answer will be different. Why? Let's see.

Unknown Speaker  1:41:06  
So let's think what the answer should be. So we, this is the whole being expression, the outer y is something that is provided was top level from the environment is 42, then we make a local definition. So there is a local y, which is 1011. Then we define the function. At this point, y is 1011. But we go on, and we introduce a yet more local wine, which is 85. And then we call F with number three. At this point, surely, we will take into account that the parameter x is now three, that's not controversial. But what is why? And we will use the why of the current environment. So this time, it should be ADA. The answer 85 plus three is ADA. Let's see if this happens. And we do get that the answer is ADA. So this may look complicated. And it clearly is. things to learn from today is there is two possible study, sorry, scope rules. One Where is one is where you define where you take the meaning of any variable from the body of the function to be determined at the site of the definition. That's called static scope. And it's good software engineering wise, it gives you readable code and meaningful code. There is also the dynamic version, where you determine what the function means only at the moment when it's called, which means that in different call sites, the function can obtain a different meaning. And even in the same call site, it can obtain a different meaning if you arrive at this call site, from different directions, so to say, during the execution of the code, which we didn't see in action today, but we'll probably later. So modern languages use the static scope. Historically, dynamic was invented first, because it somehow felt intuitive. But then people figured out this is not the right thing to do. The still used in parallel, and some dialects of Lisp. Implementation wise, it all amounts to whether you have to record what the environment is at the function definition site. Which is the case with static scope. And in the case of dynamic scope, that's a bit easier to implement, then you don't have to remember anything extra in the closure other than the function definition and the parameter name. And this is it. So next time, we will make this simpler, I'll show you like a modification of the lexer and parser, we have for this thing, this will really not, you know, this is not central anymore for us. But then I'll explain you how type inference works already in this simple case. And you see that dynamic scope is really problematic. Exactly for the reason that this the same function call can be reached in different ways. And also there can be multiple calls of the same function at different sites. And it's very odd if the function means different things at different call sites. Does this make sense? Yes, lecture was pretty clear. Yes, it is sort of technically messy, but you have to let the ideas sink in. But it's, it's always the idea that sort of outer scopes are shadowed out by the inner scopes, but then the difference between static and dynamic doesn't Until you have functions, but when you have functions, then you discover that you know what is what is what is in here and what is out there is not so completely clear. And if you start to make it clear there is two possible disciplines at which you can arrive and and and they really diverge in a drastic way. Okay. Maybe then we say that is it for today. Did you write more things in the chat? I haven't. Since I was sharing a conceit

Unknown Speaker  1:45:36  
No, I think we're

Unknown Speaker  1:45:38  
okay. Yes, I think we're good. Okay.

Unknown Speaker  1:45:44  
Good then. So, um, do do talk to the TA, to ask questions to them as well if you don't get answers from them. Ask me and as questions on pizza and then we proceed like this. So I stopped the recording here.

Transcribed by https://otter.ai
