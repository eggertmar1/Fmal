Unknown Speaker  0:27  
Hello, let me start the next lecture. Last time we talked about lexing. So getting from a string to a sequence of tokens. Today, I'll talk about parsing, which is about taking a sequence of tokens and extract an abstract syntax tree out of it. And we do it for the same language of expressions that we've now been discussing

Unknown Speaker  0:59  
for a while.

Unknown Speaker  1:02  
So let me share my screen and let's get going. So, I'll do like this. Or the same way as we did last time. So I don't introduce, I won't introduce any deep theory of parsing, like I didn't also do for lexing. And I just show you one concrete example. And based on this, we'll try to develop a methodology and also notice what the issues are when you try to build a parser. So let's remember where we were. So this is our little expression language that we liked with variable uses lead expressions where we define a variable for local use, and then you have a body expression, numerals, and then operator expressions, just as before. Last time, I showed you how to take a string, maybe something of the form, let that equal 17, insert plus x and extract from this sequence of tokens. So you look at this flat string, and you try to see you try to break down the string into sort of smaller sub strings and convert these things to for information about information that is relevant for recognising what expression disease. So here we want to, for example, understand that there are two keywords involved. There's an operator symbols involved, there is a numeral involved, which is 17. I don't want to see one and seven separately, but but 17. And then there are a few names that, that and x. So names are just strings here that start with a small letter. But two strings that start with a small letter aren't our names, they are keywords, namely less than 10. And there are no other keywords in this little language. So suppose I've already transformed this thing into a sequence of tokens, how can I further extract the correct expression tree here the abstract syntax tree, which should be something of the form really as lead here, the first argument should be seven, the second should be non 17. And then the last one should be plus bar.

Unknown Speaker  4:01  
Bar.

Unknown Speaker  4:06  
How we do how do we go? How do we get here? Yeah, we go through this sequence of tokens that we already saw. So from the sequence I can get, I can get from the string I get a sequence of tokens, which in this case will be something like let first

Unknown Speaker  4:27  
and then we say the next thing we see is names that are the next thing we see is an equal sign. And then we see an integer which happens to be 17. Then we see a keyword and then another keyword in then we see a name. Then we see a plus sign. Then we see name.

Unknown Speaker  4:57  
Last time we wrote a bit of software To get from the concrete syntax as a string to this a bit more analysed sequence of tokens. Now I want to get here

Unknown Speaker  5:15  
how to do this? Well, we first have to understand that there is something like grammar behind our strings. So we can talk about the syntax for concrete expressions. So which strings are valid. This is fixed by the following grammar, this is not F sharp, this is sort of an informal explanation of what is going on. We've got exactly one sort of interesting syntactic category in our language, which are expressions. And expressions are really of five possible forms. Here, an expression is a variable. Length expression is something that in a string looks like this sort of a sequence less than some separators. And then this variable name, maybe some separators, optionally equals again, some separators, or perhaps not. Another expression separators in separators expression, is a numeral. And to make our task simpler to start with, let us make an assumption that, in order for parsing to be simpler, let's agree that every operator expression has to be enclosed. In parentheses.

Unknown Speaker  7:03  
This is not fully satisfactory, really, we want to use parentheses the way we want to use them. But it's kind of okay on this level. But you have to then be precise. And understand what what is meant so. So when I say that parentheses can be only around operator expressions, this is what really what I mean, in particular, for example, it means that I cannot put parentheses around the whole thing where I should really put them around each time I use plus, so. So that I'm sorry. So this one is a correct version of an expression according to this grammar. So why am I putting in these parentheses here? We'll see in a short, while, but there is a reason this makes writing a parser simpler. But then, of course, we want to actually have more freedom, and we'll get that as well. And then we see we need a slightly different design. Okay, so this is what we have, I start with a list of tokens according to this grammar. I want to produce an abstract syntax tree. And I'm guided by the knowledge that the tokens must have come from this concrete expression syntax. Yeah, these are the possible sequences of tokens that I'm happy with. So, the type of parser I'll explain here is actually called a recursive descent parser. The point is, in this grammar, you start from the start symbol. So I say, Well, whatever I'm seeing as a string has to be an expression, let's see if I can justify it. And then you go down in the grammar. At the same time you pour, you consume the list of tokens. And, and see if they're, you know, if the next things that I see in my list of tokens sort of agree with what is what is possible, what is allowed here, in particular, what I see should determine what I will say My my, my, my past three E's and you can already see that you know, a variable expression is specific in that it starts with a name. A lead expression is specific in that starts with the keyword lead. And numeral expression is specific in that it actually starts with in some integer. These ones are all similar in that they start With the same thing of parentheses, so I've really got four cases here, a name, the keyword left, an integer, or a left parenthesis indicate what type of an expression I have. But then I have to read a bit further to determine what kind of operator or two to see what kind of operators symbol pops up, for which you need a bit of luck. That is, that is somehow the idea. So let's see this. So the parser of expressions takes a list of tokens from the lexer. And then it tries to identify a prefix of this list. So some initial part of this list of tokens as an expression, while traversing and sort of consuming it, it may happen. And it often often does that, you don't need all of the list of tokens, there will be an unconsumed part. That's very important for the organisation of the parser. So then you return both fixed expression, the abstract syntax tree that you determined, but also the left over have the list of tokens. The whole programme is really not so big at all. It almost fits on one slide. And the important are the simpler parts are here. And then when it comes to the operators, we have to do a bit more work on this. So what is the functionality, at least two tokens comes in. And what comes out from the function is a pair of two things, the abstract syntax tree recognised or returned, and the leftover tokens.

Unknown Speaker  11:58  
Let's see what is a reasonable thing to do. So given a list of tokens, I've got two sort of top level options, either the list of tokens is completely empty, in which case, we can just say we didn't find an expression. That's an erroneous case. If my first token, in a list of tokens is a name, and then there are more tokens. Then I've seen a variable. So I say, var x, and I just returned the rest of the token. So I returned this pair, the first expression, the abstract syntax tree I extracted. The second is whatever I didn't consume. Similar easy case, is the one where the first thing you see is a numeral. So the token there is of the form in Thai, and then there are more tokens, then we say, we've seen the numeral and then the rest of tokens are on consumed. So what's the role of these unconsumed talkers to come? The next case which concerns then these lines is the case of us finding or almost finding, but then failing to find a lead expression. So, a good lead expression

Unknown Speaker  13:32  
is of the following four, the first token is lead, then there is some name, then there is equal sign. And then there is more things. So the more things are an expression, the keyword in and the body, but first we need to see these bits. So these are a good sign of us finding a lead expression. What do I need to do in this situation? Well, I cannot directly already return an abstract syntax tree here because I need also three the bit of the rest of the tokens. So let's try to parse the rest of the tokens, the rest of the tokens must surely contain the right hand side of the definition and then there must be more tokens left. So I call parse, this is my main function on the given list of tokens here and what should come back is an expression and maybe some more focus then or some more tokens will come but if if this list is not sort of satisfactory, then we will face problems. So what can happen if the rest then after having found an expression is an keyword in then we continue to be in good shape that I mean, we were still sort of on the path to success, because in is the next thing we need to see. And then after in some leftover tokens. What do we do with the leftover tokens from the leftover tokens, we need to extract a body their body of the expression, its abstract syntax. So why do I again parse the rest, which now is this Ts from here, when there is many Ts is around this Ts is this is this, this is this. This is fish. So, I get back a body, and then something may still be left. And then what we say is okay, we found this let expression collected from their name, the right hand side I found and the body I found, so this is what I returned. But I also return sort of the final leftover. If I found the right hand side, but didn't find the end keyword, this means that the lead expression sort of was well formed up until this point, but then after that something went wrong, and it didn't follow. So that's a bad situation, then we say, we've got a lead without the name. There are some other bad situations possible,

Unknown Speaker  16:33  
which need more space here.

Unknown Speaker  16:37  
Namely, it's possible that I don't even find an equal sign after I seen a name. So then it's a lead without an equal sign. So it, it is good until this point. But it can be even worse, it can be that I only find the lead keyword, but then what follows is not the name. So then it says the left hand side of the definition in lead is not the variable name. So do you see this, so we just go further down in the given token list, if everything forms with what we expect, then we just go further down as we need like, if we've if you've got this far, this already looks like a very good lead expression, then the only thing that I need to do is to extract the body from the rest of the list of the tokens. But I may fail earlier, because something may be wrong in the input stream, like I perhaps get to this point, but then I don't see an equal sign or maybe I get to this point, I see an equal sign, but then the rest of the list of the token is is empty, then I get this missing expression error. And then finally, there is the case of a left parenthesis, the left parentheses is a symptom of that something like this will now be there. So what should we do then now. So in the last case, it was sort of, we had one possible sequence of things that we expect let a name an equal sign and expression in and body here there is a bit more of very activity in that the operator may be different. But I mean, this thing put apart the rest of the shape of an operator expression is deterministic, there has to be a left parenthesis token and expression. And one of the tokens plus minus times and then another expression and finally a right parenthesis, we repeat exactly the same ideology there is, there is not even a lot of difference in the rest of world we need to stop here. So if the if the first token in my list of tokens is left parenthesis, this is this situation, then we go and parse the remaining tokens. From there, we get an expression and more tokens. So this part is done. Then I have to ask what form is there is the rest of tokens. So if it's a list that starts with plus or minus or times, then I'm in good shape. If it's now not an operator symbol next, then an operator symbol is missing in a list. Each of these cases are exactly similar. So let's just look at one if I see a plus symbol, and more tokens, then I should parse those further tokens, I should get another expression. And then well, the remainder of the remainder, that one must start with the parentheses. And then that may is there are more things left and what I return is a plus expression and whatever was finally left, if the expression is not sorry, if the operator expression parses well this far, but we don't find the right parentheses, then we say with a, but of course, failure can come earlier. Yeah, something can go wrong in each of these parts expert,

Unknown Speaker  20:45  
as well. And also this parse expert can go wrong. Now, this where all the code cases, so a valid expression starts with a name, or lead, or an integer or a left parenthesis. But of course, in a random sequence of tokens, I may start with a bad thing. Right away, like if the whole list of tokens starts within, then it's like an end without the lead. If it starts with equal, it's like an equal sign without let, if it's plus or minus, or times, then it's like an operation symbol without the left argument. If I start with a right parenthesis, then it's like a right parenthesis without the left parentheses. And if it's any of the illegal symbols, then of course, I should also be unhappy. What is a tableau parser is the following thing. So it's similar to this one. So I'm trying to parse an expression. The only difference is I don't tolerate it if at the end, there aren't consumed tokens. So it's a function that takes in a list of tokens. I expect back an expression, this is what the functionality I want. how it's done is you parse the given list of tokens, what come back is an expression and the rest of tokens. If the rest of tokens is empty, then we say, Great, we return this expression. And that's the right thing to do. Otherwise, we we, we raise an exception, we say there were unconsumed tokens, sort of, for the top level call of parse expert. This is not satisfactory. And we signal about it. And finally, we can put our lexer and parser together by just taking a string lexing deep, getting a sequence of tokens and then parsing. Let's see this in action. So I'm loading both the lexer and parser. Now, I also need to open the lexer the names available to me

Unknown Speaker  22:53  
parser.

Unknown Speaker  22:56  
And we can play a bit.

Unknown Speaker  23:01  
What

Unknown Speaker  23:04  
can we possibly parse? So we've got this function parse expert. It's called one because we will later improving it. What's the simplest thing to type to parse would be perhaps the empty sequence of tokens to start with,

Unknown Speaker  23:24  
let's start slow. Of course, the complaint is that the expression is missing.

Unknown Speaker  23:31  
If I have some expression that starts out, not in the best way, so maybe like within with the right parentheses. After we'd say maybe you have a name, then I get to know that there is a right parenthesis without the left parentheses. So the only good ways to start, as I said, an expression were to maybe start with something reasonable, like an integer like 17. Let's try that. So pars expert one will tell me this is it found the numeral and then there is some remainder unconsumed tokens. Of course, I can have more of those I can have yet what at the end, maybe something like this. And then all of this is unconsumed. But the start was very good. The parse expert one is happy but my top level function is not happy. The top level function was called parsable. This one says there are unconsumed tokens on the top level. Let's do some Anything else meaningful? Like, if I do a simple simple addition, if I do alpar

Unknown Speaker  25:15  
name,

Unknown Speaker  25:19  
last name,

Unknown Speaker  25:25  
bar bar.

Unknown Speaker  25:29  
This should be just set plus x with enclosing parentheses as we've

Unknown Speaker  25:35  
agreed,

Unknown Speaker  25:42  
then we get exactly the right thing. So this is how it works. But you have to understand that sometimes you have to work with leftover, right? So how does how does parse one even work? Well parse one works because parse expert one worked. So this is what part one called it actually called parse expert, one that looks at exactly the same list of tokens. But it's, it's sort of its domain is the driving parser function here. So this is the one that tells us this one is the expression I find. But there is also some, some, some leftover tokens. left over tokens are important for the case that you're in the middle of a process, like when you call parts expert, one on this guy. So which part in the programme handles it? I called power expert with a list of tokens. And I tried to match Ts with all of those attacks, I go here, L bar. And some somebody stole tokens. So suppose I've found l par, I call pars expert with the rest of tokens. So let's mimic the game here. Suppose I already found the L par pas expert is called with the rest of the tokens. What happens now? Then I'm sort of in the middle of the process. The parser finds my variable name, and then there are some remaining tokens. So yes, II one here that comes back. Is this var? Is it the new tiers? Are these guys? So what am I supposed to do in this case, I say, Okay, let's look at cases. One of the cases is this starts with plus great. In this situation, I have to look at what is after plus this thing and apply the parser to it again.

Unknown Speaker  28:05  
So let's see what the parser does here. Now, at this point, it's not correct to call parser one on this thing, because this one will complain that there will be some leftover, but it's perfectly good. And this is the whole idea of this parser. to to to just start at the left end of this list of tokens, try to extract an expression that is perfectly okay at this stage, that there is some leftover. In fact, we want some leftover to be there, we expect what we expect that we do get back an expression. But we do this, we expect that we do get back an expression, very some left over a list of tokens. And this list of tokens is not allowed to be an arbitrary thing, it better actually be the right parentheses. And then we can see, plus comes back and whatever is left over now is left over on the top level. Let's see if this actually happens. Yes, it does. We extract var x and then the right parenthesis is there. And at this stage, we actually collect plus e one e two, which is what we already saw here. So the total result is is this. So let's repeat the strategy. We have to understand that we have to write it down. What my concrete expression syntax is. This is written down as a little grammar. These things are called context free grammars. So for every syntactic interesting syntactic category, these things are called non terminals in context free grammars, but I don't really want to introduce the full terminology here. You say what are the valid sort of string forms? What are the valid lists of tokens, these kind of things. interferes with with the syntactic categories. So here for example expressions again. And then you just given given a candidate expression, the list of tokens, you try to match it against one of these, and then you go deeper and you see, okay, yeah, but you know, these things are these also properly and expressions. And your work from the left to the right in your sequence of tokens. feels almost perfect, right? And if it wasn't so hard. The trick is to reverse the list of tokens. collect things from there. Always work with, you know, the current remainder, the rest of tokens. And you're fine. But are you? assumptions not because we really would want to have this grammar right, this should be a sensible way of organising expressions. I like to say the expressions are the variable, Aled expression, the numeral than any of these plus minus times. And then I may want to put parentheses around my expressions in arbitrary places. So maybe also around the variable, maybe around the top level expression, maybe parentheses around some plus expressions, but not around some times ones, because the times times has a high precedence. That's what would be so nice. But the trouble is a grammar rule like the one thing and expression is allowed to be another expression plus an expression, you're the problem. Why? Well, our grammar how it would work is given a list of tokens from where it tries to find an expression, it tries to see whether it's this form of an expression, this form an expression, this form of an expression. And for that there are clear, so the signs, this one has to be a name, here, you have to see a keyword, the keyword lead first, here, you have to say, see an integer. But in this case, you just need to see an expression.

Unknown Speaker  32:43  
And then you don't know. Because you will have to, you basically have reduced your big problem of finding an expression in your list of tokens into a problem just as big of finding an expression in your list of tokens.

Unknown Speaker  33:06  
And then

Unknown Speaker  33:08  
if this is the case, your parser or expressions will try to recurse infinitely. So you can write a parser following the ideology that I showed you here, the well, but it doesn't actually work. So unless your expression is is is a name or less expression or a numeral if it's not one of these three forms the force case will be trying at and this is a problem immediately. Because you will try to do the following thing you will try to understand he as morally you know a plus operator expression, but then you will also try to understand this one as a plus operator expression. And then also this one as a plus operator expression in the case

Unknown Speaker  34:12  
when when the first things don't apply or maybe they do apply right. So suppose your actual expression is something like x plus y. If this is the case, then surely we can see we are in the first case. But that's not the satisfactory solution because then parsing will tell us this is just leftovers.

Unknown Speaker  34:48  
Okay,

Unknown Speaker  34:49  
but then what can you do? Then your possibilities to move this case, past all the other cases to the front. Like here who Your grandma. And now you directly go into an infinite recursion immediately. So you can't really know you cannot put these cases first. But you can't put these cases first either unless you introduce some extra cleverness. So what is extra cleverness? Normally, when you have a grammar, or say when you have a language like ours, and we want to use parentheses freely in the concrete syntax, we have to organise the grammar differently. We have to stratify the bit,

Unknown Speaker  35:45  
so we have to introduce extra syntactic categories. And here's the trick. So let's now look at a modification.

Unknown Speaker  36:03  
Let's change the parser that we had the tokens the expressions are exactly the same. But we want to change the parser. There's two ways to do it. Actually, we could go in stages. But let's, let's let's jump over to one of those. So one possibility

Unknown Speaker  36:41  
would be to do something like this. We say an expression is either a summoned and then plus or minus and another expression. Or if one of these cases doesn't fit, then we could say it is just the summon. As some of the intern, now I'm trying to organise it. So that times has a higher precedence than plus and minus can be a factor than times as summoned or if times doesn't occur, then just the factor or if Yeah, if I don't find anything more, so that's one possibility to organise the grammar, and we do get rid of the left recursion, then this is okay. But we get a little problem then then all our plus minus and times will be right associative. However, this is not the normal practice, you want them to be left associative. In particular, for example, when it's something like x minus y minus Zed, you don't expect that they should be understood like this, we do expect that they should automatically be understood

Unknown Speaker  38:27  
like this,

Unknown Speaker  38:28  
but this is not what happens if your grammar is like this is the grammar is like this, you don't want to see here in the sort of recursive position immediately on the left you want the seat in the in the remainder. So, then, you extract from an expression as summon which is will be this thing and then you try to pause the rest as an expression, the result will be this. So that is a bit unsatisfactory.

Unknown Speaker  39:05  
How to get around this. Well, we can reorganise the grammar, then like this sort of even finer

Unknown Speaker  39:21  
we can say the following thing. So instead of working with one summon in an expression, then a plus or minus sign and then the rest of expressions we say the rest is like more summit. So what does then the grammar be like? What is the grammar like sorry, then the grammar says an expression is first of all, as summoned and then it has to be a list of summons list of summons are a separate syntactic category here. A list of summons you recognise by seeing Either plus sign another assignment. And yet a further list of summons, which can again start with us, but it can also start with minus because another form of a list of summons is first A minus, then a summon, then more summons, list of summons can also be empty, which means that an expression can really be just a simple summon, and this thing is empty. And that basically caters for this case, but with properly taken care of left associativity on the level of summons, that is exactly the same game you don't directly say a summons is a factor times another.

Transcribed by https://otter.ai
