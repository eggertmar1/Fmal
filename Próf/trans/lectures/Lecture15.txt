5:06  
Okay, Hello, can you hear me?

5:09  
Yes,

5:10  
very good. So,

5:16  
good afternoon

5:20  
continue today a bit with lambda calculus which is something I started last time what was this about was about the basic core formalism for functional programming, which if you wish, every actual real world functional language is some sort of syntactic sugar on top plus added conveniences plus maybe some deviations from the sort of very strict underlying discipline that I was a big part explaining last time and they will continue explaining today. So, what we saw last time was untyped lambda calculus, which is this super minimal language where you can only write expressions also called lambda terms that only can cost consists of feet, three things namely variables, applications of functions, and then this basic mechanism of making functions that we also called anonymous functions before that we write fun in F sharp and that is written lambda in lambda calculus and nothing else, just the bare bones. And then we looked at a few examples, I explained how computation goes there, in the basic lambda calculus, there is quite a bit of freedom. Regarding this in a practical functional programming language, you exploit the particular or you choose a particular evaluation strategy, the one that is used by F sharp

6:54  
is

6:56  
strict, which is in lambda calculus notation corresponds to innermost evaluation strategy. So, let me recall a bit of this and then we go on today to type lambda calculus, where we add a bit. So in addition, for the ability that we can write expressions, we can then also write down types or type expressions, if you wish more precisely, and that one is also super minimal, you can only write two kinds of things you can write down basic types that are assumed to be given. And then you can form functions basis of them. So if A and B are types, a arrow B is a function type, and nothing else is allowed. So you don't have any, say paired types or list types or option types are so we will like to generalise a bit further and go to polymorphically typed lambda calculus, which is also quite minimalistic, but this has the peculiarity that you can actually code up quite a few data types. And we'll see this in action. Okay, so let's get going I'll share my screen Firstly, they just share a window. So, yet only to recall, what I showed to you was that we have this untyped lambda calculus in which you can only write these three things variables. This is what in F sharp is written phone x arrow t are fun X lt to define T, the expression to be a function in x, which is a variable that hopefully occurs somewhere in T for this to be useful. And then finally, a function application t you where t is an expression for a function, and u is an expression for the argument. And then I explained that this is very liberal in the sense that you can write things that feel very suspect, like applying x to x, which is a bit like applying a function to itself. How can this be. But untyped lambda calculus allows this simply typed lambda calculus forbids this. And if we go polymorphic, we can already start to do things like this again. But there they make sense because the idea is that x can be something of a polymorphic type and then as the function if there's one type, and there's an argument that might have another as instantiation. Okay, we talked about terms. I said that we really don't need left here. I told you about which terms are equal, considered equal or alpha convertible, that was the idea that bond variable names really don't matter. And you can change them if you're systematic about so here. For example, x is replaced with exprime systematically throughout. But there are constraints about this. Namely, you can't create capture. So you cannot rename various variables in such a way that the free variable becomes bound by accident. Then I explained the computation mechanism here, which was going in small steps like this, the small steps were called beta reduction steps. And you just apply these steps as long as you can, in principle, non deterministically If multiple steps are possible, but you may choose a fixed evaluation strategy, and then this is determined the next plane what beta reduction was, basically, it's about the following thing. It is a sort of a description, which says, if you just made the function, and then you applied, what does it really mean. And all it really means is the argument is passed to the function through the parameter, right, what else? So, the, the outcome here should be you with the argument, lambda x t is the function that you take T, and everywhere where you see x occurring freely, which is a sign that it's about this x, and that lambda x binds here in t, then you just replace x with you this was the notation for substitution. And then the further rules say that you can't only apply this on the top level, but actually, you can apply it anywhere inside a term. So, for example, lambda x t simplifies to lambda x t prime, provided t simplifies to t prime. And the idea being that this itself is not

11:50  
something that you can reduce by this rule. But maybe tea is such a thing, or maybe tea contains further such a thing. And similar things apply to application. So, you're allowed to simplify both the function and the argument by the rules. And then I gave you some examples, I told the closer how substitution works. And it does pretty much what you expect, except again, you have to avoid captures, you have to be careful when you substitute so that you don't make a free variable bound and I talked about it at length, I won't repeat it here. Then I told you lambda calculus has some particularly nice properties. These are important to remember. One is called Confluence, the other one is called and that's on the next one no further, okay. So, let's take one by one, one is called conference which says, If I can reduce a term t to one term you using some number of steps, but I can reduce the same t also to V, then this and maybe u and v are different terms, then this is no sort of a repairable disagreement, because I can always find the term w such that both o u and v reduced to W in one zero or many steps. So aerostar simply means no steps at all once there are many steps that is a good property. For Confluence by the word is from Latin it means things flow together or to a common sync, so to say, when I told you that an immediate consequence of conferences uniqueness of normal forms, so for any term, if I reduce it into a way that gets stuck in the sense that I cannot reduce further this thing is called the normal form. And from conferences immediate that if there is a normal form that can only be one for a given firm, then I told you that not everything has a normal form. And then finally, I told you about evaluation strategies. That was the last point last time What did what was it about? Well, first of all, in any terms that can be multiple places, where you find an abstraction applied to something all of these are good for reduction. We can choose to pick whichever in general lambda calculus, but under a particular evaluation strategy, I might want to say that I prefer red X yeah irreducible expression like this, which is outermost, which means in the sense that it is not the sub term of any other term that is also red X. So if you take some outermost red X, for example, the leftmost this gives you a normal evaluation strategy, so called if instead, you reduce the leftmost guy at every time that's called leftmost, innermost These strategies are different in that the normal form always sorry, the normal evaluation strategy always finds a normal form if there is one at all. But the applicative, one may miss it. And the example was this term here, where see where omega was a particular term, that in one step reduces to itself. If you use the normal evaluation strategy, all that happens is omega is passed to this function via the parameter x, which means all occurrences of x in y of which there are none get replaced by omega, so we don't get any omega is actually only one is left. And this is a normal form, this is just a variable from here, you cannot go anywhere else. In one step, you have reached a term that you can't reduce further. But the applicative emigration strategy, which looked for the innermost radix, finds the red X inside omega, which is deeper than the top level thing. It finds the red X here, and they just rewrite it into omega itself, which was something that I showed last time. So, in one step, I rewrite the term back to itself. Obviously, in the next step, I can just repeat it and then this goes on forever. And nothing useful ever comes out. That was the end of the story. There. If you weren't in the class, then please do check, because this is important. But now we go to today's topic, which is lambda calculus again.

16:47  
And we add very, very little and then I'll give you a lots of examples of this. So what do we add? Is types. So what is going to happen? In addition to terms, we will have types? And it is a bit like we've seen in F sharp now I'm just making it all a little formal, a little more formal? Yeah, what is the idea of types, the idea of types is, is to tell you something about terms like, you know, this term cannot be arbitrary. I don't yet know what its value is, maybe there's an integer, right? Or I don't get know what what the value of my term is. But maybe I know that this is a function from Booleans, to lists of integers. This is what pipes are, they sort of classify the values a term can take, that is the main idea behind them. This is also how they used here. So they have kind of a discipline mechanism to make sure that everything in a sense, makes sense. Yeah, so you're not mixing apples and oranges together. So if you've got the function that takes oranges, as an input, you will not offer apples, or you can detect that this is happening. Or someone is trying to offer apples to a function needing oranges, just on the level of checking the types. Okay, so term in general is typed with a type. But typically, this cannot be figured out just like this. But this actually depends on what types we want for the free variables unless we looking for something like the most general type. But the typical way that you think of it is you fixed what the types intended types of the free variables are in a term. And that should determine all the rest the types of all sub terms up until the top level term. Now, what are some examples of this? The idea should be something like, when you see a function, lambda x dot x, then that should actually perfectly well work with with Type A arrow a for any type A, where a could be any specific type, like I don't know a type variable or some function space made of two different type variables, etc. So we think of these type variables here as the basic types are here is another one, lambda x lambda y dot x in an F sharp with write phone x arrow phone, why Arrow x. This is a function that takes something of type A followed by something of type B, and returns na. And that actually works for any types a and b. So let's be precise. So these are some examples sort of on an In formal level, but now let's make everything precise. So what is a type and how are types ascribed terms? So first, what is a time? Here, we only allow two kinds of types. So the basic building blocks are type variables. In an actual functional language, real functional language, you will also have some base types like maybe interval or float, but here we don't hear as the basis, we just use some type variables. So they basically stand for any type you could consider. But then, another kind of types is function types, these are types of the form a arrows B, where a and b are already types. And therefore, sorry, where a and b already are types. And this stands for a function where A is the type of input and B is the type of the return value or is the type of the argument these the type of return value.

21:09  
So, similar to similar to similar to so untyped lambda calculus, we have to make some electrical conventions. So, there we agree that application always associated to the left and lamda extends to the closest closing parentheses. In lambda calculus, the important thing as we've also seen in F sharp and that's adopted in most FP languages is that this one associates to the right. So, you may write something like this. But the idea, then behind this, this so, when, when that is when you see two arrows in a row, and there are no parentheses, this means the second and the third guy are taken together in parentheses together with the arrow, the first guy is separate. The idea being here always that these are these curried two plays functions.

22:27  
So here,

22:28  
you say, I've got a function that first expects an argument of type A, and then it already returns something but that is, in turn a function that is happy to accept another argument of type B. So you can use this beast as, as a two place function, or as a type of to place functions with return type C, but but the arguments have to be given one by one not as a pair, isn't it? Okay, let me let me try to give you a few examples. But I need to know, used to Windows

23:19  
different differently.

23:32  
So that's almost good. So some examples of types, for example. So I'm saying we've got type variables, so things like

23:50  
x perhaps, or y would be types. But then also, you can start forming other types out of them. So I can, for example, say x equals y is a type. But I can make more complicated types. Now I can say x arrows, y. arrows, x is also a time. So any of these things will be a time if I just use arrows in arbitrary ways. So different matter what, what kind of terms leave there, as we'll see in very short as we will see very shortly, right? And then the convention is, you don't need to write or parentheses. So for example, here, the parentheses are actually unnecessary. Because, sorry, here, the parentheses are necessary. But these parentheses here are unnecessary because arrow associates to the right so I could, in principle, get rid of those and that would amount to the same thing.

25:07  
Okay, now and this is all the reason is simply typed lambda calculus right you have to take into account that in a real FP language there will be some base types and typically some other type constructors beyond arrow like in F sharp what we know, where we have star, for example, for tuple types for pair types, triple types, quadruple types, I mean any any any tuple types. And then also we have the unit type, which is kind of Mallory types. And then we have lists etc with those we could already see are kind of almost like user defined data types with special syntax. But then also you need to have a mechanism for these user defined data types, which we don't have directly in simply type Okay, from where do terms get types and that goes by rules. And this is something I will have to explain in some detail. The main game is to fix some rules, when can I say that the term T has a Type A and the term T will not have a Type A absolutely if it contains free variables. But then we assume some type environment here called gamma that fixes what the types of my free variables are. So, this gamma here is often called the typing context. And it's a list of typings for individual variable. So, I might want to say that x one is of type a one bla bla accent is of type A n where that indexes are sort of term level variables and a one through a n or any types in principle can be anything this symbol here is kind of a horizontal tea is called turn style. So that's an English word that is maybe not used too often, but it is this thing. For example, in a in a food store, that is often there when you collect your basket and you go through a narrow place something turns around then you can enter the place is called turnstile in some countries, you also have a like I don't know pastures for for sheep. So, people can enter gates, but but obviously bigger animals cannot there are leap Okay. Now, we want to establish these kinds of judgments that the term has type A in some type in context gamma and we want to give rules for this what are the rules lambda calculus is a minimalistic formalism. So is typed lambda calculus about here these are all the rules there is nothing else. So, what are they the only way that the variable can be of type A is that the environment tell so so the environment is a list of assignments of types of variables, and among them, there should be one that says x is of type A, if I want to conclude that x is of type A at all, okay. abstraction is another case. So when is an abstraction of some type abstraction always is of a function type. And abstraction is a function from type A to B in context gamma, if I can establish that T, the body is of type B, in the context gamma extended with one further guy, namely that x is of type A. So if, under the assumption that x is of type A, we can freely choose what assumption we want to make. But if under such assumption, we do get that t is of type B, then we can be sure that in the original gamma that doesn't have this extra Association, we can compute that lambda x t has this time. That's the most complicated rule here. So, here we see a new thing that you also saw in lambda calculus, what does this horizontal rule line here mean? It means you have to read this thing as a rule. If the thing above the line which is often called the premise holds, then the thing of below the line which is often called the conclusion

29:57  
holds,

29:59  
so, If you already established this, you're allowed to say I've now also established this. These are called rules. Okay, and here is another rule. So what is my only rule for ascribing any type at all to an application, which generally then is of the form t apply to you in some context gamma? Well, if in the context gamma t happens to have type A to B, or you can justify that in such a context T has type A to B, then it better be that in the same context, the argument has type A why, sorry, sorry for the blinking. Why? Because the application can only make sense if the functions argument type and the type of the actual argument. They do agree, right? They have to be the same. And then what's the type of the function application or function call as we also call it? It is just the return type of the function of course, yeah, it should be sort of intuitive. But, but the way that you can formally talk about these things, goes goes by rules, which is an idea actually inherited from formal logic to sort of programming theory. Let me give you some examples first on slides, but then I can write them as we go. So, how do I justify that lambda x dot x has type a way where a here is kind of a schematic letter for any type, it could be x, it could be Y, it could be x arrows, y any any type fits here instead of a to age like a meta variable four types? Well, by my rules, how do I justify such a thing, I have to make sure that the bound vary that if I make an assumption about the bound variable with with a given argument type, then I can conclude that the body has the given return type. So, these things are what I need to check. So, let's see. So let's let's, let's make it as an assumption that x is of type A and let's try to conclude x is of type A, that looks trivial because surely x must be of type A, if we assume x is of type A. And indeed, this is the case, not only sort of intuitively, but because we have this rule, which says I'm allowed to conclude x is of type A, if somewhere in my context, that's like the lookup function right? In type inference, as we saw in F sharp, I can find that x really is in my dictionary, and it has been ascribed to type a. So here is a bit more an example that is a bit more complicated. And you can see that what starts to emerge here are what are called byte derivation. So these are formally they're like trees of judgments. Were always the children of any node justifying the parent. Like here, I've got n. So this is a tree that's the route Yeah, there are various nodes and every horizontal line stands for branching. Most branching is unary but at this place, there is a binary sorry, this place here that is binary branching, because this

33:37  
rule,

33:38  
sorry, this concludes this judgement is a conclusion of the rule with two premises. So both of these are sort of children nodes. And of course, they also the corresponding children sub trees, which are very shallow. Okay, so you see, trees emerging, and these are called derivations. And at every stage, the children justify the parent. The fact that we believe in these two justifies that we now accept this but the fact that they've already now accepted this justifies that we also want to accept this the fact that we now have accepted this justifies that it's also okay to accept this. Okay, so this is how you read these trees from top to bottom. At any line, in this rendering of the tree, the lines immediately above which are the children nodes, they justify the given line. You can read these trees, top to bottom, but actually the search for such trees are the construction of such trees goes bottom up, or root first, as people call it. swell I'll develop the interactively for your venue when you see what I mean. But let me first still show this example. So what does it say? That is actually the pipe function of, of, of F sharp, right, because in F sharp we have this thing where I can write, sorry, x f with this funny operator notation. And that one is actually defined, like f applied to x and circle the right left here. And then, but of course, you can do it as an anonymous function. And then we need to just talk about which my variables are and it will be like, in F sharp we would write fun, x arrow, fun. F. paddle FX is also allowed to write shorter fun, x f, f x, but that's the same thing. Now, in lambda calculus, the corresponding thing is just this, which is not so far apart from

36:15  
what we see here.

36:18  
Okay, how is this justified, it wants to have this type A arrow, a arrow B to B, and I've put in these parentheses here, but they are not strictly speaking necessary because of the right assertion. So it really is really like a two place function that takes two arguments, one by one first this, then this, then this gives back this. How do I justify that this is actually a valid typing? Well, this is a lambda. So I put the lambda bound variable with the correct time into my context, and I try to check that the body here has the correct type, which has to be the return type here. Yeah, so let's test to see I'm reading the tree bottom up just to kind of show how I would come up with such a tree. So if I know this is the type that I want to have, then for checking, it suffices to go like this, that as the first step, I say, Okay, I need to see this, then how do I see this? This is a similar game. Now, because I've got a lambda that I want to take with a certain function space, what I need to do is throw this lambda bound variable F to my context, my context grows, right, you can now there are two variables that are free. And then only the body has to have the return type of the function that is the now this line here, is quite different from the from the two below it, because no, I'm not piping alanda. Now I'm typing an application or a function call, at which place I have to be able to somehow say, well, in the industry context, which I use in both cases, sorry. notes into writing, in this fixed context that I want to use in both cases, I have to on one hand, give a type for the function, which is F. And on the other hand, give it time for the argument, which is x. Well, the argument is a variable for this one, it's not actually so hard to give a type because the context pretty much gives me a hint, what it could be, like the variable type doesn't occur anywhere here, this B doesn't give me any clue what the what the type of the argument should be. But from here, I could get a guess that perhaps it should be a. Okay. So x of type A, but then this is to say that the argument type of the function is a and the return type is B. So we really need to check that F has type A arrows B, but it actually also has because in the context, we have already said f has type A arrows B, and therefore we are done. So these two lines are justified by a rule for the variable case, which doesn't have any premises. So here we've done these are like leaves no premises. This was justified by the application case and the last two were justified by lambda cases. There is nothing more often, I don't know students are confused maybe because their notation fields

39:55  
new

39:57  
or unfamiliar, but there is really not a lot going on. So one thing that this kind of type discipline avoids is you can't possibly give types to the nonsense terms like the Omega from the last lecture, which was defined like this. If you're trying to invent any type for it, you'll find out to pump can we can later maybe discuss it a bit more, why?

40:24  
Okay, here.

40:29  
And there is a further example of pipe assignment, but maybe I should actually do it sort of interactive instead. So let me just copy the last line. And then let's look at it as it develops lambda x, lambda y lambda

40:48  
x, y Zed.

41:08  
Okay,

41:09  
so I want to do this. And now rather than showing you the example, I'll show you the rules.

41:19  
So,

41:20  
this is the example we want to develop these are the rules of the game. So, how on earth can I derive this thing? Well, this is first of all lamda. So, I only have one choice I have to say, I will work with a context where now the lambda bound variable is my only assumption that they may it's the assumption is x is of type A arrows B arrow C. And then in that context, I need to derive lambda one lambda Zed x, y, Zed, which will have to be of type a aerobie.

42:18  
Now what can I do next? Actually, I'm in a similar situation as before, because this term here, this one here is actually lambda. So I have to say, I know want to extend my context with y, which is the lambda bound variable and there I will put the knowledge that I will now assume that y is of type A or ob, whereas the body is of type A arrow C. So this is what happens next.

42:57  
Sorry.

43:06  
Then I draw the turnstile sign. And I will have to say that the rest of time. Yep. What else can I do now? I'm still in a similar situation, because there isn't yet. You know, there is yet further lamda to deal with. So what should we say? Any suggestions? What needs to go to the context next with what type?

43:46  
Just shout. I will Meanwhile, right? Or the part that is already there.

43:59  
Now what else do I need to say? The number one variable is Zed. Right, so I'm now gonna check if I can type the body with Type C, under an additional assumption that Zed is of type A, isn't it? What is the body? The body is everything else I see here. Namely, fix. Now we're in a new situation. Our term on the top level is no longer a lender. But it is an epic application, isn't it? So I have to use the rule for application which is this one here. That is a bit more interesting. And that is perhaps I'm guessing to be done. Actually

45:15  
a little bit differently.

45:20  
Let's give this thing a name. The the current context, I'll call it gamma, then we will have less to write in the future.

45:29  
So let me call this gamma. Yep. My task now will be to show two things. On one hand, that gamma, derives, exit in some function type. Because that's the function here. And on the other hand, I also have to say gamma turns fine.

46:01  
Why is it in some argument type? About the function type, I actually know pretty well. Sorry, not about the full function. So I know the return type, the return type must be seen, isn't it? Look here, the conclusion is B. So therefore, in the first premise, I also I need to have a function space. And the return type must be B. But I have no idea what the argument type should be. I only know it has to be the same as here. So maybe I just put question mark for the time being.

46:43  
And then we'll see

46:45  
if we can do any better. Maybe now we already can, because here is the function application again. And what do I need to make sure to pay for this thing to have a Type B, the function has to have the type eight arrows B for some suitable a, and then the argument has to be of the same type A. So let's check here in gamma, I have to have some type for y in gamma, I have to have some type for Zed. And then I will be done. Within What are these types? Well, in gamma, we actually do have a type for y, which is a arrows B. And then by the variable rule, we can actually use it. So we can say, we know under gamma that y has this time. And actually gamma also contains Zed. You can see here and ascribes type eight with. Okay, then we are actually with my two premises, we are in exactly this form that the function here has of pi as like a barrel B, and the argument has type A, of course, the coincidence of letters is purely coincidental here, and therefore, the results should have by B as well. So now I can make my question mark, I can be more precise about my question mark, people have to be and that one was the question mark for the same thing. So that's also be okay, so we're in a somewhat better shape. Now we have to still finish this part here. So we have to check everything is good here. So that's again, an application. So let's see, in gamma, I have to ascribe the type to x and also to set and this will go by variable also here, we will already be done. Now, x is of type A arrows B arrow C in gamma. So there is no choice about what the type of x can be.

49:11  
What a set has type A in the same context that's visible here. Right? No, I'm making a mistake somewhere. No, not making a mistake anywhere. It's perfect. Now, because the argument type is a, the return type is voc. So therefore, the function type is a arrows B arrow c, where you can think but you don't have to write that the parentheses are here. Yep. Is this agreeable. This must be what is actually on the slide than done in exactly the same way. Okay. So, this is kind of an exercise by complaint with

50:05  
I will

50:07  
do more of these right now, rather let me say tell you two properties about this type system and then we can take a short break. So, one very important property of this type system called typed lambda calculus is what is was historically called subject reduction property. These days people like to call it type preservation property, which is maybe more telling this means that these simplification steps by which computation of terms goes called beta reduction that we saw last time, these preserve the type of a term, what do I mean? I mean, if t takes type A in context gamma, and you can simplify t in one step to you another term then you must also take the same time. And this is a super useful property, it basically says during computation types of things cannot change. So, therefore, if everything was well typed, you know, if your programme was well timed, nothing can go wrong with it type wise during computation during execution, so to say. And in practice, this means that you never get these kind of methods not understood or wrong function argument type messages because typing is exactly about this, it's fundamentally about making sure that if a function expects an argument and is given an argument, then the arguments type agrees with a function type. This is pretty much everything that that that the typing is about I mean, there is more Of course, when you have polymorphic typing, then we also talk about type instantiation, etc. Like if you use a polymorphic function, you're really using an instance of it, you have to form correct instances, but we'll get there. So, so this is a property that is required in any reasonable timed FP language. It's called subject reduction of type reservation. The name type reservation is pretty obvious from the statement that you have a type you reduce, and the same type is preserved. Subject reduction comes from an older terminology, which was like if you wish from ganar. Sometimes the term in such a piping is called the subject. And the type is called predicate like in natural language, if I don't know when you say john loves Mary, then john is the subject and loves marries the predicate. So here the same idea. So it's about reducing subject, and keeping the predicate so to say, That's the meaning of the word. If it sounds strange, it does sound strange. Okay, that's one property. And the other one I wanted to show is, that is what makes typed lambda calculus radically different from untyped is every term has a normal form. So you can't write nonsense terms like omega, where you're trying to apply a thing to itself, which is then funny, chasing your own tail, if you wish. And not only has every term a normal form, actually, this type lambda calculus is strongly normalising. And well, one way to see it as soon as you know that every firm already has a normal form Previously, we said reduction or evaluation strategies don't matter, they will all give the same result. So now if you know if one of them gives a certain result, they all must give the same. So the calculus is strongly normalising, which means whichever evaluation strategy you will take, will compute exactly the same normal form. Now this sounds like the best place to be and kind of Garden of Eden but there is still a trade off here because it's sort of is a is a very nice, safe haven Nothing can go wrong with computations here. You can take whichever evaluation strategy you please maybe driven by some performance considerations and which one you can implement better. But sadly, in real typed FP languages, even if they're strongly typed in languages like F sharp this this Prop, these properties are lost. So, it may very well be that sometimes terms may reduce infinity. So and then therefore, not not not reaching normal form in a in a in a reduction strategy. How is this possible? This is possible because very often in such languages, you have some general recursion mechanism as primitive Like I explained, last time that you can express left via just lambda terms you don't really need left. If it's an ordinary left, also function left but as soon as you have a recursive function that is a different game, recursive function lead cannot be expressed in terms of other constructions in a pipe language. So if you want to add it, you have to add it this primitive. And then it's possible to add primitives with their own reduction rules such that these these new primitives, they give you non non terminating behaviours, terms that reduce infinitely. So that's something to keep in mind. In real languages, you have recursion given by lack rec, or loops or some other such Turing complete mechanism. And then these properties lost. Which is good for sort of universality of computation point of view. But it's bad for like, sort of clean software engineering point of view. Okay. Another thing that also happens in real life is this nice result, the different evaluation strategies give you the same normal form. They also don't hold or sort of more finer, they can give you different effects, especially and therefore also, in some cases, different normal form. In the end, especially if there is something called effect handling present, like handling of exceptions. So we saw this example, last time I showed you addition together with printing, so if you there have a different evaluation strategy left versus right most, you don't get things printed out in a different order, even if maybe the final number that your addition returns is the same. So it's the same, of course here under the type discipline. So you could say, yeah, this is weaker than via languages, but in some sense is good, because it isolates a very sort of strong core, or a very safe core. And then you can add little other features, one by one, making sure that you don't go too far from this sort of safe at the end nicety so that you really have strong properties of your language in terms of what you can guarantee. That's how much I wanted to say before the break, but do you have questions perhaps, because if you did, you'd be so nice to discuss. Let me check what is going on here in the real world. Can you give me some reaction of any sort.

58:16  
This we're still here.

58:18  
You're still there. That is good. That's good. I'm also here. I don't want to do so much else. After the break, which could perhaps be until 320 I want to add polymorphism. I want to talk more about this topic next time showing what you can use it for. But but for for this time only just show you what changes. If you allow. So generalisation and instantiation of types, you can then type more. And all these funny things come back that were not allowed before, but but it's still a far more discipline settings and then pure untyped lambda calculus without any typing discipline on top of it at all. Okay, so if there are no questions, let's take a break maybe five minutes until 1720 and then maybe you can continue for another 2025 minutes.

59:33  
Okay. I'll be back in five minutes. Okay let's continue where we stopped here, let

1:04:46  
me share Sorry.

1:05:08  
Yes. This is what you saw before. We finished off with simply typed lambda calculus, just type variables functions basis. And I told you, the ideal system is strongly normalising, which means whichever evaluation strategy you will take, you will reach

1:05:32  
a normal form with your term. Now let's do polymorphic lambda calculus. This is also called system F, this is a historic name, and doesn't mean much, maybe f was for functions.

1:05:57  
It goes a bit closer to the F sharp type system and actually goes beyond it in the sense that it's a more expressive type system. Now, when it comes to generalisation and instantiation, works under a very liberal discipline. So in system F, we are allowed, in addition to just type variables and function types, we can have types of this format, I have to explain this. A is a general type, x is a type variable. And this upside down a is called for all i think it literally stands for all the A stands for all. And you should read it as you know, something that's like a where a contains x, and instead of x, you're allowed to put anything you can think this x is in tool, whatever some other functions face. But of course, we don't have int and bool here, but but but for x, you can put any type. So this is a way to say that what you've done is is fully General, in some sense, we have it but only on the top level, in the in the in the calculus that we already had. For example, here, we concluded that we have this type for for our huge term. But really, if you think of it, we don't use anything particular about the types a and b and c. So a in particular could be maybe x or x and B could be x arrow Zed and see could be Zed, everything could be anything. So literally, in some sense, this thing has a much stronger type, it has the type for all x for all y for all Zed x arrows, y arrow said, arrows, x arrows, y arrows x arrow Zed, we could say we've actually established this because we've not used anything in particular about A, B and C at all. But this is kind of an uninteresting form of polymorphism because it's only on the top level. So we can say okay, my mind I can I can generalise the type of my term. But kind of, but I cannot internally use anything in my term that I would have thought of as polymorphic. This changes in in polymorphically typed lambda calculus, because now I can write different types that use this for all all over the place. So for example, I could write things like for example, the following could be a type, I could write a type that says for all x, x i was x arrows.

1:09:01  
What do I want to say,

1:09:04  
for all x x x equals x, for example, so that's different, because now I can use for all also deep inside my, my my my type expressions, right? That is not in any sense allowed in when just simply tackling this polymorphically typed lambda calculus allows us will now see examples of this. So what happens here is on the level of piping rules, we only add two new piping rules. And these are interesting and maybe dangerous sounding, looking piping rules because previously, for every term construction, I had a rule for variables. There was one rule for lambda abstractions, there was one and for applications there was a third and you could clearly see See, if you constructed the type derivation when to apply which rule because the shape of your term, you know, the topmost constructor will tell you that, sorry. This is not the case here. So, if you look at these two rules that we now add in both cases, in the conclusion, I have a general term t about which I make no specific assumptions. Well, something is specific, though, so, so here I have a for all in the type, so the rule only applies if you really bottom up when when the type is a for all type, the universal type then, when am I allowed to, to conclude the T has time for all x a, you're allowed to conclude it when actually T has type A. And remember, a can contain x, when x doesn't occur freely anywhere in gamma. This basically says, I'm not the X in my type is not constrained in any way. So, therefore, it is meaningful that I say, you know this T has typed this type for all x. I will see examples of this in a sec, but let me just comment the other rule. The other rule is kind of for the opposite. So, this one is called generalisation, maybe I should have written it down, because you say T has a type and now you say it has a more general type. And we saw a bit of this in in the F sharp polymorphic polymorphic type inference. Now, I'm essentially sort of explaining what is going on for me. The other rule is what corresponds to instantiation. It says, if T has a very general time for all x a, then it actually has also all of these instantiations that you can make of it, which you can obtain by taking a and replacing x with B. And doing so, actually, you're not supposed to accidentally bind any free variable in B. So I should actually say this rule also as a side condition that the free variables of B not bound in a don't get boundary. Okay. So, what are some examples of this, maybe I should just write here on the side. So, I could for example, have something like this. So, if I have established for example, my gamma perhaps says I don't know why gamma perhaps says some x is of type for all, capital X, X Arrow x. Maybe wine

1:13:13  
has the type

1:13:17  
maybe just for all yy with with crazy, but it's okay. If in this situation, I can establish that some type T

1:13:33  
have it has the type say that URL w then I'm allowed to conclude that I can put the universal quantifier in front of the set arrow w so in the same context

1:13:50  
I'm allowed to conclude tea has type say for all that said no W and maybe I can even further generalise and say it also has type for all w that sort it is a capital X.

1:14:34  
So these are allowed generalisation steps, but of course here T has to be something specific and here there must be some sort of a justification why it has this type. So this is valid generalisation. Why was it valid? Because Zed or w didn't occur free here. So if that were free here, for example, Hold on,

1:15:01  
let me find this

1:15:04  
guy just feed it to a charity. So suppose my type here would have been zap arrows x. Now you can see that the type variables that is free on the left. Now I'm not allowed to do the following. So this will not be okay. I cannot conclude

1:15:47  
let's now T is of type for all W. Because that is there is now not free for generalising, because we actually make some assumption about the type set, we say there is a very, very, very variable x depends on some set, which is free. Yeah, so it's controlled independently. So to say that now here at this point, we want to privatises that, and at that point, this that would be a bound variable. Whereas this set is still a free type variable. And then it will turn out that the type of little x, which is in terms of the capital Zed and the type of little t which is in terms of also the capital Zed but somehow a different one, then they would have nothing to do with each other, but T will reasonably contain x, I mean, T is not just the variable here these a name for some big term, then, this is no longer justified because morally these two sets now are different after this step.

1:16:57  
Okay.

1:17:00  
So what are some properties of this calculus? a crazy thing is that you can now type quite interesting terms, among others, this famous thing that is called self applications, you're allowed, for example, to type the term lambda x, x dot, sorry, lambda x x applied to x. Yeah, this sounds like crazy because

1:17:36  
we are applying a function to itself. But it's meaningful if x actually has a polymorphic type, if we think of x as little x as something, which actually can obtain multiple specific types. So here is a valid type derivation, which maybe looks crazy. I'll also read write the manual, then it will look here. So what I'm doing here, we're following the rules, we are trying to assign this guy, the type A arrows a, where A is not no longer a meta variable, a is actually just shorthand for this specific thing. So we've taken the time x times x, and we've said, for all x x x, this is a but so really, officially, I should maybe write this thing instead of a everywhere, but let's just use these abbreviations. Because otherwise, it would be huge that the whole little three times this one, I have to assume x is of type A, and then I have to conclude x applied to x of type A, at this moment, this sounds completely crazy, like, Okay, if x is of type A, how can I then get an X applied to x is of type A, because if x is of type A, then the argument this x here is of type A. But then if the result also has to be of type A, then clearly this x the function has to be of type A arrows A, which is not what we've said. Yeah, have we know, we've said that x is of type A, that's the only thing we say in the context. But now let's, let's see if we can take it. So against all odds. So what did we say we just need, we need that the argument is of type A, which we can justify that's here. Because our context tells us x which is the argument is of type A, that is fine. But then we also x is also in the function position, we have to say, as a function it has to be of type A arrows a because the return type is eight. The argument type is a. Now that looks crazy, because my context says x has to be of type A, and then I want to conclude x is of type A arrow say but look It is actually not. Because I can get from here to here by specialisation or instantiation. Because what does it say it says whenever something is of type for all x a, for some A, then I can take, I can get rid of the universal quantifier. And I can just replace in a x with any B. In particular, actually a itself also works. So, so this step here from here to here is a case of instantiation, we use the fact that a is this thing. And then we just take the body here x arrows x and replace x with a. Now, if an X that was x, you replace x with a substitution, you do get a yellow say, this is exactly what I've written here. So, that's a bit of a surprise, and maybe, maybe sounds crazy. I ready to talk properly, then I show you a different version of it, which maybe doesn't sound too crazy. And that's, that's the one that F sharp will actually use today to derive a type right. So F sharp manages this.

1:21:38  
But it comes with a different type. So you can do some crazy things, you can do very crazy things, you cannot still type omega, which was the nonsense term, that which when you started simplifying, it gave you back the same thing immediately. So this one cannot be typed. The argument that it cannot be typed is quite complicated, but you can just trust me, it can't be typed. So so we are in a system now that is stronger than than simply typed lambda calculus, where the for all is not present. But it's still not very strong. Real FP languages go in a bit of a different direction, so they allow for all but not in every position. So F sharp, in particular, allows you to generalise functions that you've different that you've defined by Latin lectric. These can be generalised. But before they apply, they have to be instantiated again. And we'll see this. So F sharp is really a bit weaker. But then it's stronger in other aspects as far as I told you. So I mean, for example, it allows rec, which this one doesn't allow directly. And it has all these side effects like printing and exceptions. And printing in particular gives you different results under different devaluation orders. And handling is something that you can't express in, in, in sort of lambda calculus simpliciter. Okay. Let me give you the properties. This actually is the last slide before I want to go on to another topic, which we'll do next time. But the good properties are still there in in this very liberal system, subject reduction still holds despite this type system being quite crazy. So if a term has a type under a context, and you can reduce it to another in one or many steps, then the term still has the same type. And a strong normalisation also holds. So if you've got the type of a term, not just any term, of course, but the type of altar, then any reduction sequence of T terminates, and after normal for so whichever order you evaluate, you get to normal. And therefore, every term has a unique normal form because we also had a conference for which we haven't lost because you haven't changed the terms. Okay, let me quickly go back to this example, because I want to show it in in a tiny bit more detail to illustrate what happens. So, what is we have here we are talking about this term, which I want to type like. And what happens here is we use the lambda rule at this point, which tells us put the lambda bound variable in the context with its type which is a and then try to derive the type for the body which is x times x, x x applied to x sorry, return type, which is this.

1:25:04  
That's all good.

1:25:06  
Then we have the application rule. The application rule told us what. And this is a place where we can actually do slightly differently. So let me move into some space. Application rule says, in the same context, I have to type the function and the

1:25:29  
argument.

1:25:32  
And let's try to defer using generalisation and the instantiation as long as possible and think naively. So this x here is the function. Step one. And the other x is the argument is that one. And about Sorry, I'm running ahead of myself. So I want to say I need to pipe this x, which is the function and this x, which is the argument somehow, so that everything fits about to a function, I know that it needs to return something of type A. Because that's what comes back here of this place right? Now, but the argument, it's easy for me to just use that x is of type A, because this is what I get from the context directly, and then here, I will be done. That didn't mean to use generalisation or instantiation in any way. As soon as I say, I want my argument to be of type A, you have no choice than the functions, input type or argument type also has to be a. And that is the strange place. Because if you just look at these things, we see no agreement. But then, remember, we know in the context x being of type A, we can derive x is of type A. And let's just simply look at what A is a, by what we agreed is. It's not just a meta variable, it's actually an abbreviation for this concrete thing. Yeah. And then we have the essential is the association rule, which says

1:27:41  
that I can replace x here with anything. And in particular, I can choose to replace x with a. So I can take this thing x that was x and replace x with a, hey, what do I get is exactly what I have here as Ray. So I've used all the right tools. So this was the variable rule. This was like the lambda rule. This was the application rule, I call it up here is the variable rule. And this is the rule that we could call instantiation or specialisation, people also call it is this fine? That is actually not quite what F sharp does F sharp morally uses a different derivation for the same that is a bit more systematic, because this looks like a real rabbit out of the hat. So what happens there is is more of the following. And you can see if we can do this, okay. Okay, so

1:29:30  
cool.

1:29:31  
Okay, so let's edit it a bit. So it actually does a bit differently. Namely, at this point,

1:29:44  
here,

1:29:48  
I cannot really use anything as a function in a function application. I can Only use monomorphic types is a polymorphic type because it contains fraud. I mean, this is here is the definition of a. So it will actually specialise at this place.

1:30:18  
Something else will happen compared to before. I can go from here to X being of the type capital X, narrows x, y, because this ad here is after all just for all x, x arrows x, isn't it? And this guy after all is just

1:30:50  
x arrows x. When I have done no interesting substitution, I've just replaced x with x itself. Yeah, so I can go from this polymorphic type to a monomorphic type where I just say x is a function space from x to x, and there is no universal quantification here.

1:31:17  
How could I then continue? Well, at this place here, I need to use generalisation going over the space. So here I am in a context which is closed, it doesn't contain capital X freely. So therefore, I can replace this guy by x x. x applied to x has to be in the type x narrows x. In this context, x is only at this place, I tried to use the application now.

1:32:08  
This was instantiation.

1:32:12  
Now I mean a bit different situation than I was before. So here is an application. The return type is x or x, the argument type is X or Y axis, we just decided, therefore, I need to show that the function is of type x Arrow x. And now I'll write something different from what was before. Namely, instead of this guy, I want to write x Arrow x Arrow x Arrow x. That's the type I want to give to little x as a function. Now my letters are maybe not great, is equipped maybe a confusion between small and big X's? This is a small one

1:33:03  
really small.

1:33:06  
Okay, from where does this come, I could get it from the old place, but not replacing x with a but with a arrow z.

1:33:22  
Okay, with x equals x. So that's what this guy here is. And then this is instantiation that is applied here. Okay, so this is a full derivation in a different way. And maybe more systematic. So

1:33:51  
let's see again. So here is an application and application is given a polymorphic type that's not accepted. This application should be something of a more specific type. So we actually use generalisation I can use it here with with x capital X, because it doesn't occur free on the left, capital A is for all x, x or x. So x here is bound. Okay, then my task is to, to make something like this happen. So one cheap way to do this is I say, Okay, I can instantiate a to x Arrow x, why not? It's allowed. And then nine needs something of this function type and it perfectly works. And that isn't the the mechanics of it. Okay, I think for today, this is quite a bit and maybe Yeah, apparently, especially this is getting a bit complicated. But next time, we'll have plenty time to discuss this closure. So next time I'll want actually to show and this is where we don't go right now that you can encode data types in this polymorphically typed lambda calculus. So that's one of the reasons why people say, lambda calculus really, in the core is everything you need to do functional programming. Namely, you can code up here things like Booleans natural numbers, if you wish, lists, option types, any of these data types that you see in in FP languages and similar also record types. And tuples are closely related. So while this looks like very minimal, we only had these three typing rules plus the two new ones, it is actually super super powerful. Okay. How about

1:36:12  
questions?

1:36:34  
Anyone there any question? Or is this reasonably?

1:36:40  
We have no questions.

1:36:43  
I'll try to do more examples next time as well. So it's not only like you know, bright lines, but I'll try to write something as I go simply to to show a bit of the dynamic of it because if you just look at the constructed tree, it looks like a given Yeah, okay, it is there before where did it come? Okay, but then if we are done with this, then this is good. Tomorrow. A whole lot of the lab sessions will actually run in the hybrid mode in the sense that you can go to school, I'll send out an announcement right now about the exact classrooms. The two last sessions will be of the day, we'd be by zoom only, but but the others who can go to can also go to school and meet the TA which may be is can be more efficient.

1:37:41  
Okay. Then, if this is it, well then I say goodbye for today.

Transcribed by https://otter.ai
