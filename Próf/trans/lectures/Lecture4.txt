0:43  
So let me start, This is lecture four, this is the last lecture on F sharp, we'll come back to many features of F sharp, also, of course, later in the course. But this is the last lecture in this in this crash course. So we've already seen quite a bit, in particular complicated things like lists, and also general user defined data types. Together, we look at the different form of interesting types, which are record types. And we'll also look about something that we haven't seen so far yet, which is the first non functional feature of this functional first language, F sharp, namely mutability. Sort of in a controlled way, we'll see it on the example of references, which are just a special case of record types that are provided to you in F sharp, you don't have to define this type yourself. But records use mutable fields. So for the first time, now, you will see that you can have something in in F sharp, that actually changes its value in a computation. Previously, we only had immutable names for examples of names can change their value. Okay, so let's start I'll share my screen. Just a sec. Alright, this is Leo, thank you. So let's define that you want to work with today.

2:29  
Let me

2:38  
also open it.

2:46  
So now we're all set. What are record types, records are quite a bit like tuples. So the idea is to group together a bunch of values. So that you can work with not only with, with with with basic values, but but groups of values. Differently from tuples. components in records are identified by field names. In tuples, you can talk about the first component of, say, three tuple, or the second or third, or the first component of a pair. And the second component here don't go by this numerical position information rather, every component in a record is identified by name by field name. And the way that you state record types, is like this, you can make type definitions using their keyword type, like a used for data types are discriminated union. So it's the same keyword, you give the type name here, I want to define a type a record type person. And here is sort of a type expression for records. Then, the symptom here are braces, then in braces, you will have something colon something some number of times where there's something to the left of a colon is always the name of a field. And the thing to the right of a colon is the type of that particular field. So a person groups together a string and an integer. But for the string, you don't say the first thing you say is the name. And for the integer you don't say the second thing you say is the age. How do you make values in a record type? Use record expressions. This syntax is very similar to the syntax for type expression, except in colon, sorry, instead of a colon. In many places, you see the equality sign. Otherwise, it's similar so that a brace This is to the left of the equal sign, you use your field names. But to the right of the equal sign, you put the value that you want the field to have. And everything by default, this is again, the mutable. So So here, for example, I'm defining a main j, this name has a value person. And there are these teams. And they don't change. So the field, john of J is sorry, the field name of J is john and the field page of J is 35. So let's play a bit with this. So let me check about J. So here it says, J is a person, that's the type. and the value is this. Very important to stress again, you have to make a distinction between the colon use and the equality sign use, colon indicates we're talking about the record type, quite the sign indicates with, we actually have a particular record. Of course, you don't only want to put together records, you want to take them apart, you want to do field selection. So there are several ways to do this. One is something that might ringabel from object orientation. So if j is a person, I can, of course work with It's me. And it's john. And I can just use the dot notation to access it. So the value of j dot name is john, I can also ask what the

6:51  
value of

6:52  
j pages is 35. So So clearly, then I can use it. Such a thing in j dot name on on the right of equal sign in by defining when I defined some name, like n. So that's one way to do the field selection. You can also use pattern matching. So here is a typical example of that. So maybe I'm interested in extracting the name of a record, my record is J, they want to call the name n. Similarly, like I did here, just different syntax for this. One way to express it is this, I say name is n in the pattern. But about the age, I don't care solely on the score. If I do this, I get to know that n is john. Yeah. So n is defined at this stage. It's a new thing in the scope. And I could similarly extract actually name and age both if I care about them. So this is like defining two names at once. So maybe we call the AJ. And then I've learned both. I can also, instead of underscore, it's also possible to just mention the fields you care about. So rather than giving, indicating all the field names here, I just indicate the ones that I care about. And I can do the same thing. Let's do it also for name.

8:39  
Ah, that is faint. No reason at this stage may be completely surprising. But that reason actually happens to do with something else that I that I have here in the loading time. Namely, I don't only have one record type person, I also have a record that record type person three and another one, called person five. And they happen to have also field name and name as part of the type. Now, when F sharp sees this thing, it doesn't, at this stage know whether the pattern is for the value of type person, or person three, because I've given too much too few clues to to F sharp to figure it out to F sharp type inference to figure it out. Of course, J we know is person, but F sharp wants to check that the left hand side and the right hand side here agree by type for the left hand side is not sure what we meant. So maybe we meant person three here. So that's not good. But I can fix it by writing something like this. So I'm saying yeah, it's it's indeed about About the record, but, but it's about a record of type person. And then so now I've defined the name and and it's still john. Right? So remember, then, where was it? The j is, is this particular record. One thing I'd like to emphasise to you is that the order in which the fields are listed in a record is irrelevant. So this is one of the major differences from two booths when tuples. Everything goes by position, since there are no field names, really where you are in the tuple is very important. Here, since we can identify components by name, holder shouldn't matter. And indeed, it's designed in such a way that it doesn't matter. So here is a different record, or it looks like different in principle, or maybe even a different record of a different record type, because the fields come in a different order. So I'm saying here's a guy who has aged 35 and named john. Yeah, whereas Jay was defined as something else named john h five. If, if I ask F sharp, are these equal, then there are several things that could go wrong, maybe they are from different record types, maybe this they are from the same record type but not equal. Let's test F sharp didn't complain, it didn't raise an error, which meant means they must have been of the same type, otherwise, you can't do comparison. Moreover, they will literally the same records for F sharp because F sharp says yes, this comparison gives as a result, Boolean which is true. Now hear something else, I can also define the new record by giving the fields in the wrong order. So if I say something like this, I don't get the record of type person with the fields name and age properly defined. And you can see when this person is pretty printed here, actually, the fields come in the sort of canonical order, which is the order in which I indicated them in the type definition. Does it make sense. But then, if I tried to cheat by, for example, saying something like this, that I want K to be some record that has exactly one field, age 12. Or maybe I mean that there are two fields age and name, but name is somehow undefined, then F sharp will complain loudly. It somehow figures out that this is potentially a record of type person, because I don't have any other record types around here in my file, that would have a field age. So he thinks this must be a record of type person, but then I don't give a value for the field name. And that's, that's an error. Now, here is something interesting. record types may be recursive, like we had data types that were recursive, right? We had a person data type that had students and teachers. That was not recursive, but we had lists and we had trees and they were recursive in the sense that

13:32  
a tree can be made of other trees here, I can have a person or a form of a person, record type, that can have fields that are other persons, or more precisely, something defined of other persons. So let's see, let me define another record type, I call it person three. for lack of a better idea, it also has a field name, name, but then there are two other fields father and mother. So field name can take values of type string, father and mother are fields where this recursion thingie occurs. So Father, and what really should be a person. Yeah, and the mother as well. But think now, if a person has a father, that person will also have a father and mother and that those will have their own fathers and mothers. So if we don't use option here, it looks like only possibly persons would have to have these infinite answers and says drills. Where do we go all the way back? Even past Adam and Eve. That's tricky. So we should leave the option that we define a person but just don't indicate it's father or mother. And we have the option data type lists. Now that's great because I can I can do Interesting definitions, like I can say,

15:03  
J

15:05  
is such a thing, let's see what happens, I get to know that j is a person three, you know. And the fields have these values. And there is even some nice at the end, instead of showing that Father has its value none. This pretty printing shows now. So it's really like no value on the finiteness per se, in, in the sense of null pointers. Yeah, if you could think of a record, or a recursive record that somehow laid out. Let's try to do something interesting with it. Let's make another person let's make a daughter. And let's let let Yeah, let's let let john have a daughter. So I'll define k like this. That's quite nice. So I get a person whose name is Mary. It has a father, or she has a father, I should rather say if your information is given, so we know that the name of the Father is john, but we don't know the name of the grandfather of Mary from polar site, neither we know the grandmother. Neither do we know the grandmother. And we don't even know that the mother who is Mary's mother, Mary does have a mother but the information is, is not provided. Now I can do field access, and I can do cool things, right. So of course, I can write stuff like k dot name, which is Mary, I can also do k dot father. Sorry, k dot toddler. Maybe I'd like to know case father's name.

17:08  
Okay, what will happen?

17:13  
To extract the name, I should have something that is of the type person three, or maybe person five or whatever, or even person that has that as a field name. Name. But case father is not really a person. As we can see here, it's an optional person. So directly like this doesn't work. But I can use the function get from the option module, which is well defined when I have a real value, and then it extracts it. And it just gives a pattern match error, if I try to extract the value from an optional value, if the value is not there, so we could do the following thing we could do option get.

18:06  
Okay.

18:12  
So now I'm just closing my eyes and trusting that all goes well. So I don't know. Favourite priori, if case father is some something, or none, some none. But let's hope it is some something in this particular case it is we've already seen it. If it is the case, then I can go and extract this guy's name. semicolon, of course, and I can see john. So this is already getting a bit more complicated, but it does work. So I can use this dot. Also, if to the left or the top, I have an expression, not just not just an A right. But of course, this expression should have a record as its value. Otherwise, I can't do field selection doesn't make sense. Let's do some more things. Here is something really cool. That is not purely functional anymore. What is is I'm defining another type of person, person five. So persons five have a name. So that is a field name, name. And the fact that I've used the same field name in so many record types is the one that no one then confuses f sharps type checker because it just doesn't get enough hints from me which kind of person I'm having in mind. But but this is legal to do it like this. I mean, you can You can use the same fields naming different record types, you just have to be careful. But then it also has a person any person five also has a salary. So there is also this field name salary here. And the salary is always an integer. These are not Icelandic crowds. But the salary field is mutable. While we were not supposed to have anything mutable in functional programming, but F sharp is only functional first. So there are imperative features here. So, part of our you know, the big thing about imperative programming is that you work with language constructs, whose meaning is that you change the state. Now there is there is the idea that there is something there containing values, where the values can actually change that can disappear, and the new value will appear in place of the old one. So, destructive update should be possible. And that's exactly what mutability here means things can change. So I'm making a new definition, I make j not to be a person anymore, but the person five, then j becomes j is defined as a person five. His name is john and salaries 5000. I can, of course, extract j salary. I can of course, do any arithmetic operations. With it, I can maybe give a little pay rise. But this doesn't change j salary, I just calculated that. If I added five to it, I will get the number that is 5005. But this doesn't change to a salary.

22:10  
All right. Now, of course, I can't write anything like j salary equals j salary. plus five. I can write this with equal sign. But this is just a comparison, which is false. But if I tried to define or redefine j salary, this is not a good idea. Right? Yeah. So this kind of syntax would be legal if j was a namespace or module, but j is a record. So this is nonsense, you can't write such a thing. So you can update the fields in a record that has mutable fields, but that goes with a special syntax, I can write the following thing, I can actually give a much bigger pay rise, I can increase the pay by 10%. Using this wonderful syntax, which is an arrow pointing to the left. Now, important equals you cannot use here you have to use arrow pointing to the left. What is strange, there is no let so it's not the definition. Yeah. Previously, we only had definitions and expressions, right? They could define types, they can define names of values. And then add expressions which I could evaluate based on values of other things that already know. This one is not a definition, it is an expression, which actually doesn't return anything, as you can hear, say, See here, it returns the single uninformative value of the type unit. And remember, the type unit is something that in some other languages, would you you would call void. It's a type that has exactly one element. So in that sense, it's not completely empty. But it's empty of information. Yeah, if somebody tells you my element in this type is empty parentheses, you've learned nothing because you already knew it, there is no

24:19  
music.

24:21  
So no information about one element. logarithm base two out of one is 01 element, no information. This is something now very particular to to, to to this phenomenon of mutability. Generally, expressions of type unit are quite useless in F sharp when you say purely functional Because it's not quite true, but but but also, because when you, when you computing something of type unit you're not computing anything, the result is known in advance it will be the empty tuple or maybe not termination or maybe an error. If, if the expression gives a runtime error for some reason,

25:22  
but

25:27  
but the point with with these things is something that doesn't return anything in a non purely functional setting can have a side effect. And here are the side effect is under the hood, the secret change has happened, namely j salaries knew nothing is returned. But Jays salary has changed to expressions that have typed unit. So they return nothing interesting. These expressions are often called commands. And they are the exact analogue to commands in imperative languages, or maybe also call them sequences, sorry, statements or instructions. This is a synonym, but I'll talk about expressions versus commands. This is the first place where we see commands and now I can ask what is the value of,

26:15  
of J.

26:18  
J, remember, was a person five. And it was defined like this, I never redefined redefined it, I don't have any kind of a new lead j here. So it's not like I've shadowed out the previous definition of J. Instead, it's kind of very same j, but but the value of F or its field salary has changed. I can also of course, directly now ask, what is what is what is the value of this field. And I can also, of course, write something that looks like quite imperative. Now I can, for example, let's forget it was 5500. I want F sharp to do the computation for me, let's give this guy for that pay rise, maybe by 70. This is now also legal syntax. As long as you use arrow to the left. You see, nothing is returned to us. But if I go back and ask what is J salary again, then it's 5570. Right. So this completes one part of this lecture. So we looked at record types, these were analogues of two types. The big difference being that instead of indicating or referring to components, positionally, like by where they are in a tuple as a structured value, you have access to components by field names, that you sort of declare at the same place when you're defining their record type. Now to something else that actually uses record types. And a particular polymorphic type of records are called reference references, or pointers. I should also say some people like to say pointers. So this is predefined for you. And there is some handy syntax that you cannot define in exactly this form, by yourself. But you almost could you could define your own to the version of the reference record type without any problem, but not exactly that syntax around. So what's the idea of a reference? intuitively, a reference points to a memory location holding a value that we hear called contents of some type. This is a strongly typed language, you should always know what type of value you're holding in that location. The way that this is implemented in F sharp is morally by this kind of type definition. So I'm not writing it myself. It's in the comments here. This is provided to you by

29:56  
by the language so the type of references Type A is a record type where there is exactly one field contents that the field is typed with a type variable A. So this one indicated here is a parameter of office type ref. But this field is mutable. And then of course, there is some interface, some some useful functions to work with the references. And they are the following there is something called ref. I mean, the type is called ref, but there is also a function called ref. And types that sort of value names they live in two different worlds in an F sharp you they never mix up. So, it's okay to reuse the name then there is bank and then there is colon equals So what are they? ref is credit for defining a new reference or for for creating a reference, you would say in an imperative context. What's the idea? ref is a function that takes a value of type A, and it basically sort of creates a location if you wish, and puts the value there. But how you should think of it using imperative programming analogy, like is a location or a memory cell where you can put values of type x, it's not a cell in the strict sense in this in that a can actually be a very complicated type, not not a primitive thing. So in this cell, perhaps you put something very complicated like a list of lists in one single cell, so to say, so that's why we talk about locations. So visit, so we could perhaps exercise a bit with it. I could, for example, say let p be ref of 42. When I do this, then P becomes a reference to an integer. And what is its value? Its value is an immutable record. This is how you understand what the what the value of reference is. So to say. There is this one field, which is mutable. It's called contents. And it's it's currently or is initially, shall we say 42.

32:27  
Yeah. Then, so clearly, then ref has this polymorphic type, it takes the value of any type, and it gives you a reference of the corresponding type. Very something for D referencing or sort of looking up a pointer, or looking looking under a pointer, if you wish. That's called bank. And bank has exactly the opposite type, it takes a reference and the tracks, it extracts the value. And more or less defined like this, except I'm not allowed to use bank as a function name myself. So this is where this is not completely legal F sharp syntax. But if bank were that a valid identifier, like a valid name, that would precisely be the definition. So all it does is just, it's field access. So it's p dot content, it's just a shorter way of writing p dot contents. So let's try this. If I do p dot contents, it's 42. And bank P is just a shorter way to express this. I can write it like this. I can also just drop the space even. And this is maybe more familiar.

33:50  
Yes. So that's the referencing but then of course, when you have references or pointers, you want to do updates. And what should that be? So that should be a two place function. So I want to have some reference some pointer to somewhere, then I want to have some new value that I want to put there. I just want to overwrite the old value. And nothing should be returned. But under the hood, of course, then the contents of the reference should have changed now, when I've called the function. So how is this morally defined? This actually is legal F sharp syntax. So it could be defined like this. So it is it is basically field update, right? So P is a record. Y is a new value for a field and all I need to do is to update the field p contents with the value one. So let's let's see this. I mean, I can I can do this manually using the sort of general record syntax saying I don't like 42 anymore. I wanted to Now b

35:01  
43. And that's fine. And then when I look up what P is,

35:13  
then I see it's a, it's a reference like this, I can do the proper lookup to see the action value, and then it's 43. So that's all well, but I can also use this nicer syntax, which is p colon equal, and then maybe some new value like 99. And when I check now what the value is, it is 99. Right? So what can I do now with this? You can do imperative programming now, right? So let's, let's, let's play this scenario here. Let me again, define P. So this is, I'm now shutting out my old P. So P is a reference, the initial value is 40. To choose a reference ratio, ation value is 1011. Instead of one parenthesis missing in my file as well, that's bad. And then I can look up what these things are 42 then 11, then I can say, let q equals P. Here, there is nothing destructive going up going on. Rather, I'm shadowing out my old queue, which is no longer accessible if I execute this.

36:44  
In terms of imperative programming, what I've created now is kind of aliases. So. So there are two pointers, but the alias each other so they point to the same location. Yeah. If I now look up, P. It is what it was before, it's 42. But if I look up Q, or dereference Q, it is what P is. Because I made to point to the same location as what PB. Now remember, these are aliases. So I can update you.

37:27  
I see nothing here, of course, because it's an expression of type unit, also called a command. So it returns nothing. But I can now I can now see what has happened in the world. So you see, I updated Q, but I can now look up P. There's also 17. Although last time it was 42. And I sort of didn't touch it explicitly. But the point was, p and q are the same reference. Yeah, they are. They are two pointers pointing to the same location. So therefore, when, when you do look up, you do get the same value. Let's do some more things. Let's do some more imperative programming sort of, implemented in,

38:15  
in,

38:18  
in F sharp as convenience, these things are also provided for you. To see everything here is in comments. And again, I couldn't quite define it like this, because F sharp doesn't accept semicolon as a user defined operator name. But morally, the definition is this. So we can, for any command, and for any expression of type A, I can put them in a sequence using semi colon sign is the semi same semi colon sign that we see in lists, but here is used in a completely different function. It's also the same semi colon sign that is used as a separator in in both record types and records. But yeah, it's used here with a different purpose. And what does this thing do? More or less defined like this? it executes the command. Because I do this pattern match. Yeah, I want to evaluate the command. See, I could be interested in what it returns, but I can just throw it away, because I'm not really interested in it what the returns unit is or is the the empty tuple. Anyway, but, but the interesting thing is, while I evaluate it to throw away the result, the side effect is performed. So this is what we do. And then we evaluate the other that's nice because now I could do things like lead queue. For example, the Q plus Q is 17 write Q plus one. And I write semi colon Q, sorry, a bank u, which means when I execute this thing first, this guy, the command is evaluated, it returns nothing of interest. But it has the side effect. The value in the location cue points to changes so that when I do look up for the reference, as we call it, I get the new value. What did I do wrong? The title does not match.

40:40  
I suppose now this is just Oh, yeah, sure. Of course, when I when I want to increment cue, I better make sure that when I want to use cue for it, I first dereferencing. So we see we got 18. Yeah, so this kind of a thing is, is perfectly reasonable. So I can give a kid also to you as an example.

41:09  
So now we can write imperative programming, or imperative programmes. So let's write a simple function swap that takes two pointers, and swaps their contents. So it's very easy to do. So I want to swap the P and Q are pointers to integers, say I want to swap their contents, what can I do? Maybe I institute a local third pointer, which is initially zero. And then I can do the following. I update our to the dereference of P. So I put the value of what is stored, what is the contents of the initial contents of P in R, then I move the initial contents of Q to P. And then I retrieve the initial contents of p, which I have sort of temporarily stored in R and an update cumulate. The result is these guys have changed. Place. So let's let's write out, P is a reference, we initialise the 15 Q is a reference initialised to 32, then I evaluate swap pq, nothing is returned. So this is a command, it's an expression that returns nothing of interest. Or, you know, the thing to be precise, the singleton tuple, sorry, the empty tuple. But under the hood, things have changed. So if I now look up P is 32. And if I now look up Q, it is 50. So this programme was almost polymorphic. But it wasn't quite because I needed some initial value for my for for the contents of our and I put zero which fixes that everything here needs to be integers, I can actually write the polymorphic swap by doing something slightly different. So here, the intermediate guy, the local guy was a reference, but they can make the local guy to be a proper value of type A, and then I can write the simpler programme. So Id reference be I make this the value of the local name r. so r is directly of Type A is not of type a ref here. And then I can do exactly the same things as before. So R is already p, that's nice. And then I can do this. And then I can do this, the difference. Now here I don't use Bangor, I just use r

43:59  
which is good, isn't it.

44:04  
And the same effect will work. Let's do some more cool things. So here is also another thing that is provided to you. You can so besides sequence you can do loops, if you wish, like imperative loops in F sharp. So morally wildoe is defined like this, but it's not the syntax, right? Because while there is mixed fixed syntax, and users can't use mixed fixed syntax, or we can't what is it we can't use introduce mix mix mix operators. User Defined mixed mix operators in this language, but it's provided to you like this. So one takes two arguments B and C B is a Boolean C is something of type unit.

44:54  
I should also say this is not completely official because why it should be I mean, the language is whatever they say the language is restrict. So when you call while though, both arguments should be evaluated before you can go ahead, but that's not what you do, really, in the case of y. So what happens is we do, we check if b holds.

45:31  
And if it does, then we do C, and then we repeat while B to C again. Otherwise, from the beginning, we do nothing interesting. So I'm in the condition is true, then we don't have to execute any further command, we will if we can evaluate the ante topples, doesn't do anything. And then I can write the factorial programme in an interesting way, in a purely imperative way, so to calculate the factorial of n, what what,

45:56  
what,

45:57  
what can I do, for example, I mean, this is just one possible way. Let's create two references. So P is something where you store what you're currently taking the factorial of. So initially, it's n, but you're going to decrement it. Q is where you keep the sort of running, running factorial. So initially, it's one but you keep multiplying things on to it. And here's the loop. So while the dereference of p is greater than zero, update q by multiplying together the current value, you get by dereferencing q by dereferencing, p, and then decrement P. And finally, you're interested in the final value of Q, you can do this and you can calculate the factorial is not the only possible version of writing this imperative problem. We do some more things. Now you can do really cool things like private state, if you wish. So so here is something I'm defining a pair of two things, a pair of two functions, simultaneously using something local. And here's the cool way of doing it. So tick zero, and reset zero are both going to be functions one takes no interesting argument, but it takes the empty parentheses, sort of as a push for it to go. And returns an integer the reset also takes a push and returns nothing of interest. How does this work? So we locally use a counter which is initially zero, then we define the function takes zero, which takes a push. And then what it does, it increments the counter, and it also returns the counter. And there is another one, which just resets the counter to zero and doesn't return anything or interest. So this is why the type of typist and actually these two local functions are the ones that we also expose, because I returned these two, these two functions. What is cool here is that no one else other than zero and reset zero, which are two functions that are defined simultaneously have access to counter zero because it's a, it's a local name here. And it's actually a local name of type reference. So something that is local and is also mutable at the same time. Let's try to play with this. Let me do so that the reference sort of is already there in and shared between two functions that I've already defined, I've loaded them, there's nothing to sort of initialise in that sense. So the the private counter of these two is already zero. But when I don't think zero,

48:58  
it says the value is one. Interesting. When I do try again, the value is two, if I just to take zero, nothing happens is the function, it doesn't do anything before you apply to an argument. And this is why we've made things zero into a function because it takes zero wasn't a function. Then in some sense, the counter would run immediately before we give it the push. That's not what we want, right? Then I can for example to reset. This doesn't return anything but the counter inside has been reset to zero. Now I can click again. And it's not going to be three what is returned but it's one again, etc. This is nice, but this is just one counter. Perhaps I should write the phone that delivers me counters.

50:03  
And

50:05  
so that each time I want, I can have my own counter and then work with it by taking and resetting. And that's possible. What you then need to do is,

50:20  
is the following thing. So yeah, we defined counter with capital C, as a record type that has these two things stick and reset. Using should really, in some sense, perhaps want to think that it's more like this counter is a type of objects. And they have these methods taken reset. I mean, these fields are functions, and fields that are functions, you may want to think of them as methods, back officially their fields in F sharp jargon. And then I can define a function new counter, I should have given its type as well. New counter is something that will only need a push, so to say to go with what comes back is the culture. And how is it defined.

51:33  
So we defined a local reference counter with small C, which is initialised, to zero. And then we define these two functions can read that exact the same way as before. And then we make these guys the fields have a record of type counter with capital, see, this tick here is a field name, this reset is a field name, this tick, is the function I just defined. And this thing is the function I just defined. Now we can play with this, if I say, let's see one be a new counter, then I, what is formed is a counter see, one is no a counter. And its fields are some two functions, like can't see what they are, they are something the the action counter with small sees private or was private, rather, to the function that I just ran. So it's not part of this thing here. Yeah, but now there is some reference in the background. Let's see what we can do. We can we can make a tick with this counter. We can maybe make another one, then maybe I can make another counter.

53:05  
I also get something that as a tick can reset. And then I maybe I can make fixed with that one.

53:17  
It's not going to be three different countries running. This one is one. Maybe I want to now make a tic with the first one. That one is three. Now maybe I want to make a tic with the second one. This will be to know the second one will run past the first one. Maybe I'll make a tic where the first one again. What's the last video the first Anyway, it was for three now it's become four. That's how it works. Oh, okay. Let's do one more. Cool topic. This is the final one here. And it's really kind of advanced programming, but it shows you that now you basically can do all your pointer programming of the C language if you wish. But in a in a much more safe way in the sense that strong typing is here right? So whenever you point something, it is something of a definite value. So it's not possible to to do anything unsafe with with the pointer arithmetic of the style of C for example. What you say okay, I'm pointing to this location, but let's look at what is what is in the next location within the memory. Whereas we should have no control over how the memories like actually laid out we should not know what is in the next. Next cell that could belong to someone else really. Remember, F sharp lists ordinary lists. So lists are a recursive data type. And you can write, you can form finite lists, in F sharp, in C, you can, and they are singly linked lists right access through the head. If you want to get any, any, any deeper element in a list, then you then you have to traverse the list to that point, and you can extract the sort of current pattern in the sense that you've chopped off quite a few heads. And then the head of what is remaining is, the remaining is what you want perhaps. In imperative programming, like in C, for example, when you create the list, it gets laid out in the memory, you can actually do other strange things, you can, for example, to circular lists. Why? Because morally, every list this list, first of all, in some sense, are really pointers to the data structure in the memory, right, all references. And what you have at any stage is either allowed pointer, or is a pointer to a pair, where you have the head of the list and then you know, then recursively, a pointer to the rest, right? Again, again, a list which is a pointer to the rest. And you can create cycles here, because you can make the third cell to point to where you started. And then you could create the list 123123123, which is actually infinite if you were to print it out. This is not possible with the with the F sharp list. But it is possible if you if you do list, your own reimplementation of list using using references. So let's try to do something c style directly in F sharp. So I want to define circular lists over a type base. So this is going to be a polymorphic thing. A circular list is a reference to a cell for type A. So what is the cell for type A, it can be two things. So it is either nil. Or it's a cons of a head element. And then circular list again. And remember, a circular list is actually a pointer to a cell. So it's not directly the next cell, but it's a pointer to get whatever directly will even mean here. Interestingly, I have to define these two things simultaneously, or mutually because in the definition of series, I need to know what is a cell but in the definition of a cell, I need to know what is delist. So it's a recursive definition. But it's a mutually recursive definition.

58:03  
Right. And then perhaps we could introduce some niceties for ourselves, we could say the empty list is a reference to nil. So when I create an empty list, with a little push SR apply to nothing of interest. The empty tuple gives me an empty list when I want to cons two lists. So I've got a pointer to a list. And I just want to cons an element in front of it, then what do I do is I put them together as a pair. And this is the initial value of a new reference that I'm creating. I mean, I can either do ref nil here or ref comes something because I've got the reference of type cell and there is two forms of cell like an empty cell nil, or a concept, which is a pair of two things. It's very cool.

59:02  
And

59:06  
now I can do lists with cycles. How do I do it? My aim is gonna to morally build this list, but this is like an F sharp list. But I want to do a circular list. It should be morally the infinite list that has first four and then three 815. But then here there is a little pointer back to three. So then when you unfold it, you should get three 815 three 815. Again, I'm

59:33  
at inflaton. Right. So how do we do it? I do it with a local reference yes

1:00:07  
Which is initialised to nil. And actually here, it doesn't really matter what we initialise it to we just need some reference to a set of integers, I think is going to be a list of integers in particular right now.

1:00:29  
This is going to be entirely local. And then how do I use it? I update P. So what do you need, what it initially is, doesn't really matter. But then I do a really bad thing. I update p in a way that uses the same p again, but not p reference, but as a reference. So P is gonna be the following its cons of three, C cons, a 15. And then P. Again, so this is the value the new value of this reference. So I've updated it to this thing, this is what p now points to. And then further, I create a new reference, what I just comes for, in front of this, this list, circular list that already have in the memory that is called P. Yeah, so I do this command, sequence together with this thing, which is actually an expression, what does this expression return, it returns this type of reference, namely, it is a list. So I can now look at my list. I mean, all of this has been already logged, this has been executed. my list is something like this four, three, a 15. I doesn't want to show me any further, but it goes on the reason. One of the reasons it doesn't want to go show any further is that it goes. But I can now write something that allows me to take any number of elements from this infinite list, I mean, it's not a good idea to print it out fully anyway, because it's infinite. But we can print out any initial prefix of it. So let's see how to do it. So let's do some functions for for heads and pay your head for circular list. Easy. So a circular list is a pointer, hopefully to a cons. Otherwise, I can't take the head and then I just extract it and return X to do the tail. You also you dereference P and then I pattern match it against this thing, which means that so I read, I introduced a new name p which is what I return its value. And the value is the pointer, which is the tail of the list. Right, these ones can give errors because the pattern match is not exhaustive. I mean, not everything is is a cons here, the reference could also be nil. Once I'm in, of course, you can also complete the pattern match using option type. But let's not worry about that. And now I can do interesting things. So I can, I can take an ordinary list and convert it into a circular list very easy take an ordinary list for every when you see the empty list, you just create an empty circular list. When you see something less something like this, you recursively call list to see list. With sequence that's obvious, in the opposite direction, a circular list, I cannot in general, convert into a list because it is potentially infinite. Although I could, but then I have trouble when i when i when i want to print it out, because nothing will be printed out until the computation finishes. And this will be never if the circular list happens to be infinite. So I won't see anything. But I can do this sort of extraction of a prefix of first elements of a security. So for any number n and a circular list, I might want to take out n elements of it and return this thing as an ordinary list. So you may want to take out zero elements from anywhere I just get back the empty list. If I want to take any number of elements from a list that is actually nil, I mean, if dereference P and you see nil then of course, you can't take any more elements from very already at the end. Otherwise, if when you dereference p you see the head value x and and a pointer to some further cells, then you just make a recursive call. But of course from the rest you don't want to take n elements anymore because you've already extracted one you want to take n minus one elements. Now I can do for example c take eight elements from my list They see this. And I can take any number of elements from my list.

1:05:06  
And it really has very many elements, right? So I could take more. Just see it's the same repetitive pattern, it does have infinitely many elements. But this doesn't mean that my memory is full of this garbage, there is really a little cycle in the, in the kind of heap that I've organised myself. Now, let me finish by showing a bit of this programming with circular lists we previously played with a pen, let's do a pen here. There is really two ways of doing append. And this brings me back to what we discussed when we did list programming before. We said append is, is is is is what these are singly linked lists. I mean, even the ordinary F sharp lists a singly linked list. So if you want to concatenate together x's and y's, it's clear that you need to traverse x's. And actually don't need to traverse wise, but but it will be a linear time thing because you have to reach the end of the first list. But then the bad thing is you copy the first list, you recreate the first list for for appending. Yeah, what is you share that the the second list, I can recreate the same idea of the programme for circular lists that has this deficiency that you don't do concatenation quite in place, in the sense that you recreate the first part of the list that is possible. I call it yep, and zero here. So we take two circular lists, we get a third one. How is this defined, it's defined the same way as the other append. So two lists are given. And it goes by traversing the first list. So since P is actually a reference, I have to dereference, I get either nil or cons. If it's nil, then great. All that I need to return is the second list, which is actually a reference to its beginning, right, or to the first element, I should rather say. If the referencing p, the first list, I get context p, then it's clear that I need to create a new cell. So now I'm not occupying more memory, right. So what do I put there is the following thing, I form a pair of x. And the result is the result of recursive call and P and Q, which is a reference to a new list. Or say it's a new circuit cyclist, but that is a reference a form of this pair and sequence. What does it do remember the definition of sequence sequence puts the two things together, I'm sorry, with this constructor, data constructor attack cones. But it also says I'm using the resulting thing, then then

1:08:07  
to create a new reference. So see cons takes a pair applies the constructor comes to it, and then uses this as the initial value of a new reference. This is what happens.

1:08:25  
What am I

1:08:30  
let's try to use this connection. So let p be some cyclic list, I just form it from ordinary lists because it's more easy for me to do it. So Pisa circular list, which in this case doesn't contain any action circle, but it has that sort of potential to be circular we see. So, P is now a reference when you're the reference you first see columns one and another reference when you dereference that you see comes to and another reference and then there is the last reference is an old pointer. Who is a similar thing, when I define it properly,

1:09:11  
missing semicolon sorry. And then I can append P and zero p p and q.

1:09:21  
I got this 129 10 organised in this way. And P is still what it was p hasn't changed, and Q hasn't changed. So So P cannot possibly point to the same place. Where were these points here because if you traverse it, you'll go past one and two. After two when you look up the corresponding pointer there there you see nine. But here if I go down this pointer structure after two if I dereference the pointer It was an up pointer. So, so clearly p and q are different things here. I could also, of course, ask not P and Q, and p are different things here now. And I can I ask, also F sharp about it, and it says false. So this was like the sort of functional programming recreated on the level of the circular lists, we should think what happens if one of these lists is circular. If the second list is circular, we just add a bit to the beginning of it, and we get something that we get like a lot. So type of data structure. So first there are some elements, there is a non circular part, and then you enter a loop. And the whole result is an infinite list. If the first given one is already really circular, in the sense that there is some actual cycle there, then of course, since cfn, zero requires that the first list is fully traversed, then the attempt to put together a circular list with a real cycle and some other lists, will will will result in a function that just doesn't terminate, it will go on forever. This must about circularity. But now actually, we can do in place concatenation, that will have the same property. If the second list is infinite, you're fine. If the first one is infinite, you're you're not good because you're traversing the boat. But the new version is better, if you wish, depends on what you mean, by better in the sense that it does concatenation in place, you've got these two lists already in your memory, I mean, they both are references to both point to somewhere in your heap. And the good append should just connect together the end of the first list and the beginning of the second list. And then after this rearrangement,

1:12:18  
the first list so to say has become the concatenation of the two. Yeah, because the first list was a reference after all. Now, the result is also a reference but it is to the same place. So this is implemented in terms of a command. So back comes nothing. But the new value, or the new contents of P is the new list. Let us see how this works. append pq, Id reference p, when I see Neil, I just update

1:12:59  
p

1:13:02  
not to have needle as its contents anymore. But to have as its contents, whatever cue points to.

1:13:12  
And Cons is also interesting. Old cons had to actually look at values, these cons doesn't look at anything. So when you when you when you're in the cons case, if p is con, something con something and another p, you just have to recursively go and do applied p to the tail. Yeah. And you return nothing. The result is a is not returned as the result of this function. The result? You see if you if you evaluate p again, then you see what it is. Let's see what happens. This is really interesting. So remember, p and q are these things. So P is maybe we just show them one. P is this thing. Q is this thing. So P is more or less the list one two, Q is the list 910. Let's do this new append. This is no longer CFS yet with append, append pq. See, nothing comes back. Because append is a command. Yeah, we see here the in the base case, this returns. This just returns you know the the empty parentheses, the empty tuple no information and the second clause has to have the same type as the first. So nothing is nothing of interest is returned. But something happened under the hood. If I check p n up there, if I check p then I see 129 10. So what happened was instead of this Neil, this thing has appeared here and this is the new value of p but when I look at what Q is He was still the old nine. Right? Let me then finish off with one final thing. So there is also mutable names, which I actually did recommend. So we saw that we could update fields have a record. Actually, you can also make updates to two simple names, if you declare the mutable and you have a similar updating syntax with with left arrows command. And here's an example. So if you do, let i equals five, then you've defined the name I, if you then do let i equals i plus one, then you have a new sort of more local or enter name I, whose value is the old I in the old I should say is the outer i plus one and the authorised From then on, from now on shadowed. So this is six. And you see, both are defined with length. So this is one definition, this is a more inward or more in our definition, more enamel, you have more definition. When I check the result of I it is six. But the point is not that the not at any updates happen, there is just two eyes in the scope, kinda but the outer one is shadow down. So I don't any longer have access to it, because I happen to reuse the name. If I declare I immutable, like we had this field record, in a similar thing, the syntax, then I do something else. Here I define a name i and i initialise. Its value, it's now a mutual name, I initialise, its value to five. Now I can change it. But this is not the definition. This is a command. So that one actually returns nothing of interest, it gives us nothing. But when I look up Hi, it is six. And now it's not the case that there were two different eyes around where the inner one shadowed out. The outer one is one single eye and it actually changed in value. Why are immutable names dis recommended? Or why would at least I discourage them is that if you use mutable names, you can't see what is mutable and what isn't just by looking at types of things. Because all of these eyes here are integers according to according to F sharp. In contrast, when you work with references, then there is a clear distinction of values and references to these values. And whenever you see that something has type t ref. You know, it is immutable thing. Whereas when something has type t, a simple type T, like maybe teasing, so it's a difference between interest and int, then yeah, but if it's a reference, then it's mutable. If it's not the reference is not mutable, and everything is very clear. So this is a nice discipline that you have by working with with references, but it only actually applies if you if you do not also at the same time use mutable names by which you make mutability, sort of invisible on the type level. Right, so that was the lecture of, of well today. I'm stopping sharing here. I'm no stopping. Also recording

Transcribed by https://otter.ai
