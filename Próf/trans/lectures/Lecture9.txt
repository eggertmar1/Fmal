Unknown Speaker  1:04  
Hello, let's have a sound check. Can you hear me? Yes. And I can hear you as well that is very, very good. Let's wait a minute.

Unknown Speaker  1:17  
Can we get started here?

Unknown Speaker  2:51  
Okay.

Unknown Speaker  2:58  
Think about time.

Unknown Speaker  3:06  
So today we'll change topic we've discussed what during this course, I gave you a quick intro to F sharp that took two weeks and then we discussed a fairly simple expression language where the idea was to simply introduce the concept of having like a small hierarchy of languages and then to talk about the difference between compilation from one language to another versus interpretation which is in some sense executing or evaluation of programmes directly. And then I showed you the different kinds of workflows that can arise there. And the main sort of language feature that is common to essentially every programming language that we learned there was the idea of local names and local scope. Typically related to some sort of block constructions. Block constructions arise in languages in multiple ways, we mostly saw one which was basically you just form a block in which you introduce one or multiple local names, local variables, then there are also other types of typical block constructions like function definition is right hand side is a function by function definitions or bodies of function definitions are also an example we didn't look too much into it at all. And then what I'd like to do next, as we go further also in the book is to talk about some ideas concerning functional languages in general. So this concerns then languages like ml, oh, camel Haskell Scala, have heavier also Lisp and closure. Which are non strongly typed. And then that will take around four weeks. And then during the last four weeks of the course, we turn our attention to imperative language languages like Java C sharp, or c++ if you wish, which is even object oriented examples as well. So, and then we look at sort of typical constructions and issues there. imperative programming is very much about operating with memory. And we look at explicit and explicit sort of implicit sort of automatic memory management versus explicit memory management by the programmer, as you perhaps seen in a language like C. Versus in languages like Python, or Java is much more sort of behind the scene for you. In this functional languages part, what are the important aspects, we will talk quite a bit about first order versus higher order functions. So functions that take other functions as arguments are important. Also, polymorphism, or generosity is important. So, so functions that operate on multiple types. And then I need to spend quite a bit of time discussing type inference. So, many of you, I think, already working on the practical session problems or assignments run into this question of how does F sharp figure out pipes and why, why is the type information here like this or like that, and why doesn't it agree with what I think, then I'll try to explain how this works, in most cases. So, there are some, some sort of Central ideas that happened in most that occur in most type inference algorithms. And also, you see them in F sharp, so that is the plan. Today, we we start slow, I just want to take the expressions language, add a bit to it, so that we can not only have local names, but we can have local, not like local names for integers only, but we can also have local functions. However, the functions will not be first class, which means we can't write higher functions in particular, we cannot even return the function as a return value. So, let me share what we have here. And then we get started here should always slow me down if you find something

Unknown Speaker  7:55  
is unclear or very unclear. Yes. So, there is a chapter in the book that I've also

Unknown Speaker  8:17  
listed in the modules in Canvas. I can't remember the chapter number. But, but this introduction then corresponds to, to the first chapter on functional languages in the book. So, what should the functional language be like? So, so far, we were able to write the expressions like maybe four plus three, or maybe let x equals four in x plus three. And these things could have been nested in every sort of way. So, you could also do let x equals four in, let y equal three in x plus y, for example, or lots of other combinations. But the only things we were able to define here, and the only things here to which we could give names were were integers. So, here I have a local name x for an integer defined and here is the use of that name. Here we also have this local name x. introduced, we have a yet more local name, why introduced was only scope is this bit here, but still is an integer. So, with a syntax that we played around with thus far, all we could write is, is basically simple arithmetic expressions, plus a bit of sort of local name giving and then the facility That we can actually also refer to these local names or we can use them. no possibility to do function calls. So what do I mean by or even to define functions? What do I mean by this, I'd like to be able to say stuff like, let f of x equals x times three in F applied to five, perhaps, which would be a way to say that I'm interested in number 15. To start with, well, maybe you don't ever want to introduce a function, if you're only gonna call it once. So this is maybe not one of the most useful examples. But maybe you want to call it multiple times, right, we could do that. So I would perhaps want to do that to give an example. So this is how first order functional language should should be able to work. So we should not be only be able to define names that stand for something primitive, like numbers here integers, but also names for functions that we can further use. And when a use of a name for an integer just means that I want to recall what the value of the integer is. The only way that we can use functions here in the language that I'm going to define is we can call functions or apply functions, these are synonyms, you cannot pass out the function. So the following thing will not be allowed. In principle, this is not a silly thing to want. So I might be willing or I might want to define a function like this, and then just return the function. So make the function available to the general public, then the value of this expression would be the function and anyone could later applied to whatever if the whole expression is also given a name for example, but here this is not going to be allowed. So we only do things like this. Yeah. So what will happen, we will take the expression language as it stood and try to do a minimal extension. So the expression language becomes usable as a sort of portmans functional language. This can be done in multiple ways, but what we will do is the one that I sort of hinted. So we will add two constructs to the language we already have function definitions. So I should be able to define locally a name a name for a function, and I should actually be able to define the function at the same time. And then when some function name is in a scope, I should be able to call that function. And that's that's all the additions that there will be compared to what we've seen before

Unknown Speaker  13:11  
some some points related to it, then we do not allow today or we won't allow today an anonymous function. So a function must always be named, if you want to introduce a function, you must at the same time give a name to it, we cannot do the kind of fun construction of F sharp for example, in this little language, what is also called the lambda. And also you cannot ever returned functions when expressions value cannot be a function. So this is related to the point with as I said that, it's not okay to say that the whole thing's value is F here. So if we played it interesting, a function should be able to take any number of functions. So perhaps I'd like to say something like f of x and y equals x times three plus y. But for simplicity, let's say a function can only take one argument and in some way this is sufficient, because if we were to also introduce pairs, so the ability to form a pair an expression that is a pair of two expressions. And then if we also introduced projection constructs, then one place functions are as solution for any number of places you want to have for a function because to have a two place function is the same as to have a one place function working on a pair. That's one sort of approach to it, of uncovering functions and curried functions was a different one. So this language is going to be first order. Okay, what is the language like? The language is our own expressions language. What did we have there? So, there are some parts that that we know and love already has. So, I can use variables variables are represented as just streams, I can do let. So alette expression is given by three things a string, which is the variable name morally to the left of the definition sign an expression, this is the right hand side and the body of a left. So, this is our block structures for introducing local names today. And then we have all the goodies that we had before either in the lecture or in the practical session. So, I can I can write numbers, integer numbers, addition, subtraction times is possible, perhaps we can also do the negative of a number. And then some little logic as well. So, some Boolean values true and false, that can compare to arithmetic expressions for equality or maybe for less than. And then finally, if then else, which takes a guard into branches. That's all, what we've seen before. The only thing is we should add is the facility of defining names of functions. And using functions. And the only way that we're allowed to use functions here is applying a function, also known as calling a function with an argument. So, there would be these two cons, directions to call and let fun call is something that you would sort of in concrete syntax, right, simply like this. So F here has to be a variable. It's a function name, he can be any expression. So it's like a function applied to an argument. Normally, in a functional language practice, we don't insist that there are parentheses around the argument, maybe you would like to put them I don't like typically you don't require it. But then in abstract syntax, all we need is a name. And then expression, the name is the functions name. Yeah, we don't have an anonymous function. So it's not possible to write the function expression other than a name. And then the argument can be any expression. That's fine. This much about using function? So we've got this call construct. Now. That is good. How about defining functions? Well, the way that you would define a function should be something like what I wrote here above, so let a function some parameters, Well, here we are on low low, exactly one, and then the function body or function definition, and then the body of the left. So the general shape of this definition is something like this. So there is like let I write left, but this is actually going to be a recursive left. Let's agree. So I can define functions recursively, without having to say rec.

Unknown Speaker  18:12  
And then what I have to the left of the equal sign has to be the function name, then some names for the parameters, they are actually going to be local names to this definition. So they only make sense in the in the right hand side. So this right hand side is what is also sometimes called the function body. But then there is the other body. This is this guy here. That's the body of the whole let construct. So this is the little block, or the little expression within which the function definition makes sense. Here, define the function. And now anybody you can use the function, possibly making function calls and using arithmetic operations, Boolean operations, etc. So does it make sense? Let's look at some examples. Otherwise, these may be too abstract. So So here is a sort of a typical concrete syntax thing I might want to do very similar to what I already showed. So I'm defining a function locally, f is the name of the function x is parameter. This is the functions. definition, people also say the function body. So the idea of the function here is to simply return the value of x plus 11. And this is the this is now the body of the left, not the body of the function. And the only thing I'm going to do here, in this example is to apply F to three

Unknown Speaker  20:01  
So let's see, this is very defined this kind of expression, it's called a one here, let's see, what you want is like F sharp tells us, it's really convinced that this very same that I defined here is properly a legitimate expression. So it's a programme in our little programming language that we've now put together. So far on the level of abstract syntax that we have to write things in this horrible way. But you connect, you can connect it to a parser and lexer. modifying the parser and lexer we have. And then you can write programmes in a more reasonable way, more or less like strings like this. Okay, let me give you more examples. Here's a different one. What is that? So here's two let's nested inside each other. One is the kind of lead way that we've seen before, where I introduced a local name for a number. So I want that y means 11. So I say this. And the scope of this definition of Why's the rest here, so it's the body of the left. Now, the body of the left consists of another lead. But this is not the usual lead where we introduce a local name for a number. Now we introduce a local name for a function, we introduce a name for F, sorry, a name. For a function, the name is F. And here's the function definition. It works with a formal parameter. So that's a name, whose scope is only the right hand side of the definition, the function body, so to say, when we get to the body of the let fun, which is here, here, x is no longer in scope. But the new name for the function that I've introduced, this is the scope, so now can use the function. And maybe I want to apply F to three. If we call it up in our concrete syntax, sorry, in our abstract syntax, I have to realise that these are two different LEDs, they look the same. But they are different. Because see, here, there is one name to the left of equals. So therefore, this is a name for a number. Here, there is two names to the left of a function of the equal sign. So therefore, this is not introducing a local name for a number, it's introducing a local name for a function that takes a parameter, the parameter can actually only be a number as we will see. And, or at least, that's the intent. And x is just local here. Now, in the concrete syntax, these are both written let, but in the abstract syntax, one of them is let it takes three arguments, the name, the right hand side, the body, the other one is not lead, the other one is lead fun. And it takes four arguments, the name of the function, the name of the parameter, or the parameter, then the right hand side. So the definition of the function and the body of the whole, let thingie the body here of of the inner let the function lead is actually just a function call. So in our abstract syntax, this is the data constructor call or the tank call with two arguments, the function name and the general expression here, the expression is very simple, it's three, but it could in principle, be one times three y times 17, or something like this. So let's take that one, two. And that is okay. But if I were to mix up the two let's or let fun Of course, it doesn't work. So I might have the bad idea.

Unknown Speaker  24:10  
Either partially write it myself.

Unknown Speaker  24:15  
I might have the bad idea to think that the outlet is also the function lead. And then when I asked short to check this thing, then it says there is a problem, right? Let fun once for arguments. But we have only given it three, this guy, this guy and this guy.

Unknown Speaker  24:41  
Okay.

Unknown Speaker  24:46  
Now let's do something more interesting. Does it make sense so far? I've gone really slow and that should not be controversial. Let's do something else which we'll look Very simple, but it's actually very controversial, when you start to think of it as sort of deeper, is a little variation of the programme that we just had. But I've introduced one more or less. So is now is three fold nesting of LEDs. So first I introduced a local name for an integer why they need to use a local name for a function f, then I introduce a yet more local name for a number. Why, again, with the funny effect that now I have two ways in the scope, but only of course, the inner is accessible the the outer world has been shuttled out should be like this. And then here the body is again, f of three like before. Now if here the body we're not F of three, if it were just why it's pretty clear what the value is, then the Y is 22. It's not the level. Yeah, and that's the value of the whole thing. But that's not what the everything here. So we've written F of three. And here's the interesting question. Now what what should come back? Of course, I'm I've already written the answer here, but let's think about it.

Unknown Speaker  26:23  
So there's various ways to think of it. One way of thinking says, so let's just read the, the the expression sort of outside in

Unknown Speaker  26:38  
one way 3d is to say, Well, we know we've introduced the local y, which is 11. Then we introduce the function which given any x as x plus y together, where y probably is 11. So we could think this function f actually is a function that adds 11 to whatever comes its way. Then we introduce another y, which is 22. But that shouldn't matter. And then when we apply F to three, why shouldn't it matter? Because we don't mention y here. Then we apply f two, three, what was f? f was the guy that added 11 to

Unknown Speaker  27:21  
2x. Then we could say okay, yeah, the way this way here was 11. It's it's three plus 11. It should be 14.

Unknown Speaker  27:33  
But what happens things Speak louder? A bit louder? Yeah. What happens to the lower? Why, like, why is equal to two? We have a very good question. Indeed. Let me put the sound low.

Unknown Speaker  27:49  
What happens to the lower Why yes, indeed. And

Unknown Speaker  27:54  
so

Unknown Speaker  27:56  
I don't know. So let's, let's try to see if there is another reading. We could say we've just introduced y, which is 11. And let's read it outside in again. We save introduced y which is 11. Then we say we introduce a function, which takes x as a parameter and adds together x plus y. Now let's think differently. We know what x is x is whatever F is being applied to. So we get to know it when we apply the function with y. Let's wait, let's see what it is when the function is actually called. Then let's process this guy, we say Aha, we enter a scope where y is

Unknown Speaker  28:40  
22.

Unknown Speaker  28:43  
And then we call F of three, maybe we should say that the answer is actually three plus 22, which is not 14 is 25. And that should be a reasonable story, right? Do you agree? That is exactly the question. What does really the why here mean? Maybe it doesn't mean anything at the point when we make the definition. And it only obtains meaning when we actually make the function call. So that's one way to think about it. Another is let's fix the meaning of everything in the definition of the function at the moment when the definition is made. So later, when we call the function, it's completely clear what the function does. It's only just to see the argument that we need to plug in. So here are the three. So in that reading, of course, you will do three plus 1103 verse 22 is very unclear. Now what do you think? Can Can someone guess which is correct? Or and also, what is why? It would be correct this way or that way.

Unknown Speaker  30:04  
I think 2525 because in the lower scope, you override why we attended to

Unknown Speaker  30:13  
that we met. Yeah, it's not a bad reading. I kind of I fully sympathise with this.

Unknown Speaker  30:20  
I disagree.

Unknown Speaker  30:21  
You disagree? Why do this?

Unknown Speaker  30:24  
Because I think it would be better, maybe for performance to pre allocate. Why is 11?

Unknown Speaker  30:37  
Right.

Unknown Speaker  30:39  
But I might be wrong. I'm just guessing.

Unknown Speaker  30:42  
I think you're both right. And that is the trouble. So both are possible designs. And maybe the best thing to do is never to arrive in such a situation, right?

Unknown Speaker  30:53  
I guess yeah.

Unknown Speaker  30:55  
Best. So you, you somehow want that. There is never this kind of ambiguity. But But this is also not a satisfactory solution. So one of you was, was promoting this kind of static idea that we fixed the meaning of why when we make this definition, right, since y is not the parameter to the function, the idea is the meaning of y should already be fixed by the time we we make this definition. So So surely, if we've taken this static idea, I'm sorry, I said it wrong. So if we just take the idea that it suffices if if y is defined around ones, like either here or here, but not both. But But then if we take this static approach, and y is not around, then then we are in trouble, because y is not even initialised at the moment when we try to, you know, record the definition of F processing this. So it also feels like it's not great to simply say why has to be defined somewhere, because this would be very awkward from the point of view of language implementation, right. And also modularity. So if we have no idea if when when we make a function definition, whether we should look for the for the value of y in a scope further out, or further in. If it's not made locally, I mean, at this point, which is not when it feels like strange engineering. So actually turns out that historically, people had the idea that he should understand that, why is 22. And this was done by this by john McCarthy in the when he defined the Lisp language, which is one of the early ones of functional languages. And in a way, it's sort of intuitive, and it's even simpler to implement, I must say, bizarrely enough. This has to do with how you implement function calls all together. The idea is, you maybe have already seen it in some other course. The idea is somehow that if you make function calls, then you build a little stack of the calls that are currently active and sort of what is still the work left to do in this course. And in that stack, you simply would then look up the value of y and you will try to find it sort of closest to you. So closer to the top of the stack dynamically, that kind of makes sense. On the other hand, this idea that why is 22 here is sort of terrible from the point of view of software engineering, or like readability of the code. Because the point is, there are so many ways in a general piece of code. How the control can reach a particular functional application, imagine that I like if the analogies here on the way. So don't know which way you came to this programme point. And depending on which way you came, you may have made different definitions. Okay, if then else to make local definitions that would extend beyond the if then else but but but in principle, the control flow can be complicated, and you don't know how you arrived here. So it's very odd. If at the function use sight, you cannot really know which kind of environment you're using in the sense of what are the values of the variables in the function definition. It's also very strange for type checking, for example. So imagine, variables could take not only integer values, but say also say string values. Then we could do things that are completely bad, right, because this function definition is enclosed in this block. Here we say Y is an integer And we could say okay, so therefore this body should make sense. Before an integer like, okay, I can add together integers plus works on integers. Suppose then I go to the inner inner block, and think the very make a new local variable y, which is not an integer, which is maybe a string, or Boolean or a character. And then all of a sudden, the definition I've written doesn't make sense, because I've changed the type of y. I haven't even changed it. There is two ways around the outer y has type into integer and the inner y has another type. But how should the poor function definition know which type it should have?

Unknown Speaker  35:42  
Right? So sort of from the software engineering point of view, and dynamic scope, so the kind of scope rule where you only decide at the function call site, what the variables in the function definition mean, is, this is really, really difficult. It lives sort of on understandable code, which is impossible to maintain. Whereas static is very clear. It's all about like, syntactic nesting of blocks, and you just see what is your closest enclosing block? that defines the variable in question. So here, this is one block, and its content, which doesn't define why itself, and here is a bigger block that encloses it, or that encompasses it defines wine. So that sounds good. To see. So let's try to let's try to make this crisp, so that we have some sort of definitions to work with. The discipline, according to which the one that is used here, when we call F of three is 11, is called the static scope rule. It's called static, because before even running the programme, you can figure out which is the place to from where you need to take the definition of why that actually is relevant here.

Unknown Speaker  37:13  
Dynamic scope,

Unknown Speaker  37:15  
you can only determine runtime right here. Since there is only one possible flow, you go from here, here here. It's kind of easy. But but but with recursion, or other things in the control flow, as you'll see later in examples, you really can't figure out what is your closest place in the frame stack that defines why which would be the why event to use, which here is 22. So that's called dynamics GoPro. So the point is, with a static scope rule before running the programme, you can figure out which definition is relevant with dynamic scope rule. This is decided runtime, which feels like it should give you an overhead but it's actually not terrible. And there is a different type of overhead that comes from the static scope role that maybe I can explain at one point. Okay, so in some sense, both of these scope roles tell you that the variables definition should be looked, there's a word missing looked up in the current block or the nearest enclosing block. But what changes is the idea of what nearest enclosing means precisely. Yeah, with static scope, it means the easy thing, it just means how blocks are inside each other in the syntax like here is a big block contains a smaller block contains a yet smaller block contains this with dynamic scope, you have to take into account how function calls nesting blocks and in each other during evaluation, and here the idea is a bit different. So, by the time that I reached the call F of three, then of course, I have to look up the definition of of of f, I see this. So basically, I will be processing the body of the function so late. And I say this guy is contained in the body of this guy. Because dynamically It is like this. I mean, this is invoked while I'm here. While who invoked me here, it was the this guy, and who invoked me here was the big guy. So there is like a fourfold tower. And this guy is at the very bottom of it. And according to this tower, why is the closest enclosing block to x plus y is not this one, but it's actually this one f3 And here, this doesn't locally define y. So we go one level up, this does locally define y, and therefore we say it's 22. So it's really terrible, kind of how the dynamic scope works. So here I've written out the tower, exactly, the use of y is in the definition of F. And that we think morally, is in the body of the third leg, because this is where the call of f is. Now the body of the third leg, of course, is in the body of the second leg, and the body of the second leg is in the body of the first leg. And therefore, the order in which you make definitions away from outside in is the most outermost one is 11. Then he this one doesn't define anything, this one says it's 22. And by the time we get here, through actually the function call, we've already seen that, why is 22 that's what dynamic scope does. So then, as I said, static scope is sort of the correct scope rule from software engineering point of view. And what I didn't yet say is, practically all modern languages. Contrary to perhaps what you first might think, if you didn't ever run into this problem is nearly all modern languages use static scope. And the reason is, you get code that you can understand. compilation is a bit more difficult interpretation is a bit more difficult. In some sense, there is a little overhead if you do interpretation in a static language, versus dynamic language. But I can't go into the detail at the moment, maybe a tiny bit later. But then, interestingly, dynamic scope was invented first. And then when you would ask, you know what is a modern language that uses dynamic scope at all, then I would have to tell you, basically no language, you would use it, except for some dialects of Lisp still in use, they tend to use it. And it's also used in Perl, which is a scripting language, as you might know.

Unknown Speaker  42:22  
So

Unknown Speaker  42:23  
similar to, to the shell languages, like bash or C shell, there is Perl and Perl actually supports both static and dynamic scope, at the same time by some annotations that allow you to distinguish which is bizarrely enough, and I suppose it makes sort of a lot of sense in in some dynamic applications. scripting applications. Because they are sort of very, very, very low level. And you'd expect that the interpretation should be extremely straightforward. So there may be some natural principle to use dynamic scope. And then static is kind of a more fancy superstructure on top of it. Okay, we'll see both in action. But now that I've told you this, let's let's look at some examples. And let's figure out what we want. So this is a tiny variation on the example that we just saw. So the only difference is that the outside let the defined y to be 11 is gone. What do you think now, which, what kind of why would be used when we want to evaluate this whole programme, which in the end reduces to evaluating f a free which is also what is returned. With dynamic scope, it looks like the problem hasn't changed. Because immediately before we make the call to F, which takes us to the definition of f, we've introduced a local y. So dynamic scope, we'll use 22. How about static?

Unknown Speaker  44:17  
What do you think?

Unknown Speaker  44:19  
Unfortunately, I'm already saying it in my text here. So for studying there is the problem that for us to make sense of this definition here, we have to rely on an outside definition of why sort of outside in the sense of lack of syntactic nesting of things. So if this is a top level programme, then we cannot know why unless y is provided to us from the outside environment, which we could then supply. But otherwise, if you don't supply any outside environment, if you if you run this programme within With an empty within an empty environment, you would you should get a complaint that y simply doesn't have a value it hasn't been introduced. It's like uninitialized in a kind of imperative programming sense.

Unknown Speaker  45:14  
Okay.

Unknown Speaker  45:17  
And here is one last one. And then we'll have to think what all these things mean and how to implement them in the on the level of an evaluator. And I'm, I don't want to do so much more today. So this is just to illustrate that we write let fun, but the intent here is that everything is sort of by default recursive. So we could do the following. We could define them, we could do a nested let, but nested in a different way. So we've got a top level lead, which is a function that with defining a function, and in the body of this lead, the function is just applied. Nothing else is happening. But there is a nesting in that the right hand side of this function definition is a further left. Actually, this is quite interesting. So the function has a parameter x, this x is only usable here, right, which is the definition of the function. But now the function definition uses another function, which is something that you see in some languages, but you don't see in others. Like in C, you have function definitions, but you can't make function definitions local, you can have function definitions on the top level of your code. So you can define your main function, which is like the top level expression, which can depend on a bunch of functions. But those cannot use any internal local functions of their own here, very sort of no reason to forbid, local functions. And what we could do is we say, the value of f of x for any x that comes our way, is G applied to two times x, where g is our private function here in this definition of F, which only we know to be equal to x plus y. And hear why is in a different role than it was before here. Why was a local name that anyone can use here? Why is a is a parameter for the local function? So it is like low levels of locality? Let's check that all of us understand the scope of everything. So here's the top level programme. Where is the definition of f, the definition of f is here. So which is the area in this programme where I can use f? It will only be the body of this left, which is only this small bit? Yeah. So this is the definition of F. And this is where f is in scope. Let's look at some other names we have here. What is the scope of x, x is the parameter of f, therefore it only makes sense within the definition of f, the definition of f is given by its right hand side it's here. So x this x declared here can only be used in this part. Okay. Further What is happening? So, here is the definition of G. Where can this G be used that we have introduced not here. But only not in all of this either. That doesn't make sense. But it can be used here. Actually g could, in principle, be recursive, then g could also be used in the in its own definition. That's all that's also possible. But he had in particular, it hasn't been used. Actually, the same is true about F, if you could also use to define f itself. And then finally, what is the scope of y, y is a parameter of G. So it can only occur in the in the definition of G. And then you can code it up in our abstract syntax. That's, that's not difficult. It's just literally collect everything we've seen. Now let's see recursion in action. This is a modification of what you're seeing here. So I'm defining some function f with a parameter x. At the end, I will only apply to some y. This y is defined nowhere so it must be given from outside. But what is the definition of f? It's this bit here. Of course, it can use the parameter But now for the first time, you can see that I'm also labour able to use the function itself that I'm currently defining. So this is recursion, that's allowed.

Unknown Speaker  50:14  
Let's see if, if F sharp believes it. So that's e five. Yeah, this is correct. It's just types of expression. No, the lighting conditions change. Okay.

Unknown Speaker  50:37  
So we've talked quite a bit any any questions. Thus far, all I want to do in the rest is just to show you an evaluator for this thing, and nothing really else. And he, the evaluator is the one we've seen before, I only need to add two clauses, one for function calls and one for let fun. But there is a twist, in that. Now, we don't only work with integers and Booleans, there are also these functions around in some sense in the semantic domain, so we have to be a bit careful with this as well. And that will introduce a small twist into the code, we need to work with the idea of a closure, which is a very important concept in, in functional languages, it also enters imperative languages in a certain way. So I'll have to explain you this. So that will be the one of the main things today.

Unknown Speaker  51:48  
Okay, let's get right to it.

Unknown Speaker  52:09  
Yes, one thing is, is the same as before. So every now and then I need to work with an environment. So the evaluator is an interpreter, right? So we don't do any compilation today. So now I need to work with an environment for so for every variable that is not defined within the code, we need to store what its value is. So this applies both to the top level code and whatever is not defined there. But also, since we defining evaluate the evaluation recursively, then for some expressions, they certainly contain things that are only defined outside them. So they're also this notion of environment is important. This is a dictionary, as I explained to you. So for every variable name that we use, we expect to see a value with a list of variable name and value pairs. And we have this function for looking up a value for a name in a dictionary like this. This was defined before, nothing has changed here this, I've shown it to you a number of things. But now things get more interesting. So in the dictionary in particular, but also elsewhere, I need to talk about values. So what is the value here? So the things we can produce here are numbers, integers. So one possibility, or one kind of value are integers. I marked them with a tag or data constructor, ie, we can also get Boolean here, I marked them with B. So b two and B four. So values and I 17. And I 42 are values. But we've got one more type of a value and these are functions. And what is the idea? The idea is somehow, the moment you process a function definition like this, you should record in your dictionary, the environment, that now we have a function around so so to the string F, we have to associate the function. The way we do it, is we just record what the function definition is. So the important ingredients in the function definition are what is the name of the parameter and what is the body. Because you only evaluate the function or the call, you don't evaluate it before. So I need to remember these two things. But for static scope, maybe I need to know a bit more. Because for static scope, I should remember when I process a function definition what the environment is at the moment when the function defined definition is made, so for example, here when I make this function definition, I should record what y is in the current environment. And this is what is captured here. So, a closure, which is what the function means semantically for static scope is a triple of three things, I have to remember what the functions parameter is, I have to remember what the functions definition or body is.

Unknown Speaker  55:47  
And then I also need to remember what what the current environment is. So, this is an environment over values. We've defined environment polymorphically. So, I can in my dictionary put anything I want, but here in particular, we want to put values there.

Unknown Speaker  56:14  
Okay.

Unknown Speaker  56:18  
What does the evaluator do? I've shown it a number of times. So the main idea is we give it an in an expression, this is the main argument here of interest. And we just want to know what its value is. And this expression is closed, it defines every variable, every name that it uses internally inside it, then we don't need to provide it anything else, we can just give it an empty environment. But in the general case, I may accompany I may need to accompany and expression together with a little environment that tells me what the values of everything are. That that is not defined locally. So let's, let's remember this, how it works. So. So like, for example, when I want to evaluate number five, se, then it suffices to do it in the empty environment where nothing has any interesting value. And we get to know that the value of this expression is five, that's sort of easy. And, well, the value of five is fine, even if I happen to know that the value of x is 17. because x is 17, but I'm just not using it. So that's the same coupon, I have to write iE 17. Because now variables can take values of different types. However, if I'm using a variable, then such a thing doesn't have a value on its own. I mean, I'm trying to use the variable x, but I haven't introduced it, I haven't defined it. So surely, something should go sour. And indeed, We this lookup function tells us it tries to look up, eval tries to make an eval makes a call to look up look up tries to find the string x in the dictionary, it's not found there. And then we get this exception x no phone, that's not good. But if I tried to do it in this environment, again, where x is the integer 17, then we get to know for sure if var xc 17. And then I can write more and more more more complicated expressions. This is what we've done before on a number of occasions. That should now also work because 3x three and x according to the environment is 17. So I should be able to see that I need to add together 17 and three and that surely gives 20 that's the game. So eval gets in the interpreter gets in an expression it needs to return a value and as an auxiliary argument, we can take an environment we always need to supply an environment but can be the empty environment and this is sometimes useful. Okay, so how is the evaluator written? Pretty much as before, let me show you some cases that you recognise. So if my expression is is just the number, given number, like here, we had known five, then surely I can just say okay, it's value is that number. If my expression is addition of two expressions, plus of two expressions, Then this is a big problem, which I just reduced this to the smaller problems of evaluating e one and D two separately in the same environment in which I'm trying to evaluate the whole thing. And then all I need to do is to collect the results from evaluation, if both evaluate two integers, so I see these capitalised here, then it's great that the result is also an integer, and I'm happy. If either one of the two is something wrong, it's a Boolean or a function, then we just fail because we will have a pattern match today. I mean, I could have also written more patterns here and give, you know, raise my own exception of like, wrong argument type for all of these bad combinations of patterns, but haven't done this here. Similar for minus in time and negation. if you for example, see the expression to its value is just a Boolean, true false is Boolean false. When we do comparison for equality, we expect

Unknown Speaker  1:01:09  
we expect we expect to, we evaluate both expressions in the same environment that is handed down to us, we expect that both are integers. If this is true, then we can compare them. And the result is true or false, which is a Boolean, we return that Boolean. If one of the two guys here is not capitalised something, but it's capital B, something for a Boolean, or a capital C, something for a closure, now a capital F something for a closure. So then we just say. So these are the easy cases, var and let R just be just as before, almost, let me see exactly as before, what was the story, when you need to evaluate a lead thing, the main thing is really that the value of lead is the value of the body. But the body you have to evaluate in an extended environment, which is not the original one passed down to you. But an extended environment, this environment is given by what is already in the environment, plus we add a thing in the front. Namely, in this new environment, we don't not only have old variables have their old values, but we have one new extra variable, this x here, which has its own new value, which we get by evaluating the right hand side of the definition here in the given environment. So the right hand side is evaluated in the environment that comes down to us from the main core of the evaluator, the body, not the body is evaluated already in a new extended environment. The variable case should really be that we do look up and then we just return whatever comes back. Except in this language we want to allow the function is used as such, or that the function is turned as such. So we want to forbid this. So therefore, what we really do is we look up the variable in the environment. And if the variables value is an integer or a Boolean, then it's great. But if we see a function come back, then we see Ah, it's a function that we try to use as a value. That's not good. So here we get with a, that's the only difference from the old case. But here's Now the interesting part. We have to also define what what calls mean. And what led funds mean. Yeah, so, this is we have to say, what is the value of a function call here we have to say, what is the value of a lead construct, where we have locally defined the function and whose body is the body thing here.

Unknown Speaker  1:04:16  
And that is now the crucial important bit. Let me do let fun first. The value of any lead to just be the value of the body like we had here in some extended environment where we're taking into account the new like local names introduced. So it's the same thing here basically, evaluating let fun in the environment and should be evaluating the body of it in a new environment and prime, which is a small extension of ends. What do I need to add there is the meaning for the new name introduced. So I need to extend my dictionary so I can in the future, look up also. The name f that I've just introduced. Okay, what's the entry we put in the dictionary? We say, well, the name is F, because it is F. And then here I put what is called a closure. So we record the parameter of the function, we record the right hand side of the function. But then also this is since this is static scope, I should remember the environment currently in force, which is this guy here. So this is crucial. So you see envies used in two places here. So we on one hand, we say the current environment is is, is part of our dictionary. But now something interesting happens, the dictionary gets a new entry, which says the meaning of f is kind of a little data structure. And in this data structure, there is another copy of this end. And the idea is the big end keeps growing. But this little guy here stays the same throughout it when we grow the these that sort of when we keep extending them all along. Now, the interesting thing is, suppose I'm calling a function with an argument.

Unknown Speaker  1:06:41  
How should that be evaluated? Well, maybe we should first figure out what the value of the argument these anyway, because then we can apply the function to that argument. So but even before that, of course, we need to find out what the meaning of Effie so we look up the meaning of F in the environment, it has to be a closure. Yeah, because functions have to be closures. If f is not a closure, if it's an integer or a Boolean, then you should not be able to apply an integer or a Boolean to an argument that's nonsense only functions can be called on arguments, not integers or Boolean. So, in the bad case, we just say our programme is ill formed and that could actually be sort of aesthetic check that you can do independently okay.

Unknown Speaker  1:07:32  
But if

Unknown Speaker  1:07:36  
if What

Unknown Speaker  1:07:38  
if it is properly a closure, then we remember this closure. And also actually, we say this closure is has got a parameter name, the right hand side meaning of the function body, and then some environment, which is the environment that we recorded at the point where the function definition was made, when the closure was formed. And then what happens now The important thing is, we first evaluate the argument in the given environment, the environment that is given to us here in the recursion from the main call. Let's, let's sort of obvious so that when you apply a function to an argument, the argument is not a problem, you understand where you need to interpret it, you should interpret it in the current environment. So whatever the value where every name is, you should you should proceed from that. However, then what is what is the result of the function call? Like, maybe maybe this guy here, right? So three, when evaluating the current environment, and is easy, what it is, is three anyway, but then I have to, once I already know that, that the, the programme num three has value is three, then what's the value of this guy? Well, I better go to the expression, which is the definition of the function. And I just take into account that the parameter now is not just anything, but it is actually the given argument. So I need to work with with the right hand side here with the definition of the function with the extra knowledge that x is three, and should this thing here contained, recurring here, it doesn't, but the principle here f could occur as well. Then I should also take into account the meaning of F itself as already established. Okay. So that's done here. So let's extend the environment a bit. Let's form a new environment and prime and then what should that be? That should be the environment in which we will now evaluate Write the function body. We said, the function body, we evaluate in the environment that is there at the moment when we make the function definition. Yeah, time has gone on, now we have a different environment. But the closure remembers what the environment was at the moment when we made the function definition is no zero kind of initial environment. So we use this. But we also use that X has value v. And we also use and that is for recursion, that F has the value clo. Yeah. So this, this bit here takes care of the recursion. And then we evaluate the body in this extended environment. So long story short, the argument is evaluated in the current environment. Once this is done, the function body I mean, from the place where the function was defined, as recorded in the closure is recorded in almost the environment, as it was back then. Plus, the new knowledge about the value of the argument, which is specific to this call, right? In every call, the argument can have a different value, of course, plus, for recursion, the knowledge that, you know, in the recursion, the recursive call of F means the same thing as the main call of f is the same closure may look terrible. But let's let's try to look at at some examples. I don't even know how to best do it. Can I follow you for a bit? Sure. Yes. That's what I said. Okay, if we take a five minute coffee break.

Unknown Speaker  1:11:52  
We could have been talking about it in the chat and it would be really nice to both.

Unknown Speaker  1:11:59  
Let's let everything sink in. Yeah. And then I'll do the examples afterwards. So do you want like until What 17? Just Just four months? That'd be great. Yeah, something like this. Okay, let's do that. Yeah. Sure.

Unknown Speaker  1:18:01  
Okay let's, I was still there. Yes, sir. Thank you. So let's let me try to give you some intuition about this, because I need to do two things and then we can call it today. One is to give you some feel why this works. And second is to, to really try to show what is different in in dynamically scoped version. So in this code, there is really two versions. One is for static scope. And there is one that is sort of commented out, which is for dynamic scope. And the only difference is in the in how you understand call and let fun. And I should also say the notion of closure slightly different differs for the static scope, and dynamic scope. So for static scope, it is important to remember what the function

Unknown Speaker  1:18:54  
formal parameter is what the function definition is. And the environment at the point of the function definition.

Unknown Speaker  1:19:03  
Because we want to get back to go back to this old environment that fixed the meaning of the function once and for all. But as for the dynamic scope, and here, you see, this is kind of easier, implementation wise. You don't really care about what the environment was, at the moment when the function definition was made. What matters only is the current environment, so you don't need in the closure to even record this. You know, you don't need any sort of memory about what the environment once was. Okay. But then, let's see. So suppose I want to do something like a call of a function say F, on some expression, maybe num three again. In some environment, this only makes sense if f is actually a function, right. So as soon As I say, f is maybe a number five. The thing should simply shout at me, because that's really a bad idea. I mean, you should not when you make a function call, then environment shouldn't think that the function name has the value which is not the function, which is say an integer, a Boolean. So here, I expect, actually, several things are happening. But what happened? Now, he was writing them in num three. So this is not good. Because we get this section exception integer, a boolean variable used, called. And that is actually

Unknown Speaker  1:20:58  
my own exception that I introduced were so bad. It was just a little bit. A little bit lower. Yeah, sure. But this means that I happen to have not the one

Unknown Speaker  1:21:19  
on commented that I meant, let me just change this. So now the study scope should, should be the one. And it's really funny that I've given two different error messages, but it's good that it showed here. So because both both are the same thing. But it saved my day at the moment. And let me see if here, the correct one is commented is also not the correct one. So let's do this. So we want to work with aesthetic scope. So this is our definition of closure. And this is what I want to do. I just have to reload it now. So okay, we should be in a better shape. Yes. Now, of course, we don't know which function was called because I put the error messages in both case the same. But in any case, I think we're here, right? Now let's do something more interesting, where we actually have the function to have some value. So one possibility is that you know, the function is not defined in the expression, the function must be defined outside, it's defined in some in a dictionary, so you could say the function is actually the following one. The function just says the function as a formal argument, x, and its value is

Unknown Speaker  1:22:53  
var.

Unknown Speaker  1:22:55  
x plus was a mistake. Just last week, I was typing okay. f x, and then plus more fix, non 12, say.

Unknown Speaker  1:23:30  
But I also have to give an environment let's, let's pretend that at the moment when the function was defined, there was nothing in the environment. So and that's fine, because for F to be a function that just takes any x and that's x to 12. I don't need to know any more names.

Unknown Speaker  1:23:50  
Oh, no.

Unknown Speaker  1:23:53  
Well, this is incredibly sad. I won't make this mistake again. I'll do it here. Evo. Cold. Number three.

Unknown Speaker  1:24:17  
Sorry for this.

Unknown Speaker  1:24:19  
So in the dictionary, where f is one last time x plus

Unknown Speaker  1:24:30  
the empty environment shows this. Close that. That's what I wanted to know. I won't close it anymore. And we're going to complain about this expression was expected to have type expert but has to Why are you telling me this?

Unknown Speaker  1:25:11  
other parents are in the wrong place now? The meaning is this. Yes. What is your problem? This is not the closure. Okay, so this is a proper closure. That is good. So what else is missing?

Unknown Speaker  1:25:52  
Yes, this is a good dictionary. What went wrong than before? Evil once? which kinds of evil? Are we using? Evil takes an expression of value environment and returns a value. Yes. So, who was not correct? Do we want to put the parameters? Right? Yeah, exactly, yes. And it was correct before but because I made this mess at the prompt this happened.

Unknown Speaker  1:26:28  
And now I see 15. Why? Why is it 50? Because we are making a call of F on number three.

Unknown Speaker  1:26:41  
And, and this is what it is. As the expression, f is not defined locally, so I have to look for the definition outside the definition outside is here we are in a dictionary where f has this value. And it looks like this. Now, let's vary this a bit, I could say, maybe also do this here. So, let this one be a bit different. Let the definition of F actually be that we are adding together x and y.

Unknown Speaker  1:27:21  
Yes. Let's see what happens. Well, if we just do this, why is not defined anywhere, right? It's there is no like local definition in the expression. There is also nothing in the dictionary. So we probably will get the problem. But But let's see, we should be syntactically correct. So we should get the runtime error. We don't get the runtime error, which is why not found. So where can we provide the Why? So one idea could be to simply say we also have an author, why do you think this will work or not? Which could be say 42. Is this good? Or is it not good? Well, we can ask the system I should say I 42.

Unknown Speaker  1:28:21  
Correct?

Unknown Speaker  1:28:25  
We get stopped to error, we stopped you to error. And what's the error? Why is not found again? Why is it not found? Well, when we evaluate the function for where do we get the values of all variables mentioned in the function definition? Well, we get them from the environment that was recorded at the point when the definition was made, right. So suppose here, I also say Y is maybe I not 42? Like 1011. Let's see what then happens. Now the interesting question is, will 1011 be used or 42? Well, the indication is 42 didn't help us anyway. So maybe it's 1011.

Unknown Speaker  1:29:15  
And indeed, we get 1014. Why? Because when we make this call, the way it works is we evaluate this guy, this is just an integer three, then we say Okay, now let's evaluate f itself. They are they're actually the definition of F, which is this guy in an extended environment where we record that x is three. And we can also use the environment that was remembered that the moment when the function definition was made, which actually happened before we were born. I mean, it's already here in the dictionary. We don't know from where this came, I just wrote it. I made it up. Let me complicate it a bit further. Let's try to define a why locally here. So I could Very well say let y be. What's another number 85? In this call now, my situation, yeah,

Unknown Speaker  1:30:14  
I have a question. Are we using the dynamic or the

Unknown Speaker  1:30:20  
other mods? Because I want to change it to dynamic and then something should go different, right? Yes. So my point is now 2011, sorry, 1011 help us. This is the one that actually made things work, this one was ignored. Now, I want to show you that this one is also ignored. Why? Because this is some definition of y that is made after the definition of F has been done, f is defined already outside. And at the moment, when f was defined, it looks like the Y at that point was 1011. So the local definition shouldn't shouldn't matter. Do you agree? Although my expression now looks like let y equal 85 in F of three. And then when I do this, hearing, the prompt, of course is impossible to read, then we still get 1014.

Unknown Speaker  1:31:24  
So then we could internalise the function definition in the expression right now it's written outside. But a small variation could be that we say that the whole expression is say, what it could be that we do the whole thing in, let fun. What led fun f x, then this plus finger here, all of that in the other lap. And now I don't need this silly thing in the dictionary. Now it's all in the expression. And maybe I could make it even more interesting by putting another letter outside where I defined that y is 1011. Like what we wanted to. So when I say let y 1011 in lead fun, blah, blah, blah, close many parentheses. Even more. So what's the structure of this we've got the threefold nested lead various the outside lead, where we define y to be 2011. In that whole thing, then there is the next inside leg where we say f of x is the sum. In a further left, where we say that the neener y is 85. And then we call F at three. Let me just once more, check that my parentheses are all good. So this is that lead, then that lead and that lead Geneva that's all good. And from the outside, why is 42 so what is 42, then next one is 1011, then we make the definition of F, and then there is a further y which is 85. And then finally we call F with three

Unknown Speaker  1:33:34  
it's still 1014. Now we've got all of these examples, let's do dynamic scope, dynamic scope is exactly the same, but I have to change the common thing here. So in the closure, I need to remind remember much less So, let me comment out the one for static scope that we comment in the one for dynamic scope. So now my my closure will just only remember the parameter of the function and the definition of the function nothing else. I mean, I could still remember the current environment at the point when the function is defined, but why because I would not use it. So there is less to remember. And then of course, I have to change things here. So I want to comment this one out.

Unknown Speaker  1:34:27  
I want to comment this one in I should not forget to actually load the whole thing.

Unknown Speaker  1:34:43  
And then we will very soon be done. Thank you. Um so here's the dynamic scope version. Let me see if I can show you both at once. Of course I can't. So, so what was land let fun for the static case, it was simply that when you see a let fun, then you have to record the closure that you learn from this function definition, which consists of the parameter, and then the definition of the function. And then you also record the current environment. For dynamic, it's exactly the same. But since our notion of closure is different, we don't record the end anymore. I mean, previously, in the static case, we have n here. Now it's not here. Yeah, that's different. So this definition time environment is not recorded in the closure. Now, how does how does this thing differ? So the corner case, the only difference is really here. And here. So the good case is if what I'm trying to call is really a function, because if it's not, then I should say it's not the function. But if it is the function, then I should use what is the closure according to the dictionary. And Previously, we had this n zero thing here, which recorded what the environment was when the definition was made. Now this one is gone. So that's one difference. The other difference is, previously we used n zero here. So we worked. As soon as we went to the evaluation of the body, we forgot about the current environment. And we went back to the definition time environment. Here, we don't do this. Because we haven't even recorded it. So we can only work with the current environment, and we just extend it to whatever with whatever we learn is the parameter value. And then the closure just for making recursive calls. Yeah, so n zero is gone from this point, it's not recorded. So that's one difference. And the other one is here, we don't use them zero, because we don't even have one to play with. very minimal difference. And sort of the over I mean, the overhead that is now gone in this implementation is that you never have to store these definition time environments. You know, if you compile it into into stack machine code, there will also be a little overhead in the static scope version, which goes away in the dynamic version. Now we can we can look at these same examples, again, are these variations. So what were they?

Unknown Speaker  1:37:54  
This one makes sense, except I have to slightly modified because the closure doesn't know contain a dictionary. So this was where we started. Not with the wrong number of parentheses somewhere. Yes. Now, that's already different. Because with a static scope, we had that, for this function definition to make sense, we already had to have meaning for x in place when we made the definition of f. So I mean, with this dictionary, empty, nothing worked. We later put 1011 there, right, and then it worked. Now, I'm not even recording anything, but this guy miraculously finds out that this is 15. And why is this?

Unknown Speaker  1:39:16  
No, no, I'm running ahead of myself. So this is of course 15 because there is not yet why. But suppose I replace num num 12 with variable y. Then it will complain that the Y is not found, right. Why not found I can do a little modification. I can in the same dictionary introduced that y is any less 11. Now at the moment where the definition of f is made, why it's not yet No later I introduced that, why is 1011 and this will already work? Because the function definition of the function called here, the definition is here will be used in the current environment of the call. And when I evaluate the call, why is already 1011?

Unknown Speaker  1:40:23  
Yes, so we get I don't understand extra parentheses now. Did it print two lines on top of each other? What is this thing here? Do we?

Unknown Speaker  1:40:45  
Yes, sorry. So 1014 that works. And then finally, I can I can make this local. So we can, for example, call this one. That's the same kind of code as what we had before. But the answer will be different. Why? Let's see.

Unknown Speaker  1:41:06  
So let's think what the answer should be. So we, this is the whole being expression, the outer y is something that is provided was top level from the environment is 42, then we make a local definition. So there is a local y, which is 1011. Then we define the function. At this point, y is 1011. But we go on, and we introduce a yet more local wine, which is 85. And then we call F with number three. At this point, surely, we will take into account that the parameter x is now three, that's not controversial. But what is why? And we will use the why of the current environment. So this time, it should be ADA. The answer 85 plus three is ADA. Let's see if this happens. And we do get that the answer is ADA. So this may look complicated. And it clearly is. things to learn from today is there is two possible study, sorry, scope rules. One Where is one is where you define where you take the meaning of any variable from the body of the function to be determined at the site of the definition. That's called static scope. And it's good software engineering wise, it gives you readable code and meaningful code. There is also the dynamic version, where you determine what the function means only at the moment when it's called, which means that in different call sites, the function can obtain a different meaning. And even in the same call site, it can obtain a different meaning if you arrive at this call site, from different directions, so to say, during the execution of the code, which we didn't see in action today, but we'll probably later. So modern languages use the static scope. Historically, dynamic was invented first, because it somehow felt intuitive. But then people figured out this is not the right thing to do. The still used in parallel, and some dialects of Lisp. Implementation wise, it all amounts to whether you have to record what the environment is at the function definition site. Which is the case with static scope. And in the case of dynamic scope, that's a bit easier to implement, then you don't have to remember anything extra in the closure other than the function definition and the parameter name. And this is it. So next time, we will make this simpler, I'll show you like a modification of the lexer and parser, we have for this thing, this will really not, you know, this is not central anymore for us. But then I'll explain you how type inference works already in this simple case. And you see that dynamic scope is really problematic. Exactly for the reason that this the same function call can be reached in different ways. And also there can be multiple calls of the same function at different sites. And it's very odd if the function means different things at different call sites. Does this make sense? Yes, lecture was pretty clear. Yes, it is sort of technically messy, but you have to let the ideas sink in. But it's, it's always the idea that sort of outer scopes are shadowed out by the inner scopes, but then the difference between static and dynamic doesn't Until you have functions, but when you have functions, then you discover that you know what is what is what is in here and what is out there is not so completely clear. And if you start to make it clear there is two possible disciplines at which you can arrive and and and they really diverge in a drastic way. Okay. Maybe then we say that is it for today. Did you write more things in the chat? I haven't. Since I was sharing a conceit

Unknown Speaker  1:45:36  
No, I think we're

Unknown Speaker  1:45:38  
okay. Yes, I think we're good. Okay.

Unknown Speaker  1:45:44  
Good then. So, um, do do talk to the TA, to ask questions to them as well if you don't get answers from them. Ask me and as questions on pizza and then we proceed like this. So I stopped the recording here.

Transcribed by https://otter.ai
