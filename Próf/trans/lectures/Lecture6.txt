1:52  
Hello, can you hear me? Yes, very good.

1:59  
I think we're about ready to start.

2:36  
Okay, so Hello.

2:39  
This is the second part

2:41  
about expressions. And we'll do something more interesting than than last time. And I'll introduce you to some more sort of general concepts that you see in every type of language. And we have to think about these together.

2:56  
So just to recap very quickly, what we did last time, we looked at two languages, really one was expressions.

3:08  
And then there was also the stack machine language.

3:14  
Yes, and I emphasise that there is difference between concrete syntax,

3:20  
which is writing down expressions as strings

3:24  
versus abstract syntax,

3:28  
which are abstract syntax trees, that the abstract syntax is the one with which we want to work.

3:35  
And then we said, well, the point with expressions is not so much to be able to write them down or to read them out, but that they stand for something for which there is a meaningful way of executing them. Namely, we simplify expressions, because we're after the value of the expression. And then we said there is two ways or two workflows for doing this

3:58  
interpretation

4:02  
versus

4:04  
compilation

4:08  
where interpretation meant

4:12  
evaluate expressions directly. And this is generally the idea that

4:18  
you have some sort of

4:22  
little abstract machine or computation platform on which you are able to evaluate your programmes or run your programmes directly, where compilation goes into stages.

4:38  
So here, we going to stack machine code.

4:44  
And then we evaluate that

4:48  
by interpretation, but interpreting different things. So now we interpret stack machine code.

4:55  
And it's important to realise that of course in real life, there can be a

5:00  
stack of languages. So, so very typically is that you have at least one or two intermediate ones.

5:07  
So, if you for example take Say,

5:11  
say Java,

5:13  
then the idea is there is this intermediate language called Java, Java byte codes or Java virtual machine code. So you can

5:26  
you can interpret Java programmes or you can just in time compile them into into Java bytecode.

5:33  
But Java bytecode itself runs on a set of a virtual machine, but that's not the actual machine you own. But rather below is his actual machine code. So, we've got like three different levels of languages there like there is there is Java, there is Java bytecode. And then there is the actual processor code. And

5:58  
yes, when you want to process your your Java programme, you either have to be interpreted to be able to interpret it directly in some sense, or you go via the JVM, the Java virtual machine code.

6:11  
What do you say? Well, really, the way I explained my Java programme is I look at, you know, the actual machine code, I could, in the end of the day, compile it down to

6:22  
why you do have these intermediate languages, there are several reasons. One is that sometimes high level languages are very complex, there are very many constructions for the convenience of the programmer. But most of them can be rendered in terms of some other constructs, they don't really need so many. So so the intermediate language typically is a smaller one sort of easier to easier to handle. So surface level things you handle by compiling from, from the source language to the mean, intermediate language, that's one. But another reason very often is interoperability. Like you may want to run your Java code on very different processors. And all of these processors have different instruction sets. So in the end, the machine code is different.

7:08  
But, but Java bytecode is platform independent. So this is this kind of an

7:15  
ideal idea of what machine code could be, that has little to do, or that has something to do but but not so much to do with with actual machine code. So for interoperability, it's nice to have these intermediate languages because then you can compile many different languages to the same intermediate language like Java perhaps, could go to JVM, but Scala code could also be

7:39  
translated to to JVM, Java virtual machine code. That's the idea.

7:44  
Okay, today, what is going to happen is, we will say these expressions are a bit too primitive.

7:51  
So we want to enrich the language a bit and see what kind of issues arise there. And there are quite a few immediately. And we'll only do two things, time permitting. The first one is,

8:04  
let's suppose we also allow variable names in expressions. So

8:14  
first, we add names. so we can write something like three plus seven times x,

8:20  
maybe divided by wine or something.

8:24  
And then the second move we do is we introduce a little bit of block structure into expressions with the idea that some of the names

8:33  
could be not top level, but local, so visible only in a part of the expression.

8:40  
And then we also get to the idea that you can start reusing names. So if some local scope, you don't need that some outer scope name is visible, you can actually reuse the altar name for a different purpose in the locals scope. Yeah. So why would you do within a single expression, perhaps,

9:01  
there is not so much reasons. But they but the but the overall principle is everywhere, right?

9:07  
You want to write your own programmes using your own names. And you don't need to you do want that you shouldn't worry about the names that perhaps are used in the code of the library functions, because you haven't even seen their code. So there should be the natural idea in every reasonable programming language that you can make names to have a bit of a local scope. One is reuse of names, but other are simply like practical hygiene. So if many people work on something that in the end will will form one piece of code that runs together, then surely different developers name shouldn't class clash with each other just so that you should be able to control what do you expect to expose to your your pals.

9:55  
So that's, that's the programme for today. And we do it in the same way as as a Tuesday.

10:00  
So so just playing on the simple example and showing what what sort of adding features means to a programming language, what it means for interpretation of what it means for compilation.

10:13  
Does this make sense was a planned?

10:18  
Someone's there?

10:22  
Hello, hello, hello.

10:24  
You're they're very good. So just shout when when you have different ideas or questions or just even viewpoints because it would be nice to actually talk a bit.

10:37  
Okay, we're not going to do too much to begin with, I want to represent our talk about these expressions that in concrete syntax, we perhaps write down in these kinds of forms write expressions like last time.

10:50  
So we do basically arithmetic, I can write down numerals, there are some operations that we have for operating numerals that stands for that stands for integers. But then I want to be able to also have variable names. Now, of course, one of the things we need you to see is, as soon as you introduce variables, an expression doesn't have a value on its own, right? I mean, how can you possibly say how much three plus A is, if you don't know anything about a or if you haven't made any assumption about the

11:21  
and that will bring us very soon to the idea of

11:25  
the environment.

11:28  
And

11:29  
when we use the same word environment like that you do in nature protection or so. But the idea is exactly the same. So I mean, there are expressions, but then there is something surrounding them, or something that is outside the expressions, that sort of makes a nice place for expressions to live. And that we call environments. This is the official terminology.

11:50  
Before that, let's just fix then what our expressions are. I do it with this recursive data type in F sharp so that we can actually play with these things.

12:00  
And it's pretty much the same as before last time, at one point Tuesday, so I'm able to write at least two kinds of expressions, numerals, which are just the attack norm, or the data constructor norm followed by an integer, or a data constructor attack up, followed by an operation name, and two is two expressions.

12:22  
So these were the two constructions that we saw before, we just add one more, we see an expression can already can also be a variable or a name.

12:32  
And this is indicated by the tag var for variable.

12:38  
And every variable has a name. So we also provide a string.

12:42  
And we are very generous. So I don't want to limit the kind of strings that you can use this very variable names at all at the moment, because that's not that's not our sort of concern here. Of course, you can have lexical conventions in the language saying, you know, variable names should be strings like this, like starting with capital letters, or cannot start with capital letters, or may not contain special symbols or anything, right now, this is not a concern.

13:07  
So once I've done this, I can already start to play a bit, but not so much yet.

13:27  
So I can write down my own little expression. So for example, this one is going to be an expression. These are difficult three expressions, we could do with a pretty printer, it's not hard to to extend the pretty printer that we had to also cover variables. But let's not bother about it right now. So we just worked with these abstract syntax trees. So we can see that these three things in particular, they're really legitimate expressions in the sense that

13:53  
when I when I when I entered them at the prompt of the interpreter, F sharp agrees that these are legit expressions.

14:07  
Now,

14:10  
this much about syntax, let's not worry about pretty printing or parsing right now, we just work with these abstract syntax trees.

14:18  
Suppose I wanted to compute with these expressions, I really wanted to evaluate them, which is the main reason expressions exist in the first place. How could I go about it? So, if I ask you,

14:31  
what is v times nine plus a?

14:35  
Then you should reasonably tell me we do not know unless we make some agreement about the value of a and the value of b.

14:46  
Yeah, so an expression doesn't have a value by itself What do I need to provide as extra fun expression to obtain a value is called an environment here in this particular situation and environment is a simple thing.

15:00  
It's an assignment of values to names.

15:07  
In this language, I'm not really, there are no declarations. So I can use any names. I'm not saying like in this expression, only a and b are available.

15:16  
This is nothing like I would declare an A and B to be integers. So in principle, any, any name could occur in any expression. But in order to evaluate an expression, what we need is that

15:29  
we know values for at least these variables that are around. So for example, to evaluate this one, I don't need to know what b is. To evaluate this one, I don't need to know what c could be if C were another name. But surely I need to know that NPR.

15:44  
So an environment is an assignment of values to variables, at least those ones that are important for us that in some sense, are in the global scope, although we haven't introduced this concept yet.

15:55  
So

15:57  
what is it really,

15:59  
so a way to represent this, that is also very reasonable, it's kind of a dictionary data structure. So in the simplest way I could, I could write it down as a tree, perhaps you would want to do it as a search. Or as at least, you could also do it as a kind of a search tree.

16:17  
But for the moment, at least, we'll do. So we could say that the environment to have an environment is the same thing. So this is a type synonym declaration as to have a list of pairs of strings and integers. And the idea is that I just tell

16:33  
which names I'm associating to which values, people also often say you bind values to names.

16:41  
Not that they like this word very much.

16:48  
Because you use the word binding also in another meaning here in this context, but people often say this.

16:57  
So this could be, for example, one particular environment. So indeed, like, if I type check this thing.

17:06  
The next stop agrees This is a list of strings and integers. It didn't tell me it was an invalid invader. But then there is a synonym for this thing. So this is fine.

17:19  
So in computer science, we use very many different names for this kind of data structure. So strings of sorry, lists of pairs like this, I use dictionary here, some other people would call this thing Association list, which is exactly the same thing.

17:34  
And you could also say that, like key value pairs, which is kind of reasonable to hear, we use variable names as keys. And these integers as values is a little database where you can look at things.

17:47  
That's what it is.

17:51  
In order for the environment to be helpful for you at all, you have to be able to look up

17:59  
values for keys. Yeah, here values for names.

18:04  
So at the very least, I would need to write

18:10  
I mean, to write an interpreter for expressions, I surely need

18:14  
to be able to look up values for names in an environment. Do we agree this right? I mean, if I need to calculate this thing, it would be so nice to know that A is actually three in this environment, and B is 111. Because then I can work it out that the value is worried 11 Plus, sorry, is 999 plus three, which is probably 1002.

18:40  
So let's write a quick look up function. And then we can go on to more interesting things.

18:47  
I'll do this.

18:49  
So what comes in, where is the variable whose value I'm interested in? There is the environment that is given to me, and I just want to get an integer, this thing may fail. If the dictionary is too thin, it doesn't contain the word right, it doesn't contain the variable name, then well, then you simply have to lift up your hands and say, Sorry, I couldn't do it. So this happens,

19:14  
like this here. So we do look up by pattern matching on the environment. If the dictionary is empty, you can find anything there, including you can find x.

19:25  
But otherwise, we reduce the bigger problem to a smaller one. So if the dictionary is some first variable name and value pair, then it's nice to check maybe the first entry already matches.

19:40  
If yes, then I extract the value otherwise, I get go deeper into the dictionary and look it up. Right. This is a particularly silly dictionary, which is not ordered lexicographically like ordinary dictionaries are so it just, you know basically you have to browse through it and hope you find your your your your variable name

20:00  
So

20:02  
let's do a few examples. So this is an example of an environment Actually, it's already loaded. But I can do it again anyway.

20:10  
So here's a dictionary called n. And now I may be interested in looking at that various

20:19  
names in here, actually, this order is wrong.

20:27  
So I could go

20:29  
look up a in here, in this environment.

20:33  
And the thing nicely, it tells me it's three, I can look up the value of buff should be 666.

20:43  
And it is,

20:45  
I have the, I may have the bad idea to look up D.

20:50  
And I just get a lot of swear words, but the main point is somewhere here.

21:01  
This, this is actually the error messages, I wanted to provide D not found, right.

21:07  
And the rest is more information, which I really shouldn't.

21:13  
Now at this place, you should ask a question,

21:18  
which is the following suppose my environment was a little different?

21:23  
Maybe I had another eight here,

21:29  
which was five perhaps?

21:34  
What do you think will happen if I now look up a

21:42  
ticket both for just first one?

21:45  
Yeah, unfortunately, I only get the first one. Why?

21:52  
Well, I could do something so that I could retrieve them all. But then I would have to write a slightly different type of a function, right, that would basically take in a name and an environment, and would return perhaps a list of integers, which would be the list of all possible values,

22:08  
that would be quite a nice thing to do in the sense that then actually, I wouldn't need to raise an error here. Because then if there is no value, say, for D, I would just return the empty list to see this.

22:19  
Which is nicer to work with, you don't get this danger of runtime errors. But somehow, morally, this is the wrong thing to do.

22:27  
Because it turns out, it's quite useful to work with such a structure, where it's possible for a dictionary to have the same name twice.

22:37  
Namely, you can later use it to model the idea of scope.

22:43  
And things will end up in your dictionary, if you do it right, in such a way that the names that are more local, or say, you know, are in more inner scopes,

22:55  
will appear in these environments like these. So they're more toward the front. Whereas

23:03  
names from outer scopes, which may coincide, right, they can be the same names would appear deeper in the list. And then when you get a free lunch, which is an extraordinary thing, right? In the sense that you then don't need to do anything, you don't need to put any extra care into getting this sort of shadowing thing. When you reuse the name you, you you, you start to local scope where you have a different definition of a name.

23:36  
You don't need any unique don't need to do anything to to make sure that the shadowing works properly, because things just work in your favour without any effort.

23:47  
from your side, isn't this nice? No, you won't see this right now. But but it will come later today. What you could think this was the locally and this was maybe the A from the you know, from the next outer scope or maybe from the top level or so.

24:05  
But for the moment, we don't have in the language, any scoping mechanism. So we think this is just a flat list. So if I happen to have some the same name place, then bad luck, the second occurrence is just useless and the third as well.

24:21  
But what we've done for now is actually great, because now I have a very simple interpreter for my language, just by modifying the one from the last time by adding one single new line

24:36  
and the rest is literally the same.

24:55  
So let's remember how did we do running

25:01  
expressions before,

25:04  
or evaluating them. Before I had a little function eval, which was defined recursively, because I needed to pass two cases, to do case distinction on the expression, but also

25:15  
recursive calls in the more interesting cases, and expression comes in, and an integer should come out.

25:24  
And I already said this won't work. Now, if we have names because solely an expression doesn't contain enough information, because you have not, you know, nothing what to do at variables. But if we provide an environment as an extra argument, so this thing will now be a curried function with two arguments coming in one by one,

25:46  
when an integer comes up,

25:51  
let's see what to do.

25:56  
Let's actually look at the old cases a bit, because they're not exactly the same as before there is a minimal modification. See, because I make these recursive calls to eval, formally eval to one argument. But now of course, it has to take the extra argument as well. So suppose I want to add together two expressions.

26:17  
And then I want to know the value. So find eval of this thing up? That's my big problem. What could be my two smaller problems that helped me to solve this one?

26:28  
If, if recursion manages the smaller problems?

26:32  
Well, it's, of course, obviously, to evaluate v one and v two.

26:36  
But these guys need to know some environment, they need to know the values of their variables.

26:42  
Which environment should they use?

26:46  
Well, there is only one to play with, which is the one that comes here.

26:51  
So if I want to evaluate the whole thing in the environment, and then surely,

26:57  
I mean, that the variables in the sub expressions should also be interpreted in exactly the same environment, right? So this n is passed down, was handed down to all these recursive calls.

27:09  
do agree? And they don't have to change it in any way. I mean, it would be very stupid to say that, on this level, I know that A is nine. But I don't want to let you want to know about this. So just remove it from the dictionary that doesn't feel right thing to do.

27:25  
Then if you have to evaluate the normal expression, like nom, 17, it's just 17.

27:31  
And then there is only one

27:33  
really new line, which is this. So if you if you are at the leaf or abstract syntax tree, you see a variable.

27:40  
What is its value?

27:43  
Well, it doesn't have any absolute value. But there is something that we've decided in the environment, we just look up text in the environment.

27:53  
Let's see if it works at all. So if I want to do eval, what can I have? eval num 17

28:02  
then this can be done in under any environment. I mean, I don't really need to know the value of any variable for that week.

28:09  
So this is 17. By the way, it's 17. Also, if A is 13.

28:17  
It's also 17. If, if b is also nine.

28:26  
Hmm, but what are some more interesting expressions, maybe something like var a.

28:34  
This one is 13. Because we can look it up in the dictionary, we can also look deeper in the dictionary. So for example, B is not the first entry in the dictionary.

28:44  
The thing will find it if I want to evaluate C in this environment,

28:50  
then just just swear words.

28:54  
And the expression can be complicated, right? So it can be very interesting to use this machine as a little calculator.

29:03  
So I do

29:05  
plus

29:07  
apply to these two things. Variable a variable effects.

29:13  
92 parentheses 22.

29:18  
Does it make sense?

29:22  
Anyone? There's still questions.

29:28  
Hello, hello. Hello. Hello. Yes, so we haven't done a lot. I just introduced one new notion to you and vironment. This is very common, right?

29:38  
And if I'm in a language, which is functional, so variables, don't ever change their values during the course of the programme. And if there are no local names, then there is one very little thing here that you work with, which is basically like one fixed dictionary, which you pass into the recursion

30:00  
Every one can see, you know, the lower the lower levels of the ASD so to say nothing else can happen. But of course, this will change a lot when we get to more complicated things.

30:13  
Now let's do something a bit more realistic. So what?

30:17  
What sometimes happens, what very often happens is, you of course, think of your environment as something stored in memory, isn't it? Like, you know, you've got your memory, yes. And then there is a little symbol table, which will tell you that maybe a is located at cell,

30:35  
whatever

30:37  
1011 and maybe B is located at cell 1012.

30:42  
And when you actually evaluate the programme, then you don't work with these names anymore, you actually work with these these cells or locations.

30:52  
Yeah.

30:54  
So

30:59  
we could do that.

31:01  
So let's, let's play a little game.

31:09  
We will work with two kinds of expressions for the moment, for the time being, they're going to be source expressions, which are the ones that we just saw. And there are target expressions

31:18  
that are like expressions in a little intermediate language, which is almost the same as those be the one we had before expert. But now we have the expert. The only difference is that, when you see the type T bar, you're not told the variable name, you're directly told where this variable is in the memory. So it's going to be. So here, we model it simply by a number, of course, realistically to be a word, like maybe two to the power of 16, or something, or 30 to

31:45  
some number from zero to that minus one. But here, we just model it with integers for simplicity. And that is that is all the reason. So variables are numbers, rather than the name, and you can think of them as kind of addresses in memory, which is a useful way to think.

32:06  
So now I'd like to play this little game that we look at two workflows for source expressions, I either interpret them directly, which we already done, but then I could play the game that I translate target expressions,

32:22  
sorry, translate source expressions into target expressions.

32:26  
This works if I somehow decide which variable goes where in the memory. And then I can get rid of variable names in my expressions, I just replaced the variable names by the corresponding addresses.

32:38  
And then I could interpret this this target expressions directly.

32:43  
So again, that is like interpretation versus a little compilation followed by interpretation of a slightly different language. Yep.

32:50  
You see this target expressions, source expressions. And then sorry, source expressions, target expression, either interpret source expressions directly or compile them into target expressions and interpret those.

33:05  
So let's do this. This actually all fits on the screen, there is nothing more.

33:11  
Maybe there is a couple more lines below. So target expressions are the same as expressions except that every variable comes together with

33:23  
with a with a with an integer. And just to just to be able to tell F sharp whether I mean a source or a target expression. I renamed the constructors here. Now they're not called var lumintop. But they're called to our teen on the up just for default target.

33:40  
Yep.

33:43  
So I can write

33:45  
what what can I write? I can write like Keenum.

33:50  
17. This is now the target. What happened?

34:02  
Yes, thank you.

34:07  
Tina, I'm 17 is the target expression, but also for example, fever one

34:14  
plus t num 17

34:18  
will be which I can write down like this

34:27  
is correct.

34:32  
This also has to be cut.

34:34  
So that is a target expression to see this.

34:38  
And

34:40  
then what do I need for interpreting target expressions?

34:45  
I also need the notion of an environment but now we can be slightly different. I don't need a dictionary, it suffice is just with a list of integers.

34:56  
And my idea is that

35:00  
You know,

35:02  
the value at address zero is at the head of the list the value at address. One is the next one in the list, the value at address two is the next one in the list. And you can basically extract variable values simply by indexing into the list.

35:18  
Yeah, if you do this, then this is exactly what we need. So I will say runtime environments are in there to just to distinguish them from these invaders that we had before. They are just lists of integers.

35:34  
And then I can evaluate the target expression with respect to a runtime environment and I get the value. The programme is exactly the same as the evaluator before except that I need to do a different thing in the T var case.

35:46  
So I don't do look up by name.

35:49  
But I do sort of look up in memory, which is organised by addresses. So of course, you know, in a real implementation, you would want to have an array here with direct access rather than list. But just for a sort of simple exercise with the model. Lists are just fine.

36:07  
So this is what we do we just use NF item in the list to extract the value of a variable, and then we're good. So now can evaluate things. So for example, the last

36:19  
the last one, which is called it at the moment,

36:25  
I could try to evaluate it in the environment where I have these numbers 17 1730 1342 and 1011.

36:37  
Now, it is a target expression, you can see it is the last guy here this one sorry.

36:43  
And this is a runtime environment names are gun. But the idea is this is the value at address zero, this is the value at address one, this is the value at address two, does it make sense?

36:55  
Then what do we expect back? So can you beat?

37:04  
Anyone?

37:06  
No, not really, if the target, like the list you're making here, the 13 and 42 and 1011. I talked about the state tax of some list or

37:18  
Yeah, these, this argument here

37:22  
corresponds to this runtime environment that I provide as the second argument to

37:29  
all evil is of course wrong. So I should say t ever let's just push the wrong type there on P. But so so this is the environment and they you should see this environment that's kind of just the dump of the memory.

37:44  
Wouldn't you get?

37:46  
Pardon? Wouldn't you get an error? Because index 17 isn't in the environment? Well, no, no, but 17 I don't have as an index 17 is a constant in my expression.

37:57  
Okay, all right. Maybe I should write it somewhere on the site here. My expression at this moment, morally, is, yeah, something like,

38:07  
I don't know how to write it, maybe like,

38:10  
write it with a kind of pointer. dereference notation, if you wish.

38:15  
Bang one plus 17 in the sense that 17 is just the numeral I get. But t bar here, I want to get the thing from the address one in the memory, right? And 42 is there. Yep. Is this fine?

38:30  
Yes. So the results would be

38:33  
59. Right? We expect but if instead say I wanted

38:39  
what did you know?

38:49  
For example, we looked at the second variable, and maybe we we just studied five twit, or something like this, we should get something different, right? So if I now do the same thing,

39:02  
I'd expect that I do get 1011 plus five, which should be 1016.

39:08  
Okay.

39:11  
This might seem really silly, but it is to illustrate the idea that when you work with names generally in a series implementation, you do Institute some sort of

39:26  
mapping of variable names to memory

39:29  
addresses. And then you have to keep track which variable went where. Yeah, like perhaps should know that this 13 is actually meant to be my a and my B went to sorry,

39:41  
is position zero which happens to have value 13 is is a and maybe B was located position one pepinster value 42 etc.

39:53  
Okay, and that is actually going to be happening next. So suppose my

40:00  
Again, we're now to combine expressions to target expressions.

40:06  
So the idea now should be that I give you something like x plus 17. And maybe I expect that this compiles to say,

40:16  
you know, local variables zero

40:19  
plus 17, something like this. So this is I bang just for this little dereference here.

40:31  
How could I possibly do this?

40:34  
Well, I cannot sort of on my own,

40:37  
because somebody has to tell me that I'd quite like that you put x at address zero. And I'd quite like that you put w at address 45 or so.

40:48  
So again, you need

40:50  
a sort of an environment. Basically, you want to say which variables go where,

40:58  
in terms of addresses how to model this.

41:02  
So one simple trick we could do with is we just work with something that we call cn, we're here C for compile time environment. So it's just something that only exists in compiled time. When you've combined, you can throw it away.

41:17  
And this could be just a string of lists, sorry, a list of strings. And then the idea is,

41:24  
by taking your environment to be a string, like, sorry, a list of strings like a be

41:33  
the boss,

41:36  
I expressed my intent that he should go to address zero and B should go to address one and pH should go to address two while I compile.

41:50  
Right?

41:53  
Yep, makes sense. Makes sense.

41:56  
So how would you then do the compilation? Let's see, let's look at that one first. So an expression comes in what should come out a target expression.

42:05  
And now to link the two up, I need to decide which variable wants to go to which address, which is the CN thing here.

42:14  
That's a little recursive programme. Obviously, every numeral I have in my expression just becomes a numeral in the target expression. So gnomes become genomes.

42:24  
Because we use different data constructors, but it's really the same thing in terms of concrete syntax, write an op similarly, go to T ops. And of course, if you have to compile an op,

42:35  
which has two sub expressions, you run into e to the task reduces to be able to compile the smaller expressions, right? As always, in recursion, this is going to be my slogan, until the end of March. Yeah, reduce bigger problems to smaller ones, until they go away. And so if you can trust recursion to make them, make the small one go away without you having to care about it, especially specifically, when you've set up things, right.

43:04  
So that's almost good. But then, of course, there is one little clause to write. So var x where x is a string has to become t var, something where that something is, is of type int. Yeah. So names have to turn into addresses.

43:21  
I agree.

43:24  
So how do I do this? Well, basically, if somebody gives me a compile time, environment like this, so then when I am asked to compile B, then I have to say, Okay, yeah, B has to go to address one. Why? Because B occurs in this list, at position.

43:45  
One. So what I need to write is a little function that given a string, and the list of strings, finds out if the string occurs in the list of strings and tells me at which position this happens.

44:00  
So you do it by recursing on the list.

44:06  
If there is nothing in the list, you're at the end of the list, then you say, okay, sorry, cannot allocate it to any address, because, you know, you haven't planned anything for that particular string. Otherwise, if the compiled time environment is a string, followed by more strings, so why is this string cn is a list of strings? When you check if the given string agrees with the one that you currently see? If yes, then you say, well, it's zero, because with the head position, otherwise, you'll have to, you'll go deeper into the list. And you'll find if your string occurs there, if you find it there, at a certain position, so now then in this list, it has position one deeper, yeah, if something occurs here, position five, it will surely occurred here in a position six. Yeah. Because instead of looking at the list, cn, and I'm looking at that at a longer list, why consider

45:01  
That's the programme. Maybe I should show it to you in action. So if I do like get index

45:09  
of what? D in this thing here.

45:21  
There's no t in the

45:23  
wrong order of arguments, right? Yes.

45:29  
Then these not found, but when I look at for something reasonable, then I'm told what it is. So this is, this tells the compiler where to put bar when you see in your code.

45:44  
Okay, and now we can do some little examples. There is this example e three that is already loaded. I've got no idea what it is, but we can look at it what it is. So it is actually this one.

45:55  
So it is b times nine plus a.

46:01  
And now we can for example, say

46:06  
compile it.

46:08  
Yeah, into a target expression.

46:14  
What happens we should get an expression that looks pretty much the same as this except every op has become a de op, every norm has become a genome simply because these are sort of tags for a different expression language. but crucially, B and they should be can. And he had a he has become zero, B has become one. Why? Because I decided, so to see this.

46:37  
Of course, I could have decided something else. I could have said this is not at all how things are things are maybe like this,

46:46  
oh,

46:48  
sorry.

46:51  
Press the wrong key.

46:57  
Maybe, maybe I want to say things are like this, which actually makes it even more interesting.

47:06  
Now, what do we expect.

47:08  
So this is the expression I want to compile again. But now in a different environment.

47:16  
I'd expect that this var B becomes actually

47:20  
D var one again, because b is still at position one. But a is at position three, isn't it

47:28  
0123.

47:34  
And, of course, when I just don't give the compiler idea, an idea what I want to put this in variable, like I say nothing about a then compile the compilation phase with a lot of complaints.

47:51  
So previously, we talked about correctness or combination, let's play this thing here as well.

47:58  
So when you have two different workflows, it's very important

48:03  
to be able to say

48:06  
what you mean for them to be the same. And then to make sure that they really do the same thing.

48:19  
I would say we want the following thing.

48:22  
So, if I evaluate a source expression directly in some given environment,

48:29  
that should really be the same as

48:35  
compiling e with respect to some compile time environment, which is just the list of streams

48:43  
then I get the target expression right and then target evaluating it in some runtime environment. Now, of course, these things will not always be equal, but n C and n Rn

48:57  
have to agree suitably to agree.

49:06  
And in what way suitably Well, let's figure it out.

49:12  
The idea of course, is that you know, for for corresponding names here in the environment.

49:19  
You'll find the same values here at the corresponding addresses.

49:25  
So the idea should be that

49:31  
at whichever address, sorry, whichever address you work with, the following should be the same thing.

49:39  
The value at that address according to the runtime environment,

49:45  
but also what you would get, if you look up the name of that address, in the compiled time environment.

49:57  
And then you look up the the name you found up

50:00  
In the original

50:03  
dictionary, which was with associative values to

50:08  
two names, right. So you can always make these kinds of statements is important to make sure that they are actually upheld.

50:20  
Let's, let's build now one more level of a language. So we had a source expressions, target expressions, let's have a yet lower level language, which now can be a state machine again, because we already had the nice tech machines, we should simply be able to adjust it somehow.

50:37  
That so that

50:44  
so that it also works with with these names and expressions, global names and expressions without any specific scope story.

50:55  
So what do I need to do,

50:58  
I again need to revisit the bit of code. So it looks like a bit of code. But it's a whole lot of code. I mean, but, but really, the changes are super minimal compared to what we had.

51:09  
This is the old art answer language. But I've added one new

51:14  
command,

51:27  
which is

51:30  
called our load, it takes one argument, an integer, and this integer, you should read this as an address. And the idea is, you take a value from an address morally than

51:42  
in some sort of a heap.

51:45  
And you place it on top of the stack to move thing, don't move action to copy a thing from the heap to the top of the stack. So the load here is, is from a runtime environment, I should stress it. So this is like memory represented in a list. Yep. And then all these things

52:07  
that we already had before.

52:09  
So that's a single instruction. And, and a piece of code is just a sequence of instructions with a list of instructions.

52:18  
And like before, when you interpret or run stack machine code, it also doesn't work alone. So previously, what we experienced it. So we run when you run stack machine code, you need to know what the current stack is. So at least you need

52:34  
a stack argument to your evaluator.

52:38  
Of course, you need the piece of code that you want to evaluate. But now in addition to the stack, you also need to know what this runtime environment or heap is. So both of these things come in. I have not said here, but what comes out is an integer.

52:54  
So the code is correct, it's just that I put in the annotation. And for clarity, we could put it in it also works without.

53:05  
So now we should be able to run run stack machine code

53:11  
that was done like before. So you basically work with with a given piece of code. With a given stack, there is also the given environment that you can use.

53:22  
With pattern match on the instruction sequence and the stack, we don't pattern match on the environment. But it doesn't mean that we don't use the environment with

53:31  
the code is like before in all cases. So like when you have some instruction to do and some more instructions, then what you do is you do the first instruction, you work out the new stack with which you want to do the recursive call with the rest of the instructions.

53:48  
And the for all of these instructions, you'll never change the runtime environment actually here. Similar to the evaluation expression evaluation, I've never changed the memory only read from the memory read from

54:00  
the runtime environment.

54:03  
And also, these two pattern matches are exactly the same as before. So if you're at the end of your piece of code,

54:10  
then you're actually at the stage where you don't need to recurse anymore, you're in a base case and then in this case, you should just try to return the top of the stack. So, if the stack is at least one element, you can do it if the stack is empty,

54:25  
then you can do nothing but complain

54:31  
here is the extra

54:34  
in the situation. So, our code is first load and then do some more stuff.

54:41  
And load from address and

54:44  
and the current stack is or the stack with which we work is SDK.

54:49  
This reduces to of course executing all the remaining instructions from the same environment. But now we provide to this recursive call.

55:00  
The different stack, which is obtained by taking the old one, but adding

55:06  
the result of looking up the element at address in, in, in the heat in the memory in the runtime environment, as we call it.

55:17  
Do you see the only changes, we go on with recursion, we go on with the evaluation, the runtime environment hasn't changed, we still go on with orange. But we have a new stack, which is the old stack plus something new on top, which was directly obtained from the runtime.

55:34  
And one

55:37  
maybe I should give a small example of this actually directly, not with any long piece of code. But suppose what we need to do is the following.

55:48  
What do we need to do?

55:52  
I do our eval. And my piece of code is just one single or load instruction.

56:00  
Our loads, say three.

56:05  
Yeah, so this is my whole programme very short.

56:10  
The stack is maybe empty at the beginning.

56:15  
And maybe I work with a memory which has these values, like 2357 1113, which happened to be the prime numbers, but plays no role. So at address zero, I've got two at address one, I've got three others, too. I've got five, others three, I've got seven, etc. But there's four, I've got 11. Now I want to evaluate this.

56:40  
What happens is,

56:42  
first, we do the lookup of at address three, where do we find the value seven, because agitation starts from zero, not one.

56:55  
So this is pushed on top of the stack. And then a recursive call is made with the empty sequence of instructions. So we end up here with seven on top of the stack, and then seven should be returned to us.

57:10  
And that's what happened.

57:18  
Let's do something more interesting. What is more interesting.

57:25  
Let's load free.

57:29  
Sorry, one single semicolon, let's also load

57:38  
zero.

57:41  
So this doesn't mean that zero goes on to the top of the stack, it means that the value in in my little memory here at address zero, which is two goes onto the top of the stack, maybe I should here show you how this works

58:00  
as a kind of animation field.

58:03  
So if we were to do that,

58:07  
then what happens initially, we've got slash zero, then we push

58:17  
the thing from address three, which is seven on top of the stack, now stack looks like this. Then we also push the thing from

58:27  
address zero, which is to on top of the stack. Now the stack looks like this.

58:32  
The stack top is the front of the list. And then we say maybe then we say sub actually this is what I want to write is it called arsa. for subtraction, what should then happen

58:45  
to top most elements of the stack should be extracted.

58:50  
The first subtracted from the second and then the result returned on top of the stack, which then will be a stack consisting of a single element which is fine.

59:04  
Which is fine.

59:06  
And it's not this five here that happened to be in the memory. This is just a coincidence. But it's really the find that came from subtracting does it makes sense?

59:19  
What's the happiness index?

59:23  
Yeah, make sense? Does it make sense? Okay.

59:28  
Once we've done this, we can actually now complete our cycle. So we can we are now able to compile target expressions into stack machine code by just doing the very smallest possible tweak in in our code from Tuesday.

59:46  
So this was the compilation. So for example, we kind of saw subtraction in action already, right? So, for example, if you want to compile here, basically the code that says take something

1:00:00  
From address three, take something from address,

1:00:04  
zero it was and then subtract. So minus between them, then what you all you need to do is to combine the one, combine the two, you get two pieces of code, you just concatenate them together. So this is least append. And then finally, you're also concatenate the singleton list consisting of simply our, our sub.

1:00:27  
And you actually get a piece of code.

1:00:30  
And then if e one and E two happened to be these variable things, just t bar zero and T var three, then exactly, we get this piece of code. So let's do that. So

1:00:42  
suppose I want to do our comp

1:00:45  
of the following target expression, what should it be? What was the one that we had here in mind? Was

1:00:55  
t var three?

1:00:58  
I'm not writing them in the right order, even t var zero. And then subtraction, P sub i, sorry, it's called T.

1:01:08  
And then there were then we had minus,

1:01:14  
then this thing

1:01:17  
should give us the correct

1:01:21  
stack machine code, isn't it?

1:01:26  
Because we are basically in this case, and we have to compile t var and tes, t tr three and P four, zero, and they just become the corresponding our loads. And then we get our sub at the end. So let's cross our fingers.

1:01:43  
Am I doing it right with my parentheses? I suppose Yes. And we get the exactly this piece of code that we had before you see this.

1:01:50  
That's how it works.

1:01:58  
What else could I know? To

1:02:05  
know I can.

1:02:10  
Now I can paste together these pieces that I have in all sorts of ways. So right, so we could, for example, start with expression.

1:02:21  
What could it be? I could start with an expression say

1:02:27  
that's an expression.

1:02:29  
The nice expression is

1:02:32  
maybe

1:02:34  
var d?

1:02:38  
bar, a.

1:02:43  
That should be a legitimate expression in our language. It stands actually for nothing else than T minus A in concrete syntax, isn't it?

1:02:53  
I can see I don't like this because it has these numerical.

1:02:58  
I'm sorry, he does these.

1:03:02  
He has these named currying variables, but I'd like to see addresses here. So maybe I say

1:03:13  
maybe I say I want to compile it. How can I compile it, I can compile it to pocket expressions

1:03:20  
to compete, but that doesn't work alone.

1:03:25  
decomp wants an argument

1:03:39  
Let's call t co D confronts an argument which is an environment okay. So let let us give it some environment I give the environment a the.

1:03:57  
So this is my idea of what I want to map variables in the memory age should go to either zero B should go to address. One c should go to others to D should go to others three, it should go to address four. If I do the compilation,

1:04:13  
I get this guy.

1:04:16  
Yes, which I can further compiled to

1:04:23  
machine code

1:04:27  
which I've already actually seen happening. So I get here.

1:04:32  
Yeah, of course. Now I can put together pipes of these things. So right so I could for example, let's give things some names. So let my code be

1:04:41  
my expert,

1:04:43  
which is this one there.

1:04:50  
Now let's say there was this workflow my expert

1:04:54  
I can apply the function

1:04:57  
t

1:05:00  
Come

1:05:02  
to my expert and all these things.

1:05:06  
Oh,

1:05:08  
that's not what I wanted to do.

1:05:11  
Go in the wrong direction as well.

1:05:19  
We've done quite a bit today.

1:05:21  
I have no idea what it is. Oh there.

1:05:25  
I start from the beginning.

1:05:31  
Let me give some more names. So I don't make the same mistake again. So this is a compile time environment, cn.

1:05:44  
Now, this is my expression, this is my compile time expression. This is my compose that means

1:05:51  
I can do the following thing to my expression, I can first tee compete

1:05:59  
using this compile time environment. And then I can further submit this thing to

1:06:05  
the to the further compilation to the register machine to that to the stack machine, which is called arco.

1:06:11  
And we've actually seen both steps. So I've just put them together.

1:06:17  
And we get here in two phases, right? Did I tell you about this nice syntax, you can you can you can write these things with with pipes. And it's kind of maybe even more understandable. So I could say,

1:06:27  
which does exactly the same thing. So take something, apply something, apply something get more to it, but to write it in a different order. So you start with my expert, I pipe it into

1:06:41  
Ah, okay, should they hear the argument all the results are great.

1:06:48  
Okay, I could write it, but it's not so pretty. I can pipe it into T comp.

1:06:55  
It doesn't work.

1:06:57  
The older with the arguments is not great.

1:07:05  
All right, I would have wanted to write t comma C and pipe it in there. And then I further type it into our comp. But you see t comp

1:07:17  
doesn't want C and V as the first argument and my experience the second argument, but the other way around. So to write this pipe notation, I would need to define tea cup with the arguments in the other way. In the other order,

1:07:32  
which you can do with lambda notation or with full

1:07:36  
maybe not now.

1:07:38  
Anyway, this is one possible workflow. But you could you could also go in all possible different other orders right here. So we've got three language source expression stock is target expressions, stock machine code, we can compile between the two, between the three different languages. And we can also interpret each one of them directly, provided we give the requisite additional information so that the connection

1:08:07  
does this.

1:08:10  
Feel was this?

1:08:13  
Okay.

1:08:19  
It's a little hard to understand, but I just think it will come with time or something.

1:08:25  
What I what I want to get across to you is not so much the concrete code, but but sort of the general principles that are here, right? So when you work with programming language, there is always layers, maybe you don't see so much of them, really, you see just the top level, which is the language given to you.

1:08:40  
But underneath there is

1:08:44  
there is usually a power the finite power. I like to say like

1:08:49  
in this old story. Yeah, who upholds the earth and then you say there is a there is an elephant that is carrying the earth. But who is cutting the elephant there is another elephant

1:09:00  
cutting that one.

1:09:02  
And yeah, but what does he finish his elephants all the way down here is not the case. Here

1:09:09  
is not an infinite our elephants there is always something at the bottom, which is like the the actual processor code, right? You can't possibly go beneath that. Maybe again, I mean, you can go to the physics beneath it, but that's not what we do. As programmers or computer scientists, we see, you know, the lowest we sees is processor code, but that's always there.

1:09:30  
And then there is the idea that the different levels, they have to talk to each other in terms of some agreements like here, when I go from

1:09:40  
source expressions to target expressions, at least I should know, what is the correspondence between names and addresses, which was my compile time environment.

1:09:50  
And there are sort of similar kind of agreements that now and then you need to know.

1:09:55  
But otherwise, there is not much else happening. So

1:10:02  
The key concept in this part of the lecture lecture really was powers of languages. And the idea that you often work with environments, which typically are some sort of dictionaries associating something to something. So here, we could directly associate values to names. But we could also go into levels of So first, for an A to A name, you associate an address, this thing is often called the symbol table.

1:10:29  
And then to an address, you can further associate the value. So this kind of mapping is just a memory. Yeah.

1:10:37  
Oh, okay. I've got

1:10:41  
20 more minutes to go. And I'm afraid I have to torture you with more interesting things.

1:10:50  
Which is sort of more of the same, but it gets more complicated.

1:10:59  
I only want to add one little feature, which is local names, which comes together then with some idea of, you know, names aren't one of the same name isn't sort of valid throughout the whole code. But but then it turns out a

1:11:15  
block of the code are here in a sub expression of an expression.

1:11:21  
You can also have top level names that the valley sort of throughout so to say that, but there can also be local names. Yeah.

1:11:31  
So you've seen it in every programming language. So so there is basically two kinds of places where they tend to occur. One is when you simply declare local names for hygiene, I mean, you want to have some privacy of names, you don't want to show your names to everyone, because you use too many, and many of them don't mean anything to anyone else than yourself for them for your piece of code. So that's typically done with, with with block constructs, or maybe with modules and module system has, has its own

1:12:03  
little private namespace.

1:12:06  
Another typical place where you also introduce local names, and that's very important is is functions or procedures, or methods, whatever word you use, for our purposes here that are more or less the same. So there, you typically get two kinds of local names, where are the parameters, so when, when you define a function, there is the idea that

1:12:31  
you have these parameters of formal parameters that actually get matched against the real arguments at a function call or procedure call or method call.

1:12:40  
And then Moreover, it typically also have some local names that are completely local to the function procedure method, isn't it? So that's why you've seen so in in F sharp, we see it in led constructions. And here we model a little expression language. And here we do the same. So the idea is, we will have little LED constructions

1:13:00  
in my language of expressions. So it's expressions as before you do arithmetic, you have numerals, you've got like plus minus times,

1:13:08  
you've got names, but then you can also have local names.

1:13:16  
So let's not even look at abstract syntax. First, let me introduce you to the concrete syntax on the level of equations to start with.

1:13:26  
So here, for example, is a typical kind of a let expression.

1:13:32  
It always consists of two parts, there is some new name that you introduce together with its value that may be given directly as a numeral or maybe as another expression. And then there is what is called the body. So the general form is like, let some name equal some right hand side erhs RHS here stands for right hand side, I often use it here in this type of code. And II bodies is another expression, which is for the body.

1:13:58  
And the idea is, you've introduced a local name.

1:14:03  
And it has value 17.

1:14:07  
In the body.

1:14:11  
Yeah. So if, you know, we were to evaluate this thing in some global environment that had the idea, that's that is five. Then when you add that plus that you don't add five and five, because it's not the global set that we're talking about here. In this sub expression, we've introduced the local debt. And actually we've said what it is is not five it's 17. So the result should be 43.

1:14:40  
Is this clear?

1:14:48  
I mean, this lead in is an expression form like any other like operator application, or like just the human or like just a variable. So in particular, you can nest them inside each other

1:15:00  
So here is maybe one example.

1:15:04  
So this whole thing is an expression.

1:15:08  
And there is some nesting of lead expressions or let constructs here. So the whole thing is a lead, where this is the definition part of a new name, like name and right hand side. And this is the body of the outlet. Yeah,

1:15:25  
the body itself is not another lead, the body itself is plus something plus something else.

1:15:33  
But the first summoned of this addition is another left where stupidly, I introduced another name that they call their prime here

1:15:46  
whose value is 22.

1:15:49  
And

1:15:52  
the body is set times their prime Does that make sense?

1:15:56  
There is nothing that says that you need to define values directly as numerals, I can very well say variables directly humours I can very well say a variable is another expression,

1:16:06  
like, defines that as five minus four in 100 times that?

1:16:11  
How do you think this is evaluated? If you evaluate the lead expression, you first find the values of all local variables. So here, you get to know that you've got the local set that is one and here the 100 times one.

1:16:29  
Uh huh.

1:16:33  
And these examples are similar.

1:16:36  
It's just to show you different ways in which lead expressions can nest.

1:16:42  
Are you happy with these?

1:16:45  
Now, what is not shown here is that there is this phenomenon of shadowing,

1:16:51  
which maybe I should tell you as well.

1:16:54  
So let's play with that again. So if I say something like, let's eat Zed equals

1:17:05  
17, why not?

1:17:09  
In

1:17:12  
Zed,

1:17:23  
Zed plus six,

1:17:29  
plus, plus.

1:17:35  
plus,

1:17:36  
then what is happening now is really important to understand the idea of scope.

1:17:42  
This big thing is a lead expression.

1:17:48  
I'm making a local definition here, which means that in all of this body, whichever was defined globally as the value of seven opposite isn't, is no longer visible. I've got my local set, which is 70.

1:18:01  
So in particular, when I do the addition, the second

1:18:05  
summon is 70.

1:18:09  
But the first summons is interesting, because here I introduced another set, which is five. So that set here is five.

1:18:17  
And the fact that I had just declared or defined that to be 17 is shadowed out. I don't see it here, because I've got my own set, which is five. So here we get five plus six, which is 11 plus 17, which is 28. That's fine.

1:18:35  
Yes.

1:18:36  
Okay, these kinds of things happen and and you know them and one. One final thing to show is, of course, you can also have let's not only in nested let's in the body, you can also have nested let's actually in these definitions. So I can very well also do something like this, let y be

1:18:58  
maybe three

1:19:00  
in white times two.

1:19:03  
Yeah. Now, the scope of this, why is just the definition of the of the death of that left.

1:19:13  
And anywhere else is invisible. So if I were to also use y here, it will have to be a different global y that will get its value from the global environment. It's not locally defined. Yep. But this way, here is three.

1:19:28  
Okay, on the level of abstract syntax is not complicated. So let's, but of course, syntax is the easy part.

1:19:36  
May or may be okay, parsing syntax is not is not easy, but abstract syntax is very easy. You just need to say what you're, you know, what your ingredients are in expressions, you don't have to worry about how you actually lay them out in concrete syntax, like you don't have to worry about lead this whitespace and whether it's mandatory or not, and then these white spaces or other separators none of these nonces lead fundamentally just

1:20:00  
needs

1:20:01  
a string and two expressions, the string is the name being defined locally.

1:20:07  
And the two expressions are the right hand side of the definition. And the body.

1:20:14  
Okay, then it's not difficult for you to work out, for example, this one is now illegal expression in this extended language. And you can work out that it means exactly this thing. Because let's take three arguments. The first is the name define. The second is the expression, which is the definition. And the third is the body which is set by set etc. So I trust that you can work this out,

1:20:41  
we can already do a cool thing.

1:20:48  
Oh,

1:20:50  
I promised you a free lunch. And I suppose the free lunches is as far as we

1:20:56  
more or less get today, and then I will have to continue with this, okay?

1:21:03  
It will be okay, then I have to continue next time because this is really subtle. And it's important to get right.

1:21:11  
I promise your freelance I said local names will work like

1:21:15  
will work like clockwork, without actually us us

1:21:19  
having any effort and that is true,

1:21:23  
they will cause us some trouble when we work with the machine etc, we have to think more. But here they they will come to us really, really cheap, namely free. So to interpret expressions with respect to an environment in these extended language, you need to change very little.

1:21:42  
And so the environment is exactly the same thing as before. So it's a dictionary, it's a list of pairs of names and values associated to them. Because right now I'm doing evaluation, I'm not doing compilation to, to a target to target expressions or are further down to the machine. I'm just doing evaluation directly. I work with these environments, somebody has to tell me what the values of my variables are. And I don't care anything about addresses or show

1:22:09  
the lookup is the old one, I could have actually hidden it in the module and loaded here, or included imported the module here.

1:22:18  
This is the evaluator very little has changed.

1:22:23  
Previously, what changed was that we added these environment arguments to all these cases, but we've already added them. So I didn't need to do this. Now. The only new thing is is this here.

1:22:41  
Yeah.

1:22:46  
So when you want to evaluate

1:22:51  
a let expression

1:22:55  
that has a name, then the definition for the name and the body, what do you need to do actually told you how a lead is evaluated. So intuitively,

1:23:05  
you have to work out the value for the new name, first of all, or maybe they're used only anyway, the name, you're defining the local name.

1:23:16  
I do it by just recursively, calling the evaluator with the same environment that is passed in.

1:23:24  
And you know, just the right hand side as he is.

1:23:28  
And I just locally remember it now this is not the length of, of my expression language, that's the length of F sharp, which also has less. So I define locally that this is the value of x.

1:23:40  
Then I also build the new environment, which is the old environment. But at the front,

1:23:46  
I put that I now want to say that the value of x is x, well,

1:23:52  
I call this environment as and one.

1:23:56  
Okay.

1:23:59  
And then finally, what is the value of the lead, the value of the lead is not the value of the right hand side. But the lead returns, of course, is the value of the body. That's that's that's the purpose of the lead construction. The body definition is kind of a local extra here.

1:24:14  
So I need to evaluate the body. But where do I need to evaluate it in end of

1:24:21  
in the original environment that was passed in?

1:24:26  
No, I have to complete end with the new binding, which was excellent, excellent. So we really have to call it with no one.

1:24:34  
You see this. So there is some global dictionary with which I work. But each time I go deeper

1:24:42  
into nested nets, nested less, less deep nets.

1:24:47  
nested less each time I go deeper into nested let's I grow my dictionary by the new bindings which I put in the front.

1:24:57  
Why do I put them in the front not anywhere else?

1:25:00  
Can anyone tell me?

1:25:06  
Yeah, just think of this example where I had multiple zeds. Like, there may be a global set, and I have a local set, and then I have a yet more local set.

1:25:18  
The global set is perhaps 17, the local set here will be six and the yet more local set is five. All of these values are in the dictionary, but in which order. So if I'm deep down here, and I'm interested in doing that, plus six,

1:25:33  
surely I show that when I start looking things up first, the innermost things should come my way first. So I better put them in the front of the dictionary each time I extend it.

1:25:47  
Does that make sense? This is how I look wrote up my lookup, I always just find the first matching key, the first matching name, and look up the value from there. Yep.

1:26:03  
And now I could, in principle, even provided that declared all names, I can work in an empty global environment that was not possible before. Because before when I wanted to have any names at all, I had to provide an an environment from outside to the evaluator to actually evaluate the expression. But now I can define if I want like a specialised evaluator that evaluates in the empty environment, this one works well. provided all names are defined locally.

1:26:35  
Yeah, let's try and then stop. Through them really want to stop.

1:26:43  
To think we can do all of this today?

1:26:46  
No, no way.

1:26:52  
What is your favourite take some evaluate expression you want to evaluate? Maybe like this one is reasonable. So that should be Let's set is 17 in that plus set.

1:27:03  
But let's start for something simpler. Let me evaluate. Just for sanity. Let me evaluate var Zed

1:27:12  
in an environment where y is 15. And set

1:27:19  
is

1:27:24  
when it's two.

1:27:27  
But now, let me evaluate e one e one is this guy.

1:27:35  
In the same environment?

1:27:50  
What's happened?

1:27:52  
Val is 70.

1:27:57  
Do you think 17 plus 17? Is 17.

1:28:03  
I was expecting for 43 to come back. Let's see what the wonders.

1:28:09  
Oh,

1:28:11  
I've redefined the one that's not a good idea. So let's let's just use this one, of course.

1:28:21  
What's happening now?

1:28:28  
Don't you think I should work in the right fine.

1:28:34  
Let's do load.

1:28:37  
Think it's a better idea. Yes, I'm in the old fight.

1:28:48  
So that was funny.

1:28:50  
This is the one that's my new one. And now I want to evaluate it wherever I wanted to evaluate.

1:28:58  
Namely, here, and the result is 34.

1:29:04  
So the point I want to make is the expression is really this, right? I'm providing a global environment where I say that is true.

1:29:13  
But the result is not two plus two is not four. It is actually

1:29:19  
34. Because while the initial environment is this, at the moment, when I get to the body of the lead,

1:29:29  
it's no longer that it's gonna be this one which is extended. Yeah.

1:29:34  
With 70.

1:29:36  
And that's why it works. And then there are more complicated ones. Let me check if it's correct. It was this horrendous thing, but we can think what it is. So whatever that is, on the outside, inside it is 17. So this is 17. Here, I just do 17 times what 22 which is a humongous number. And then what will come out is

1:30:00  
is the result, which will be 17 times 23. So that is what I expect. And then when we evaluate the two in this environment,

1:30:11  
it will be there.

1:30:13  
And similarly with all of those, but the important one is to one with shadowing can we do one was shuffling

1:30:25  
these ones, I think I've modified them when I explained it,

1:30:36  
we can maybe do it by just modifying one.

1:30:41  
So let me do my expression again.

1:30:50  
Let's put in another left, maybe this one here is is not what you see.

1:30:56  
But it's like,

1:30:58  
let that

1:31:02  
be.

1:31:04  
And number three,

1:31:08  
inverse.

1:31:09  
So justifying the local set, which is three, and I'm adding it together with the outer set, which is 17. So the result should be twin Fie. When we evaluate this

1:31:26  
pair of parentheses missing, of course,

1:31:29  
we're actually in the wrong place I should run.

1:31:34  
So that's an expression. And then when I evaluate it,

1:31:44  
when I'm in the situation when the outer the global set is too, but then I'm not using it at all, because I immediately define a local set, which is 17.

1:31:54  
And then I add that one to a yet more local set, which is three. So I expect not to not 17. Not any of these things back I expect 20. This is 20.

1:32:11  
Now that's exactly time.

1:32:18  
What did I tell you in the second part was

1:32:21  
lead constructions are sort of a generic way of doing local names. So in any specific programming language, it might be called a different thing. Maybe it's curly braces with some declarations in the beginning or something like this. Or maybe it's a function, procedure or method body, or maybe it's local arguments, but morally local names are about such a thing.

1:32:44  
And then working with bigger code that has that has blocks in it with local names, means that you have this idea of environments that extend

1:32:56  
and sort of shadowing out that happens when names are reused in the sense that declare the same name or define the same name again, in a in a more inward scope.

1:33:08  
How is this?

1:33:12  
Are you?

1:33:15  
Are you on my page?

1:33:18  
Happy?

1:33:20  
Yeah, I think it's

1:33:21  
too easy, too difficult. I think it'll just take some time to process. But yeah, it's pretty understandable.

1:33:32  
Yeah, and then try to map it to whatever programming language you actually have in mind. I like to bring concrete examples. But I mean, there is something like this happening in in Python, there is something like this happening in Java C, wherever. There's always the same idea of locality as well as copes, right.

1:33:51  
Okay.

1:33:53  
But then, if there is any, not anything, I can stop here. I, I published the solutions from the of the problems from yesterday. I'll publish the exercises for next Wednesday. But I also published the first set of assignments, I mean, the the hand in assignments today in a few hours. So you'll see those, they will not yet concern this programming language part. They're really about this Crash Course F sharp Crash Course part. And then you'll have I don't remember the deadline, but something like two and a half or three weeks to complete.

1:34:32  
The group is the group assignment or you can do in teams of two, maximum or one, then.

1:34:41  
Yeah, so it's

1:34:44  
up. So for this to make it to work smoothly. I'll create these sort of template

1:34:51  
Canvas groups. I mean, if you make your own groups, the graders won't see them so they will grade the same work twice and everything. So it has to be real groups, but then you can

1:35:00  
freely sign sign sign up for those groups. Or if you just do a thing alone, then you don't have to go via group you just submit.

1:35:09  
But that will all be set for you when I opened the assignment and

1:35:14  
then the upload is just you know, a file and.

1:35:21  
Okay.

1:35:25  
Request. Yeah, thank you as well.

1:35:37  
Thank you.

1:35:39  
Thanks.

Transcribed by https://otter.ai
