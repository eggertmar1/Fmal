0:54  
Right So, let me start the lecture, this lecture 19 we continue with micro C. So I was telling you a bit about imperative programming already we looked at the simple imperative language. And then I started to tell you about the C like imperative language, who's one of the main features is that there are pointers that also raise I explained you the complications of such a language. So, what does it mean to to work with pointers that you need to work with a tool level memory model where variables are mapped to locations or addresses, location and address are synonyms. And these further are mapped to values. So, when you want to actually consult the variable, then you first have to find the address at which it is there can be several variables around the same time with the same name from different scopes. So, of course, you consult the correct version of it, and it's lost value. Yeah, since in this the store keeps updated all the time, or we pass store around in our F sharp interpreter of the language. So, today I want to talk about this micro scene a bit more detail so that you see some of the tricks there. Let's start let me share my screen or rather my my text buffer

2:25  
and we go check

2:40  
this one as well. Right. So I'll tell you about the the micro C language then so first we look at the abstract syntax, then a bit about the structures for manipulating memory and then we actually will look at an interpreter that allows us to execute statements and evaluate expressions.

3:04  
So what kind of types will we have around? Well, the main thing is to have some base type like int or float or char here Actually,

3:15  
we have both integers and chars but it doesn't really matter then there are arrays, when you tell something is of an array type, you have to say an array of what and you can optionally also say the length

3:33  
right. And then there are also pointer types of reference types when you say something is a pointer, then you want to say it's a pointer to what like a pointer to an integer or a pointer to a pointer to an integer or any such thing. So, these are the types of types we have around here. We do not need to talk about function types, because functions are not first class, we will have top level functions around

4:01  
arguments will have types, there will be a return type which may also be void. Void is not listed here among the types but the return type can be void. You'll see very shortly how we model this

4:14  
okay. Now two more interesting things. The main syntactic category of course, are expression categories are expressions and statements. Then, I said there are two kinds of expressions there are those that denote values, data values, that we also talk about our values and those that denote addresses, that we also call l values. And of course, when something denotes an address, you can go to this address and look up the value there. So via and address these special kinds of expressions called accessors, they also denote data values, but this is in an indirect fashion. So what are expressions whose values are not necessarily stored Let's start with the simplest ones, and then we go to the more complicated ones. So, surely we can have around just numerals, which will be something of type integer. There are some unary operations like negation perhaps or negation integers that you can also see as well, negation of integers, and some others. Also, Pink is done via the exact the same thing, then there are some binary operations, like, plus times, but also equals less than equal etc. I put some binary Boolean operations separately that are here called and also and or else. The reason to put them separately is that most operations are strict. So, you always need to evaluate both arguments. But and then, or are a bit special in that you first evaluate the first argument and only then you see if you need the second one at all. Then finally, when f is a function, we only have top level functions, and you'll see how they arise, then I can apply this to a bunch of arguments, it should be the correct number of arguments for the interpreter not to fail. Today, we only talk about the interpreter. So, there is nothing in the in the way of type checking, but, but we'll see how this goes. Okay, then there are some some more expressions. But maybe I'll go get to them when we have first looked at accessors. So accessors are especially kinds of expressions that correspond to addresses as well. So

6:45  
yes, any accessor is actually an expression tool, but not the other way around. So, the base case, one of the base cases for expressions are actually accessors that are here denoted by this tech access, and what can an accessor be, so the simplest one is just a variable

7:01  
name.

7:04  
So that will, so if you've got a normal variable of type like integer, this will this will be an accessor. But then, there are also pointers. So, in principle, you can write expressions that are pointers, and then you can dereference them. So in general p will be an expression, but of course, not every expression will work. But, but this is one possibility, and then there are these index accesses. So, and the main use for these are arrays, then and then of course, multi dimensional arrays. So something like this A, and in brackets e will be an accessor. And the idea is you are doing a lookup of an array element, the array element is described by an expression whose value hopefully is an integer. And the array itself is a pointer, we'll see this more specifically. So these are all good. Now, when something is an accessor, and you use it as a as an expression, then the idea is you don't mean the address, you actually mean the the R value that you reach going through the address. So when you just write a the the idea is to do this two level lookup you first look up the address, and then you do look up the value under that address. But if something denotes an address or or is an L value like accessors are then you can also directly ask can I just instead see the address and then you can manipulate the address directly. So this is something that we talked about last time. And then most interestingly, assignments that in imp were statements or commands can also be used as expressions here. So this has to do with the following idea in C. In C. You can write assignments anywhere in an expression so I can write stuff like maybe x equals y equals Zed plus five for example, what is happening this y equals that is not the comparison of y and Zed. Rather the following happens when you look at this assignment. So the assignment is the top level assignment can also be seen both as an expression and the statement. But when you evaluate the following things should happen. You evaluate Zed You assign the result to y. But you also return the value of Zed as a value to which you can add five. And then you assign the result to x. So this is just a shorter way,

10:12  
if you wish, in some sense to write the equivalent of that let y be set. And also let x be Zed plus fine. So if you want to do these two things in a sequence, you can just Well, just as well also write this.

10:32  
Yeah, so you can read an assignment as a statement, then you don't think of it as particularly as returning something you just as a side effect. So the story is updated, but you can also see it as an expression which both has a side effect. So stories update, but also something is returned that can be used in further calculation.

10:53  
So these are expressions, okay. Then, what are the statements? Actually, any expression qualifies as a statement in particular assignments to, then you could ask, okay, but then

11:21  
what is the point, so the expression returns a value, but a statement is not supposed to return anything? Well, the point is, the expression has a side effect, and the side effect is kept. If you have an expression that you treat as a statement, the value is thrown away. So you can write several expressions, for example, next to each other, with a semicolon in a block like this, haven't gotten there yet. When you you throw away the values that the expressions return, but you keep all of the side effects. Okay, let's jump over return for a moment. In general, you can put statements in a sequence in a block. And then the additional thing is, you can also put declarations of local variables in a block. A block is actually a list of statements or declarations. And a statement or, or a declaration is then either a statement signified by this tag is stmt, or it's a declaration and the declaration is given by a tight vendor stream. So you introduce a variable name, and you give it a title. That's the idea. So here, I've shown that the declarations and statements are nicely in order in the sense that you first have a bunch of declarations, then a bunch of statements, but actually, they can come into spheres. And the idea is that the declaration takes effect, you know, at the moment that you see it in the sequence. So the declarations are processed one by one sequentially. And as you go through a declaration, you you you introduce a new local name into the scope, when you leave the block, all of these things are left behind, I mean, they are no longer in the scope. They were private things of this inner scope. Okay, then you can do IPS and wires. These are very simple. I'm all here I see this mistake. So that should be statement one and Statement two. And why. And then what is it what is the complete programme, a complete programme is a list of top level declarations. And at the very top level, you can only have two kinds of things. So the top of the Declaration, top level declaration is either a declaration of a variable. So that's like a declaration of a global variable. Or you actually define a function. So the variable declaration is something like also a local variable declaration. So it's a type followed by a variable like indexes x is of type int,

14:08  
but there is also this form where you will say something like, you know, type function, and then at least type in function pairs. So then you this corresponds to giving the formal arguments like t 1x.

14:26  
Through

14:28  
t n, x n, Papa. And then there is the function body, which is just a statement. Yeah, in general would be blocked. But if it's a simple statement, that's also loud, I forgot to close the parentheses. So this is what we can do. Let me illustrate this a bit. So here is an example written up in the abstract syntax looks pretty complicated. We can We can try to process it and see what it means. So don't get some feel for what is going on here. So it's, it's a piece of code, it is actually not a top level, top level programme, it is an expression seen as a statement. Why? Because Because expert is a tag for the data type statement, or the discriminated union type statement for statements takes as an argument and expression. It's just something that tells you here's an expression, but now I want to leave you with the statement. So we've got an expression that we want to view it as a statement, what is the expression? It is?

15:47  
Above all, it's

15:47  
an assignment? Yeah, what's on the left hand side of the assignment. To the left of an assignment, I always need an accessor. There are three kinds. So there are just names, variable edge, there are pointed D references, and there is indexing. So here there is just a name. So in concrete syntax is just written x equals and what does x equal two, it equals to some humongous expression, which is the right hand side of this assignment. So this is an operation times applied to seven. And then what? Ah, another assignment. So they are the argument two up to two times is the second argument of times is an assignment. So we've got something of this form now.

16:36  
What do we assign to what? So here is the left hand side of the assignment? Here's the right hand side, both are complicated. Now, the left hand side of the assignment is something more complicated than what we saw before. It's an indexing thing

16:56  
that uses on one hand, the name a, okay. Okay. And then some expression, which is the expression for the index. And what is that? It says we want to add together a variable and it's on the right hand side, so we have to convert it from an access or to an expression, so it's access

17:19  
back for I okay. I plus five. So we are assigning something we suppose in an array A to the position i plus five? And what is that?

17:37  
This one is also a complicated thing. So it's an expression in particular, it is an access are seen as an expression because the first case of expressions, we say here, any accessor is an expression. And what is that it's a dereference of something plus something. So it should be a dereference of and then plus access to a name. Why? In what way, this is actually also an expression here, we are using this construct, so we access y in this way. 10% y plus three. Now see gets as complicated as this. Now, maybe let me put some more space. And let's try to read it. So what is happening? The whole big thing is in assignment, which is both an expression and the statement, but we want to see it as a statement already. So what does it do? It assigns to x the multiply the result of multiplying by seven a thing? And what's that thing,

18:44  
that thing you fundamentally get by using y Well, if you apply y ampersand to y, this means y must have been a pointer.

19:00  
And I'm not interested at the value in the pointer, I'm interested in the address of the pointer. Because I really want to increment the address by three and the reference there, so I'm not looking up on there why, but I'm consulting the error. So why and then I go to the right three positions in the store to different address, and I look up the value there. This value is something that on one hand, I want to multiply with seven and assign the result 2x. But on the other hand, even before I get there, I also want to assign this result to a particular element in the array. So I'm going to update the array not everywhere, but at the position i plus phi where i is some name that hopefully was declared as an integer so that I can actually carry this thing up here. Okay. That is complicated right. Now, if you're a real c programmer, you use this mechanism, quite A lot for data structures, but maybe not for writing very obscene things unless you really try to write off escaping c four, to 20. with other people, which people sometimes do for fun, you can really write very unreadable things in theory. Okay, now, now we go to the memory model. So there is this two level structure. We do have environments, which map names to addresses fundamentally. Nope. Yes, but this is defined as a polymorphic type. So in principle, an environment is implemented via a list and we could, we could associate to a string, which is an identifier, any sort of data typically, we'll put addresses here, which are represented here as integers. And this is the usual definition of the environment. So, yes, which we hear used to associate overseas to name. But then there are environments, there will be different kinds of things around. So on one hand, we will have, we will use this type for local environments, we use the same type also for a global environment. More specifically, a local environment is an environment over ins. So here you associate two names, addresses, as I just said, but it's paired together with another int, and in a local environment, so there is both the dictionary and the specific constant, not constant, but the specific single integer that you use as you need to remember which is the next free place in the memory. So this is the next free address that you can use in allocation. Global environments, our pairs are similar, but there we do not keep this. Next, we address information. So there is an association of addresses to global names, this is the intent video guy. Plus there is also a function environment, a function environment is maybe a bit more specific. So a function environment also uses the type and we're so it associates to name something. But here to every name to every function name, we assign on associate on the one hand, the list of parameter declarations, which is just a list of type and variable name pairs corresponding to the formal parameters and their types. And then also to every function name, you have to associate the statement which is the functions body. Okay. So this is how the hell this envier is used here in multiple ways. The string is always some sort of names, identifiers, but the data are different depending on what exactly we want. Okay, what is the store, the store here is, is implemented like we did for imp just for the change with maps rather than lists, but it's a very similar thing. So we map addresses to integer values. So you could also implement it if you wanted with an environment that doesn't map

23:56  
identifiers to addresses but rather maps addresses to two data values which here are only integers. And we have some interface to it so we can create the empty store we can change the value in a store this actually doesn't change anything, it just gives us a new store that can look up value in a store based on an address using some functions that are provided

24:28  
with this type map Okay. Here's another little primitive that we use. For arrays, we need to do the thing that when arrays created just just for keenness, we also need to initialise it, but with some error values. So what then happens is,

24:53  
we need this helper function image store, which does the following thing. It takes some store that He's already given, it takes some particular address, and it puts an initial value, it puts in it, it puts n initial values to the store and all these initial values are minus 999. So if there is any new venues to put into the store, we just returned the old store. Otherwise, we say, where we actually set the store at the given location locked to minus 999. And then we recursively call it store, we say now there is one less item to initialise or one less address to initialise. And actually, we start with the next location. Altogether, we, we initialise end location, so lock itself lock plus one lock plus two etc anti lock plus and minus one. Then, as I said, and these are maybe already the last infrastructure things, but they are the more complicated ones. We need some combine the environment and store operations because if I've got, say a name that denotes an address and that address, there is a value How do I reach that, first I have to find the address that then that is associated to the name, then I have to go to the address and fetch the value there. And also, actually when I want to? Well, I've just created a new variable and I want to place it somewhere in the store, then I have to associate an address to it and I also need to put the value there in the store. So there are a few operations like this. So let me explain them bind var is the following thing. It takes a name it takes the value, it takes the current version of the local environment, which then associates values to address data values to addresses. The local environment also knows the next free location and then we take

27:24  
the store current version of the store buying var What does it do? It does the following thing. On one hand, it extends the environment it says we build the new environment which consists of the old one, but we add

27:44  
the Association of the name x to the next three location that was provided to us. And then what we return is a pair of a new local environment and the store which are they the new local environment is the is the newly created version of the environment, you know the extended environment. But also we increment the the next lock. So I mean, we return not net lock, but next lock plus one. And we return a store that is obtained by this one by updating it at this address, which we just reserved for the for the new variable. And there we store the value v. So we did two things at once, we added an association of the variable to some location for which we took the next three location. Then of course, the new next three location is something else. And then at the same time, we also update the store so we return both the new local environment, the extended local environment and the new updated store. Sometimes you need to bind a whole bunch of variables to a whole bunch of variables at once. And you can do it by just recursively calling bind var on these pairs of variables and data values from here. I won't explain this.

29:17  
So I'm almost done with these infrastructural things. I have to explain one more thing. So when we declare name, which can then be a name for an integer, a name for a pointer, a name for an array.

29:45  
So, the declaration gives us a name paired together with a type which is one of these things. Then, when we process such a thing, we have to do allocation

29:58  
How is that done? In the following way, fundamentally we use bind var, that I just introduced, but we need to do a little more in the case.

30:12  
We're actually allocating memory for an array. So let me explain this. So what comes in? Yeah, something from a declaration. So a pair of a name and the type, local environment store. And what really turn is a new version of the local environment, and also an updated store.

30:33  
How do we do this? Well, first we do some analysis based on what what what, what type tipis Yes, and it can either be an array type or it can be a pointer type or an integer type

30:52  
or a character type. If tip is not an array type, then I define certain things, I say, let next lock prime be just next lock, let some value be just one. So this will actually be the initial value for the thing for which we are allocating a memory but not initialising it yet. And let a new store be the given one, store zero here. So basically, we just use next lock as zero. But as we take minus one. When we see that our type is actually something else, the type is an array of G's, so an array of intz, or an array of other arrays on array or have references. And possibly very is given with a length. So if the array is given with a length, we do this thing, if the array is given with without a pre specified length, then we don't do any allocation at the moment, when we process the declaration of an array, an array gives a location, if the array is given with with a length indication, then we need to do something else. Namely, we don't pass out from here next lock. But next lock up plus i which means that when we process, an array declaration, we will reserve I addresses, at least well, there'll be one more that comes from bind verb, but we'll see later.

32:39  
The

32:39  
value that we want to return is next lock. And the point is when we declare an array, an array becomes a pointer, which is actually initialised to the beginning of the array. So this is this next clock here. So the other guys don't get initialised. It's just minus one, here's an S clock. And then actually, we initialise it many elements

33:12  
of

33:15  
the store. Right? Then, what do we do with all these things, so we return these stuff. And then what remains is we actually want to say we want to bind the name that was declared to the value v that we invented here. And we do this in this newly created store store prime that comes back from here, so in its store, actually gives us the new store that has all these new values for the elements of the array. In other cases, it's just the initial store. Yes, and then also what we say the local environment will be it doesn't change a lot before we start finding the variable. It's the given one, but we already had to say that the next free location is not the original one. But is is whatever comes back from from here. So next look prime is either this or the original one depending on if we processed an array declaration or not. That is tough. But But what it says is when you process a declaration if it's not a declaration of an array of a predefined length, then you don't at this point allocate for initialise any memory except Whatever binds var does and bind var always allocates one address namely for the name itself. Yeah. And in the case of the array, it allocates memory for the pointer to the array, but not to the array itself. Yeah, that is done in this clause if the array has a predefined length, and in this clause, if it is type PE t none.

35:27  
Okay, one final infrastructural thing. When we have our top level declarations, among which there are then declarations of the global variables and global functions, among which there should be the function main,

35:52  
then this is processed in the following way. So, the topic declarations come in. And what we produce is

35:59  
a local environment to start with, which won't contain a lot the function environment and the store and the local environment is called the local environment here, but it's actually consists of the you know the environment for the global variables plus the plus the next free location. So, how is this done, we actually

36:30  
use

36:33  
a helper that just goes through the declarations one by one. And it uses some accumulators. So, we start off by saying we start off with the empty store empty environment of functions and also empty environment of global variables and also the the next free address is zero. At the beginning, all addresses are free. Yeah, we start from this, if we reach the end of the declarations, then we return the current value of the values of the accumulator. So this is what comes back here is good. Otherwise, we are processing either one variable declaration followed recursively by the rest or one function declaration followed recursively by the rest. So what needs to be done when you process a variable declaration,

37:34  
then this is given by a pair of a type and the name, you just allocate memory for the variable using the given look and then store and what come back is a new version of the local environment, the new version of the store,

37:57  
and then you recursively carry on with these new versions. You don't touch the function environments. Maybe it's a function environment, it's the other story. So you process the function declaration, which is given by the type of the function that you don't look at here at all. This will actually have to change when we properly process the return statement, which we don't do here yet. Then there is a function name function for more parameters and the body. And we just call the helper recursively on exactly the same local environmental on exactly the same storage, we don't update them. But to the function environment, we add the pair which is basically essentially just a closure and there is no environmental remember in the closure here. Specifically, we only have top level functions and the global environment will be visible to the functions is always the same. So it's pairs of functions and function names are associated to pairs of parameters and the body okay down here this was complicated, but the good thing is now we can write an evaluator and that is not after all, so complicated. So the top level functions are what on one hand? Well, there are quite a few the main ones are, I need to be able to evaluate expressions I need to be able to evaluate statements which are also called execution. Specifically, we want maybe to evaluate top level declaration. So the main programme, so to say and among the expressions, there is a special case of accessors for which there is also a separate function. All of these are declared in a mutual recursive so it's a big Let's rec with with a bunch of ends. So several things done simultaneously. So when you evaluate an expression, what happens, you take in an expression, local environment, global environment, some store, and what comes back is the value of the expression and the updated store. And I'll explain the functions. Access is similar to what comes in is an accessor. local environment, global environment storage, what can what is returned is an integer, but this time not an integer for a data value, but an integer for an address. And then an updated store. Because accesses can have side effects, for example, you're doing array indexing, and the index expression contains an assignment. So why do you index into an array, you actually change the store evals. It's just a helper for the case when I have a list of expressions, which is used in some place, but nothing interesting is happening here. It's just basically mapping eval over all expressions here, but not quite, because you have to thread through the store. So when you process the first expressions, the store is changed somehow, the next expression will already work with the updated or the new store. There's also a little helper for calling functions, which is one special case of evaluation. And then there is the other type of, of main function here, which is execution of statements. That's very similar to evaluation of expressions. But that difference on the level of pipes is you don't return any data value. So you're taking a local environment global environment store, what comes back is an updated store the new store, but no value is returned. So once we're done with this, we also have to be able to process statements or declarations, statements are processed by executing declarations are processed by a location. I'll explain this once we get there. And finally, the main thing is top declarations for so this corresponding function here is called run. And it takes in a programme, so list of top level declarations, and a number of values. And these are the values that we're passing into the main function. So in the case of a C programme, if you run a compile c programme from say the command line, then you can actually apply on the command line, you can provide arguments to your to your main programme. So let's go through these one by one. expressions, I'll start with the simple ones that we've seen before, so they don't look so difficult perhaps and then we get to the more and more complex

42:58  
ones.

43:00  
So let's start here. When you evaluate the numeral, you don't have to care about the local environment global environment store. Because you don't really depend on them well on the environments Not at all. To return the value of a numeral you just have to return that same number. I have to return the new store. And for that I need to know the old store because evaluating a number doesn't change the store at all. When I have you unary operation applied to an expression what do I need to do evaluate the expression what come back are the value of the expression and then update its store. Now depending on what the operation is, I may need to return a different result from the operation. But the new updated store I return is the one that comes from here. So the an operation itself doesn't change the store anymore. But evaluating you one which may for example be an assignment does change the store. So we return rest and store prime. So what is rest, rest depends on actually what the operation is. So if the operation is bang, which actually stands for negation, when it's just this thing, so when when the value from the expression was false, then you return true which is represented by one otherwise false. So you negate but we also have print things as print operations as unary operations here. So all you need to do is you print the integer value or the character turned into sorry, what did I say? Yes, we either print the integer or the character that is also represented as an integer, but that you want to print it as a character, but you use it in computations you return still the integer two characters are internally represented as integers everything is integers. And this is then what the result is. So, either the result of negating the given expression if this was a negation or otherwise just the given integer or character that you want to print represented in any case as an integer operations are very similar. So, you evaluate both operations sorry, both both expressions both arguments to the operation, the first one you evaluate in the given store, this gives a new store and data value, the second one evaluating the new store which gives a yet newer store and another data value and then you return the newest store. And the result which is given by you know, based on the operation you do something with the values of the arguments. Okay. And, and or are similar except that you're lazier you first only evaluate.

46:29  
First only evaluate the first argument. So this will be a pair of a value, or more or a boolean value together with an update possibly update store. Which we collectively call rest. If before and so the value is true. And then we have to check the other argument. In the new updated store, and whatever pair comes back, this is what we returned. Otherwise, we already returned the given pair. And the or case is true. So if the first guy is true, here, we can already just return the pair that was returned. Otherwise, we need to evaluate the second guy and then whatever its result is determines the whole thing. So function calls are expressed through a special function here. That could have also been inlined. Here Actually, there is no special reason to keep it separate. Okay, now let's go to more complicated things. An expression can either be an accessor seen as an expression, or it can be ampersand applied to an accessor. If it's an ampersand applied to an accessor, all I need to do is I need to apply access to the accessor local environment global environment and store. This will give me back an intern the store and the input is the address and here in this case, we're interested only in that address. So that's in the case of ampersand but if an accessory is used without an ampersand, it means we're not interested in the address we're actually interested in the value at that address though, so then we have to look deeper. So, we do exactly the same we use the function access on ACC the given accessor this one gives us back a location and the new store because accessing can modify the store and then I have to go to this new store. And I have to look up a value that at the given location that I just found or that I just found by you know, evaluating access. And then the store that I returned was the store that I got from here there is no further changes to the store. So So anorak does look up on one level, just look up the address in the store, um but if EQ is an accessor is used as an expression directly without an ampersand you have to do two lookups. So first, you have to understand which ad address the access or which which store address the accessor corresponds to. And then you need to actually go to the store and then fetch the value at that address. Okay. assignments, assignments are interesting. So assignments have an accessor on the left And an expression on the right. So this accessor. Here, when you apply the function access, it denotes a location. So when you, when you process it with access, you get back an address, and also a new updated store. When you evaluate the right hand side, you do get back a data value. And the yet newer store, what you need to return is whatever comes back from the right hand side. But you also have to return a yet newer store that you get by setting in the store that you later Scott. The value add lock to this data value rests here. Yeah.

50:48  
Okay, we're done with this access. And then maybe 10 more minutes, this is really quite involved.

50:58  
Access. Access source, there are three kinds. So what do I need to do, I'm given some access for a local environment, global environment, global environment, you don't really need here unless you make a function call in the array indexing expression, which can also happen and the store why you do access, you need to produce an address. So this is what is returned from an access and an updated store. So if the accessor is a variable name, then what you need to do is you go to the local environment, which is a pair or an environment plus then the next three location, we just we just look up the local environment. Sorry, we take the local environment from there and we look up x there, we get an address. And we are interested in this address. So this address is what we return, and the store doesn't change at all, in this exercise. When we dereference an expression, then the idea is this expression, it should be one that actually has an L value. So it should give us an address, so I just evaluate the expression, back comes an integer, but it's a specific integer that I can use this an address together with an updated store. So what comes back here is an integer and this store.

52:39  
Finally, if this is indexing, then what do I have indexing is given by a pair of an accessor and an indexing expression,

52:46  
what do we need to do? You have to approach this act with access this gives you an address and an updated store then you have to go to the store.

53:01  
So this address Yeah, arrays are pointers to get an address, you actually need to go to get to the store and get to know where the Get to know where the where the actual array elements are, which is another address this is this a Val here another address, then what do I need to do? I need to evaluate the index expression already in this modified storage, what I get back is is an integer and then the yet newer storage and then the address where you actually need to look up the array element or the others that we return here. At this point, we don't get to the lookup we just return an address is the address of the first element of the array of the array plus the correct offset given by the you know, indexing expression. So, maybe the array was the array the first element is at position 17 maybe after the fourth element, so I is four. So then I have to go what I need to return is dadra 17 plus four. Finally, are almost finally calls to functions. What happens so there is this function name is are the actual arguments. local environment global amount of given store. This should be the return value from the function if it returns anything

54:37  
and then a new store What do we need to do? The first thing we need to do is

54:45  
we look up the next fee address in the local environment or we don't even look at that I mean we just we see the local environment as a pair and the second component in the pair is the next location in the global environment. We get sorry, we just pattern match the global environment. And we find out which of the global variables, which are the global functions, then we look up F in the function environment, this gives us the declarations of its parameters and the function body.

55:26  
Now we've done all the lookups, we need here to do some work.

55:41  
What's that, I need to evaluate all the actual arguments. And I use this helper function eval, yes, that will just start with this local around global environment and store, work through these and possibly update the store. And it gives me a bunch of values, I mean, after producing each value, it may have updated the store with the story threaded through here, I get the final modified store, then we use this storage to do what, then we bind all of the parameters of the function to the actual values that we get back from from here. So the second components from the parameter x, which are not the parameter types, but they are the parameter names, we

56:30  
bind them to the, to the values, this will actually assign addresses to all these things. And in I initialise them in the store to minus one or maybe if it's a raised to two more things,

56:46  
and yes, this is done with these data, the variable environment and the next lock where the variable environment was the global variables that already given and the next lock. So these are these are the variables that are already there, they are the global variables, next lock was them. next location that is there. And, and with all this, and what comes back is some new storage. And the function body environment. And then finally, which is which is yet the different local environment that has the old local environment, plus all of the all of the local variables that come from parameters,

57:36  
you know, the local variables from the parameters, and then we execute the function body,

57:42  
which of course, can yet grow the local environment, because the function body may have its own local variables, etc. But whatever, when we execute the function body, then what comes back is the storage. And here since we didn't implement return, actually, we return nothing from the function, we just returned the final store. So we will have to treat the return statement separately. And Jen, this is not yet done in this file at all. You will actually see here the return statement is says not yet. Done with this, the final bits, how do we execute the statement? But maybe it's the least interesting thing. So local environment, global environment store come in, and you produce a new store, what do you do you look at your statement, if it's an expression seen as a statement, then you just evaluate it, what comes back is the return value in the store, you update it store, you ignore the value, you just return the store. The return statement is not implemented. If I've got a whole bunch of statements,

58:55  
which actually statements of statements or declarations, I should say, then what do we do, we loop through them starting with a given local environment and store. And in each one of them,

59:18  
we

59:20  
we just process the statement or declaration with respect to the local environment. The current one the store the current one, these ones keep changing the global environment doesn't change in this course, because we don't have we don't have any local functions we only have functions. For if the nails, evaluate the guard, you get a value and an updated store. Then depending on if the value is true or false, you execute one statement or another in the new store. If it's a wine It is very similar but you need to recurse so we need to use a helper function loop that uses the givens store as the initial accumulator and then the accumulator keeps changing the store is updated with every iteration of the loop and at the beginning of every new iteration you check, whether the value of the guard which in turn can change the store by the way is true or not. And you then run the current iteration from the store that you'll be well aware that the current evaluation produced no block produces these statements or declarations each one of them is either a statement which you just produce by executing the statement and not changing the local environment, if you process the declaration, then you need to allocate memory for x given type in this local environment that is provided to you with a store that is provided to you and come back in your local environment and store. So both the local environment and the store may be updated. Finally, for the top level programme, what do I need to do that's the very last bit how to run a programme. A programme is a bunch of top level declarations and then input values which are the actual arguments which are integers to the function may so we initialise an environment and a store based on the top level declarations. So, this will give us a store an environment for variables the next three location and the function environment, then the main thing or not the main thing, one of the things I then need to do is I actually need to get going so this initialises the environment and the store

1:01:57  
with everything, so with the global variables and the functions and the functions are only global, then I need to look up the function main in the function environment, then I get the main parameters and main body, what I then need to do is I have to proceed from the store that I obtained by initialising the environment and the store, I also need to produce from the variables that I got there, the next three locations, these are the global variables. And I need to bind all the parameters of Maine to the values that are given here as input, these are the values come from the command line. This actually gives me it's actually gives me a local environment where what all these findings are done properly, and then updated store and then finally, we just have to execute main body here. So where exactly do we execute it we executed in the function environmental variable environment that we got by processing the top level declarations and the local environment that we got by binding finding the the argument right is from the command line to the to the to the parameters. And that is it is a complicated piece of programme. There are examples here, I think I will visit them a bit on Thursday. But for today, I'd like to stop here. So what happened, we went through the syntax of micro C, the important bits are there is a distinction between any old expressions that do denote some data values, but are not necessarily stored in an address. So the only denote our values POS perhaps. And then there are accessors that truly are somewhere in the store. So to every search expression corresponds both an address in the store, and the actual data value, which is at that address in the store. So accessors are a special important case. And then there are statements. Statements contain things like ifs and Wiles, every expression counts. There's one particular view assignment which are expressions is a statement. There should be a return for returning from a function that one was not implemented. So although we could declare the types of functions, so the functions return something or interest, really at the moment, we don't return anything. And no type checking is happening. And then I explained how how everything works. I think there was one place where I jumped over. That was a mistake.

1:05:00  
When we talk about the function declaration, then it looks like this. But I forgot to say, for the function type,

1:05:07  
the function type cannot just only be integer or character or array or a pointer, the function type can also be void. And that void can never be an argument type. So therefore, we represent the function type here by tip options. So this means a functions return type is either just T for some regular type T, or none and the none stands for,

1:05:31  
for void.

1:05:32  
But in practice so far, we're only playing with void functions are functions that are declared to return something but really only return some sort of an error value which was minus 111. So that is it for today. I thank you for your attention. And I stopped sharing here. I also stopped the

1:05:56  
video

1:05:58  
and see you another time.

Transcribed by https://otter.ai
