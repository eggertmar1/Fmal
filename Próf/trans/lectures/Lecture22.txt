7:54  
Okay

7:56  
Hello, today Can you hear me? Yeah, well, I hope so, let us continue on where we finished last time I was discussing the stack machine for micro c What was that? So, we saw an interpreter for C. But then I also introduced this stack machine which is like a lower level virtual machine based on some simple instruction set to which we could compile Microsoft programmes. And this example is intended to serve sort of as a general introduction into how imperative programmes could be compiled into a lower level language. One of the main things here being that since we have functions and also recursive functions in particular, but already functions that can call each other one has to work with something that is called the frame stack. frames in the stack. Frames are also called activation records. The idea is when the main function calls a function that function calls another function. This one calls yet another. In general in a computation, we can be in the middle of a lot of things, there is a lot of things that are not yet finished. At one point we will return from the function where we are to the function that called us from there eventually hopefully, we will return to the function that called that one from there eventually hopefully we will we will return to the main function at every stage So we have to work with the actual arguments, and also the local variables of every particular function. And they have to be somewhere during the, during the execution of the programme. So what we can do is that the stack machine can handle all of all of these frames on the stack, including allocating all the data on the stack. Next time, we will also start to look at heap allocation. And the stack looks like this, let me share my screen.

10:48  
The stack looks in general, when you're in the middle of the execution, something like this picture from the textbook, which I explained last time, let me quickly remind you, and then we go on to where we left off. The idea then was that, in general, your computation will be in states that are given by you know, your programme that you're running, which is a list or maybe in a more serious implementation and array of instructions together with a pointer to this array, which is where you currently are in the programme called PC, the programme counter. And then the other part of your state is state is the current stack, what is on the stack? Well, you have to have some positions in the stack where you keep the values of your global variables. And then on top of that, this is at the very bottom of the stack. So this stack is often pictured sort of vertically, and the top is at the top and the bottom is at the bottom, here, it's written from the left to the right, like also in the code that we have. So the bottom is to the left, and the top is to the right. At the bottom, we have the global variables. And then on top of that we have all these frames every frame corresponds to a function call that we're currently in the middle of and what is the information that needs to be recorded there in general is is the following things we need to know when we leave the function the place from where we were called in the programme, so there has to be a return address. So, this is a this is an address in the programme, repositioning the programme to which we will go once we're done with this function here then there is this thing called Old BP. So at the very beginning, they say some special value or now, but at every next in every next frame, this is a pointer to a definite position in the previous frame, which is actually not the zeros not the first but the second position, which is the position from where on in the frame, you have your your your all your audio local variables including the what the arguments that have been passed to the parameters plus the locally declared variables. So, these are here together with any possible temporary things you may have like intermediate results of computations. And then there is the next frame and next frame, next frame etc. and here was an example in the case of factorial for example, and I pointed that out to you that the old base pointer thing always points to the correct place back in the stack. So here for example, in this frame corresponding to not the main not to the main call of fact, but to the first recur recursive call of fact, the old base pointer, which is hearing position 10 in the stack, holds value six and this six here is nothing else than the position. The correct position identifying the previous frame. Well, the frames are not necessarily all have equal length, I mean here they happen to be because these are all calls to pack. But But corresponding to different functions, we might have frames that have a different number of of parameters and local variables. So these things are generally the frames can be a very different lengths. But then this BP allows us to, you know, navigate from one frame to another and land at the correct place. That's what we talked about. I also mentioned sorry,

14:46  
let me show it here

14:50  
was then the global sort of state of execution of the abstract machine involves five components. So as we said, the really big ones here are this array or list of instructions, and an array or list of integers, which is the stack. But then we also have three sort of top level pointers to these things. So we need to know, designated position in the programme, which is where we currently are in the programme. So it's, it's a position in this array of instructions, it's called the programme counter PC. When you know, the PC, you know, this is the instruction is points to the instruction you have to execute next. And for the, for the stack, if it's implemented as an array. Well, we've allocated some stack a huge thing, then we know that the bottom is at position zero, we don't know where the top is, unless we specifically remember it. And here, we remember it in this in this in this pointer SP, so that points to the stack, top actually, it points to the position next to the stack top, so it points to the next three position. So if you were to push something, next, it would go to that position. Okay. And then there is the base pointer. So we have these old VPS everywhere in the picture that pointed to, to the to the basis of all the previous frames, but we also need to know the base pointer for the current frame. And this is then held in this base pointer,

16:27  
b, p.

16:30  
Okay, that's what we discussed. And then I was in the middle of explaining you a bit of the compiler. So what is our cost here, we've got these different micro C, syntactic constructs like expressions or which the special case are accessors, statements, declarations, and they are somehow put together into into the top level programme, how each of these are translated into stack machine code. Yeah. So this goes by, by different functions, all defined by mutual recursion that produced this code. So we looked in particular at one that was called C expert for compiling expressions, what comes in is an expression, what comes out is a list of instructions. But there are similar ones for the other construct like four statements, that's the one that we didn't consider last time see statement takes the statement produced is also a list of instructions. And both of these guys, they use some variable environment and function environment that are sort of the key information about how we did allocation of variables and functions. So in particular, I already mentioned that for global variables, you have to remember their absolute addresses in the stack. This is what var n knows, for local variables. Since you may have several incarnations of say, the same function around like your effect was the picture when it's wise to keep actually not the absolute addresses, but but the local addresses of these variables, which are kind of offsets from the base of a particular frame, like here four factorial and is at address six, but this is obtained by taking the base which is six plus zero because n is you know, at the very beginning of of this, this part of the frame here, but as rest would be six plus one. So the base pointer value is six, and the corresponding offset that is recorded in the variable environment would be that rest is at one. So n zero rest at one. In this particular example, in general, local variables are given relative overseas. Okay, I didn't get very far with this. I didn't formally show your foreign or foreign funding or anything like this. But we'll see a bit of these today. Okay. Then, what else did I say about expressions and accessors that we looked at was that when you produce this compiled code, you follow a certain protocol or agreement with yourself regarding to how each of these compiled pieces of code treat the stack. And what is an expression supposed to do? The code for an expression machine code for an expression is allowed to consult the stack. But it can't change the stack. Other than that, eventually it will add one element at the top of the stack and that is the value of the expression. This is how we express sorry, how code for an expression works. So the idea is that Use the stack. By looking up things there, we had instructions for this

20:09  
load indirect and what they were. And then Indian producer value accessors are similar, but they put not the data value but an address

20:25  
at the top of the stack, so they add one value to the stack and move the stack pointer up, of course, statements are different statements can consult a stack. But in the end, they don't contribute anything new to the stack in terms of the length of the stack at all, right. But, of course, we can save some values in the sense that we also have the store in direct instruction. So why do we do not put the new value on the stack, we may actually in the course of executing a statement, change something inside you already provided height of the stack or length of the stack. So for example, when I when I calculate the factorial, in the end, I may change these rests, positions here in the stack, in the course of execution. Okay, so where did we leave off? I explained expressions fully, starting from operations numerals, but then also like, what do you do if you already have an accessor compiled and then you want to do assignment. And I started with accessors, which I only touched very briefly, I'll continue a bit on those. And then I go to statements. So one thing, maybe, since I already brought it up to mention in connection to assignment was, this is one of the places where you do not add a new element or a new value on top of the stack, but you change something deep inside the stack. So an accessor. That, that compiled code for an accessory, the the accessor denotes an address that is produced by the compiled code for the accessor on the top of the stack. But this address is actually used to modify something deep inside the stack. Right. So this is one of the places where you don't change the height of the stack, but something inside the stack changes. Let me remind you what storing direct was to get us back on the top, you've got an eye for an address and V for a data value. And then what is returned is s but it's not the same as is an updated this. And the value is kept on the top top but is dropped. But instead what has happened is this S is really not the same as here, maybe it should have been written as S prime, it is a modified stack where at the highest position we put the value. So in the in the pre state, the interesting data value is only at the top of the stack. In the post date or after the instruction the value is in two places on the top of the stack. Where do we keep it because assignment wants to return a value, but also the same value is duplicated somewhere else deeper in the stack. And it has overwritten some other value that was previously there because it's a destructive update this okay. So I mentioned accessors and I finished off commenting on this clause. Let me let me now also comment on the remaining cases here. And let's repeat that far. So what was it? So if you have to find out an address for a variable, what do you do? We'll address these are invented for variables and we haven't yet talked about how exactly exactly happens in the code produced for declarations the code produced for declarations. Why do we produce it we build the var environment and also the function environment and in this environment we remember which variable is placed where the global variables in this var n are put at some absolute address. Whereas local variables in this var n are associated to their relative address. Because the same variable especially like in recursive calls can be in use in multiple places and for each time. It has a different Absolute address, but it always has the same relative address. So here we had multiple occurrences of frames of fact, around all came with variables and address, in each case at the same offset zero and one at the same offset zero and one, but from a different base.

25:20  
Okay, when you need to find them the address or produce the code for looking up the address of x, then for a global variable, all we need to do is we push the address that the environment knows on top of the stack. So that is the address that we want to see on the top of the stack. cspi, remember is push a constant for a local variable, this is not the correct constant to put address that we get from the environment is not the correct constant to put in the environment. But we have to put the base point there plus this relative address or the offset. So for that, we need to produce the following code which is the sequence of three instructions. So first get the P. So this pushes the base pointer on top of the stack, then we push the address that the environment knows on top of the stack, now we've got two, two addresses on top of the stack. And then we pop off them both and we add them together and then we push the result back. This is what add that. So in the end, the absolute address has been made out of the relative address and then pushed on the stack

26:51  
akdy Rafi. So here, the idea is that he is an expression that has an L value, and we're just interested in the L value of it, but he is an expression.

27:08  
And we can we can compile it. This produces something that pushes what normally looks like a data value on the top of the stack. But here this data value is treated as an address. But you know, we really don't make any difference, real difference between instructions and sorry, between data values and addresses. They're both integers. So it's an integer. Anyway, this integer is what is pushed on top of the stack. So it's something that was made as a data value but a which you think of as an address. Yeah. And then finally, access index. So this is for the case when we want to do array indexing. So we want to know, the address corresponding to a particular index into an array. What do we need to do then? Well, we have to compile the accessor. This produces a code, this produces a piece of code that loads the address corresponding to this accessor on top of the stack. Okay, but we're not interested in that address, we're actually interested again, in an address that we get by on one hand, taking the given address to the array, for example, and then adding the correct offset to it, which is given by the index. So what do we need to do, then it's good if this thing is on top of the stack, but then also we should.

28:57  
So an array, an array is associated to an address that further associates to the address of the first element or the zeroeth element of it. So So really, we have an address on the top of the stack, but that's not the address of the zeroeth element of the array. That's when we actually get by D referencing this one. So we should also do a load indirect. So we look up under this address, and we put the result on top of the stack. So this is this bit here. We start from here. And we do that. So that but this is still the base address of the array now or the the address of the zeroeth element of the array, but we have to add the correct offset. This we can do by addition, where do we find the correct offset from? Well, we have to evaluate the index expression which is just a normal expression. It produces a value like one or two or five, which appears on top of the stack and this is something that We don't literally treat as a data value, but we think of it as an offset. And then we add them together.

30:08  
Okay.

30:11  
A bit about statements just to give you the feel of it. I won't show everything anyway. So what kinds of statements did we have any expression. Most importantly, any assignment counts as a statement. And the point is, when you want to see an expression as a statement, you don't care about the value, it returns, you only care about the side effect it has, which are the rights it does to the stack. But you don't care about the value that is put to the top of the stack. So really, the compiled code for an expression as a statement is just the compiled code for the expression, but you have to add one more instruction, which is think SP. So increment of the stack pointer by minus one. And this is just a way to say pop, I mean, here, Pop is not the primitive instruction. But Inc, SP minus one is to shrink the stack by one, you don't even delete the value at the top of the stack, but you just move the stack pointer down. So whatever value is, there is no longer considered to be part of the stack. Hmm. Then there are control instructions. So for example, stuff like if and while and also blocks. Locks should in some sense, be more basic, because it's just about sequencing statements together. But since they can also contain declarations leave these just leave this for later. But if the nest for example, and and why? Well, if it's analysis given by two statements for the two branches, and then an expression for the guard. Here's the compiled code, all of it, actually, sorry, one line using all of this. So is a whole bunch of sequences of instructions glued together into one long sequence of instructions. The main parts here are the combined versions of statement one and Statement two. But then I have to arrange some control flow around them. And how is that done? Well, we also use the compiled code for the expression. So this is compiled code that produces the value of the guard at the top of the on the top of the stack, the next instruction should pop this value check if it's zero, not because we're testing if the guard is true or false. So this reduces to finding if it's zero or not. If it is zero, then we should jump to the second brands. So invent that we invented a label called label for the else branch, and then we just put the jump to that branch. If the guard is not false, then we don't jump, then we just go on to succeeding code, which is the first branch the true branch. But then I shouldn't be so naive as to just put the first branch here, and then the label and then the second branch. Because then if I'm done with the first branch, I will still do the second branch. And that's wrong. So after the first rounds, I better insert the go to to the very end. So I also need to invent another label for the very end of this compiled code for if then else. And then after the first branch, I jumped again. So there's two jumps involved right? After the first branch, I unconditionally jump into the very end. And between the guard and the first statement, I conditionally jump to the second branch, which means if the condition of being equal to zero doesn't hold so that the guard is true, then I don't jump and i i got too much. And why you can imagine you can you can do in exactly the same way. So I just have to organise the control flow somehow. Okay, let's see why. So what do we need to do for Why? For while we need to, I have to use the compiled code for the whole statement, of course, and compiled code for the guard expression. And here a while is typically combined like this, you invent two labels for the beginning and for the test.

34:59  
So The test label we put in the middle, and the beginning label we put here. And then what happens. So first we happen. First we jump to test unconditionally. So we jump over this place. And over this place, we jump here, and we just do the expression, the guard. So when you execute this piece of the code, the first thing you do is you jump, then you execute the guard, and then you check if the guard is not zero or not. So if it's not zero, which means the guardian to then we jump to begin, and we actually do the body, then we go through this label, nothing happens. And then we're back at the guard again, and then we look around, but as soon as the guard, so as soon as the value on top is zero, which means the guard is false, then we just fall out of the loop. So we complete the loop. So this is the piece of code that is generated includes two labels that we need targets of jumps, then at the beginning, we put them on conditional jump. And somewhere in the middle, we have the sorry, at the end, we have a condition. Okay.

36:34  
return is an important type of an expression. And we've got two kinds of return here. So for the functions that have type void, when we return, we return nothing. For functions of type, some other non void type, we actually return. And we'd have to provide some expression in the micro C code. Each of those is compiled using grep, which is the machine instruction for returning to the place indicated by the old base pointer. So the current base pointer is set back to the to the old base pointer. And the PC is set to well to the address where you have to return. But you have to make sure that you remove the current frame from the top of the stack. So all of this stuff has to go. Yeah. And in the end, you only want to return the value of interest. And now here there is some sort of pointer arithmetic making sure that all this happens.

38:04  
So let us see how this goes. So if the function actually returns something, so this is given by an expression, then of course, the compiled code should contain the compiled code for the expression, this compiled code produces the value of the expression on top of the stack. But then a way to take care of also this value being made known to the function that called us and getting rid of the current frame for the function from which we're just returning, so we were no longer in the middle of that function. That's done by this command ret. And the important point is to figure out what is the correct argument to keep the wreck in, in these two cases, this is the general case this is somehow a special case. So here to read, we give a number and the number is actually stored in the variable environment, I didn't fully tell you what the variable environment contains the environment. The variable environment consists of two parts. The first is a dictionary associating to every variable, either its absolute address if the variable is global, or an offset if the variable is local. So that's the dictionary part, but there is also a second component which is just a number and that is what is used here. And that precisely knows how many parameters the function has. And the point is, we want to tell this, this instruction read, how much stuff it should delete, from the stack. And here all of this has to go on. Right. So if, for example, the function has zero parameters, but it returns something, then all these things have to go away. There is also the case when the function returns nothing, and then more things will have to go. And that's captured by putting minus one here. So it's a function in particular has zero parameters. And it also returns nothing, then this thing is minus one. And that turns out to do the right thing in this particular case, because then in some sense, you also want to get rid of this V here.

40:46  
Okay. And that may feel unintuitive. But if you do the arithmetic, and you figure out, then you see that this is, this is what happens. So is that in the book, this is even calculated for you. But I don't want to go too deep into this, because it's really kind of a corner case. And then what else should be explained? I don't want to now explain the full detail of everything. There is especially a case where you have to work with a list of expressions that has to do with functions, calls where a function call has a number of arguments, all of them are expressions. So these have to be dealt with, with using this function. That rather than compiling a single expression, compiles a list of expressions. But this is really mapping, compilation of a single expression over to a list of expressions, there is nothing specific happening here. More interesting is function calls, which I jumped over the last time. So let's look at this. So we said the function call is an expression, but it's treated with its compilation is treated with a special function called fun. So call fun, then should be compiled code for a function call. And according to the protocol, this compiled code should leave the value returned from the function on the top of the stack. So it's important to ensure that this happens. So let's look at how call one works. So cofund gets from cx for these two pieces of data, the function name and the expressions which are the arguments, the actual parameters together with a variable environment and functional. So here's generating code for a function call, when the function environment based on the function name knows a whole lot of stuff about the function.

43:19  
So it knows in particular, the parameter declarations it knows the label that we associate to the function and in the generated code, so this one has been invented. And add this label is the code of the whole function. And that's maybe what is important for us here with the tie up thing is not

43:47  
even used.

43:50  
Then what do we do? It's important first of all, to ensure that the function is called with the right number of arguments. So So here we've got a call the arguments are these expressions, yes, but they we have to match them up with with the parameters from the function declaration and they these parameter declarations are here. So these are both lists, and they have to be of equal length. So this is something that we check. And then if this is the case, then we can combine each of their arguments separately. So this is this map, apply to the compilation function for individual expressions. And then at the end, we have to put the call instruction and let's see why it does the right thing. If the number arguments provided is wrong or we just say there is a parameter or argument number mismatch, I mean there is no pipe checking there is only the checking that the number is correct. So, why is the call the right thing to the well, it is because in this language in this machine instruction language call is actually a primitive instruction. So, this is supported by the machine directly but of course, it's not like a it has a different meaning than than a function call in the in our high level language namely myocracy it is it is kind of a go to so, where we go to a certain place, which is this lab F in the in the machine code and we have to correctly return and now let's look at what are the arguments to call the arguments to call our number which is the number of arguments here and the label which is this ad here. So, we are calling a function that this address we really jumping to this address so, called functional a what it does is that the the PC now will become a spelled out here exactly that are explicitly but this is what happens, but something goes happens on the top of the stack So, namely there is a certain manipulation here. So, the function arguments are expected prepare then here we did prepare them as values on top of the stack So, they are here already on the top of the stack prepared by the compiled code for the expressions that are the arguments but this bit is manipulated a bit so it's turned into a proper frame. So, here they're like intermediate values on the stack, but now we organise them into a frame how So, we put the return address and we also put So, what is the return address the return address at this point should be the current PC plus two because it has two arguments. So, our here looks like something out of the blue but it's not. So, this is where we want to return and BEP is is the current base pointer which now becomes the old base pointer at this place. Yeah, so, these are all the side effects here. But this is what a call to a function that and now have more or less explained you how everything in the programme works except perhaps for for declarations that are involved and then how allocation on the stack happens. So, what is the best place to look for this? So, there are two places where we see declarations. So, there are top level declarations of the Global's and functions for example, but there are also local declarations in sequences. So a block consists of either statements or declarations. And, and, yeah, maybe to see how this is processed that let's look at the case for block for statements and then I finish here today actually.

48:50  
Now, we are back at compiling code for statements. The block I said was a bit more complicated because it also involves declarations. But what are what was the state? what it was a list of statements anyway? or What sorry? What was an argument block Anyway, it was a list of statements or declarations. It's called statements here but everything here is either a statement or a declaration. So what do we do? So basically this thing is processed with a little helper called loop. So statements are produced with loop and this guy uses as an accumulator both statements which will start to shrink and will be processed statements one by one and remove them from the list. So to say and the variable environment that keeps changing because we learn information about the variables and we put this information environment prime. So when all this is produced, two things are returned a piece of code that is what we actually return

50:01  
And also a number called f steps. And then what is the final code produced is the following. So, we meet all the code that was produced by the individual statements or declarations. But at the end, we put this ink CSP thing, which was increment of stack pointer that will either grow or shrink the stack. And here what we use is well, the second component of the given var and which we modify by the F steps that is calculated in the in this loop, and then we get the numbers. So let me try to motivate let me get here, after we process this part. So what happens

51:01  
if that is important to keep, because we have to know how many variables are allocated as we process a statement, right. So what happens if we're at the end of our list of statements or declarations, then we don't produce any new code at all. And we remember as the number to return the accumulator value here, or sorry, the return value here. This second of our and otherwise, if I've got the statement or declaration followed by the rest, what do I do, I process the statement or declaration in the given variable environment of functional and functional environment, this good produces a piece of code. And it may change the variable environment which happens in the case, we are actually processing a declaration rather than statement because this will add one new variable to the environment together with its offset. And then I continue

52:21  
with

52:31  
with a loop, and now with the rest of the statements and declarations, with a variable environment just produced so that one is threaded through and that produce more code. So this is the code for the first statement for declaration. This is recursively the code for all of the rest of the statements or declarations, and that is what is returned. And the final number that is returned is this f depth here, F for function depth, well, it doesn't need to be longer, maybe we should call it block depth

53:03  
here. And the point is this many new variables to get allocated on the stack. So in the end, I need to increment or I have to say that the stack pointer now is is a bit higher. So differently from the other imperative features that we have in the statement, I mean, nothing here grew the stack in height. When all all statements that don't don't contain declarations, they leave the stack quite the same, they can change something inside the stack, here the stack grows. But of course, the growth is not this final thing after here the growth is the difference between what we had as the depth before and what is the depth now. So that's thing increased, or increase in height or depth, how confident and then we have to correct the value of the of the stack pointer here. Actually, these inks p in CSP, we could also have done at the end of every particular declaration that contributed by one so that's another possibility not putting qsp by a big number here but in qsp by one at the end of every single declaration.

54:24  
So how is how is processing a declaration going? Well, a declaration is given by a type and the variable name and all what we do here is we allocate a local variable with a given type and this name in the given variable environment this activity will actually return us a new variable environment and the compiled code for this location. So the variable environment is something that we use during the combination in the end is thrown away when the company is finished. It's just our own sort of note on the back of an envelope, what have I put where the compiled code in the end needs to know nothing about it. This is for me to do the bookkeeping during compilation, but then instruction list is what is produced. So it's allocate lockwise. And then how should the allocation happen? Well, it depends on the type now. So if the variable is is an int, or a car, or a pointer, then we just allocate one position in the stack, if it and the same, if it's an array with an unspecified length, if it's an array with a predefined length, then we allocate both space for the for the address of the array as such, but then also, which is a pointer to a further place. But then also, we actually allocate the space for a whole array as well. Which is similar to how we did in in the interpreter, but I'll point you to this. It's here. So that's the function allocate that was called during the compilation of the Declaration, so what information did it take and what was it promised to return it's exactly those that are given here. And so first, it takes something that is called the claim, which is just an indication of whether it's a global or local. But it's more detail than so but let's let's ignore for now, then type the variable name, the given variable environment, what it produces a whole is a whole bunch of instructions that will make the space as we sort of say, as we as one actually executes the machine code. So this is this corresponding code with var n with our new variable environment. So this is the updated dictionary, where we are remembered the offset for the new variable that we just processed. Okay, so what do we do, we pattern match var n, we split it into the environment proper, which is the dictionary associating addresses or offsets to variables and F depth,

57:43  
which is, which is a number of current variables in the current frame. And then we can This is the real application, then it depends on the type.

58:08  
So, first of all, just to make things simpler, we forbid nested arrays, we don't allow arrays of arrays, so, something of the form where the type where the type itself is actually tip A, which to pay always has to take two arguments, one is the type the other one is the optional length. If the type is is tip a, again, this is forbidden, because it would be an array of arrays, we don't allow it. And then the two other cases are either an array with a pre specified length something of the form tip A t where t is a type and some I which means that we have an actual integer here giving the length then we do one thing. The default case accounting for characters integers, arrays with no pre specified length, and pointers is this one, this is kind of the main situation. And arrays with a pre specified length are then a bit more of a complication.

59:20  
So so here's location for for this default case. So what we need to do is we insert

59:54  
to the environment, which is a dictionary, a new entry which just says x. We have A new variable x of the given type tip, which is most often not used here, because we have very lexical pipes, but some functions to look at it. And then, the other thing that we have to associate here is, is, is a is a client. Now, so they have to tell you what what kind is officially. So it takes an integer, which is here, this f type thing and it gives you a variable. As you're sure what the variable, you'll see what the variable is, but it's the knowledge of whether it's local and global plus a bit more, then the real thing here is that the counter is increased by one. And in the code, this is also reflected by and by incrementing, the stack pointer by one. And then what we return is we return the new environment thereby produced. And this little piece of code here, which was actually very little, it was one single instruction.

1:01:23  
In the case of an array, it is a bit more complicated. because on one hand, we increment the stack pointer by the whole length of the array. So that's what we do here.

1:01:46  
And then, what do we do, then we have to actually put on the stack, which will be the value of the pointer corresponding to the array the the correct thing. So which then is okay, we incremented the stack pointer by this much already. But now let's put on the top of the stack the pointer to where we were before. So that's like, get the get the get the stack pointer and subtract what we just added, we get the old number. And this is what we put on the top of the stack. Actually, it could be written in a different order. But then we would need to do swapping, so I could remember the stack pointer before, then I could increment, then I could do a swap, deeper swap. And, yeah, and we would also be fine. But this is one way to do it. Now we have to look at kind

1:02:55  
Oh, sorry, I want to say I'm curious just just just here name that assigns a variable to an integer, which is the steps part but I wanted to say we have to look at the definition of var. So variable really is is one of two things is either an integer tagged as a global variable. And this pretends to be then an absolute address in the stack. Or it's an integer tag with lock var that pretends to be then an address relative to the bottom of the current frame or, or an offset with respect to the base pointer for that frame. Base pointer into that tree. So here, coin is passed down to, to, to allocate from. From the compile function, in our case, state c statement for the case of Roxette state statements and declarations, we know it's local, so kinda is just the function lock, which is the tag turning an integer into a variable. So basically, at this place here, I'm instituting sorry better to talk about this one, this place here on instituting a new variable I'm saying so if my current current counter of the depth is F, that's, then I'm saying in the dictionary x is associated to, you know, local of that depth. And if the same function were called from the processing function, for main, it will be global of that depth, but here it was, local. So all that happens at this place is we increment the counter by one into the dictionary, we put the Association of the variable name x to the type of it, and to the address that we just made with a tag that this is meant to be a local variable, which means you should treat the address as,

1:05:16  
as an offset.

1:05:19  
Yang, the real code is is is only this. Okay, and this is all for that part. Now, I think that I wanted to say there is more that could be said about me. I actually want to stop here today and finish earlier. I will continue by showing little examples of this in action on small programmes and the combined code that has come out. And then we can think how this code gets executed. I mean, what does the abstract machine to using sort of this, this cheat sheet in action, but this was the story of how the compiler more or less is built. So things you have to know is, expressions are supposed to put the value on top of the stack, ie the value on top of the stack, the same for accessors, except they leave the address statements leave nothing on top of the stack, all of these things can change some values in the stack without changing the height the such. So, this corresponds, this has to do with the fact that this is an imperative language. So, variables values do change, but they're all stuck located. So we change things deep in the stack, using the story in direct. And when we want to, you know, recall that the value of anything was in this in the event, it's also in the stacks, we have to go deep into the stack and look there, Lodi, so then there is always bookkeeping about how high we call, we want to consider the stack to be. So the stack is implemented as an array. So you work with an explicit stack pointer. So when you make the stack higher by one, then you should also increment the stack pointer.

1:07:25  
Unless this is done, so unless this is sort of part of the instruction. So obviously, this one will increment the stack pointer by one. But then when we sort of want to artificially increment the stack pointer, so So here, for example, we've produced some things on top of the stack using some sort of ad hoc mechanism. But now we want to say, okay, the whole extended thing here now wants to be considered as the new state of the stack, then I have to manually increment the stack pointer. And similarly when I want to shrink the stack, so I really want to pop, this is what we do. So this increment here is like an anti pop. We don't explicitly say what we want to put on the top of the stack, but these things are have already been pre prepared there. And we'll just use them. And that is it. Why don't we combine we keep the sort of compile time dictionaries, which are the var and when finance in the compiled code in the final compiled code, they don't show that we just have a list of instructions. But as we combine, this is where we keep track of the decisions we've made. And that is more or less. Hey,

1:08:42  
how about the questions? Okay, there is no two lectures left. One next Tuesday, but I'll still talk about technical material. And then one

1:09:16  
after these the break on Thursday, which will be kind of a recap thing as well. So I try not to leave too much for it. Rather than I can perhaps go through again, a few things and maybe comment on last year's exam. You'll get the solutions for that one, which I think are not in my school. I'll post them in Canvas. And that should be it for the lab parts because of the rise in the COVID cases. The last lab, which is after this the break these will have to be online as well all of them. But we will keep in touch and I'll inform you about developments before. And certainly before the Easter you should get the grades for the other scores for the third assignment. And I'll also publish the solutions. Maybe today. Okay, I'll stop the recording here.

Transcribed by https://otter.ai
