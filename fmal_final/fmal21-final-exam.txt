

T-501-FMAL Programming language, Spring 2021 

Final exam, 12 April 2021'

Part 2: Freetext questions

Write answers in Icelandic or English. 

=======================================================================

STUDENT NAME: Eggert Mar Eggertsson 

ID-CODE: 030699-3199

== 21 ==================================================================

   In Problems 21--23, it is more important to demonstrate that
   you understand how to solve the problem than to resolve any errors
   that F may give because you have got something wrong in the syntax. 

(7 p) Write an F# function

   group23 : 'a list -> ('a list) list

   that groups the elements of a list into groups of 2 and 3 elements
   in alternation. Those last elements that don't make a full group
   should be dropped.

   > group23 [10; 11; 12; 13; 14; 15; 16; 17; 18; 19];;
   val it : int list list = [[10; 11]; [12; 13; 14]; [15; 16]; [17; 18; 19]]

   > group23 [10; 11; 12; 13];;
   val it : int list list = [[10; 11]]

   > group23 [10; 11; 12; 13; 14; 15];;
   val it : int list list = [[10; 11]; [12; 13; 14]]

   (Hint: You may want to use mutual recursion.)

ANSWER:


   let rec group2 = function 
      | []              -> []
      | [x1]            -> []
      | x1::x2::xs      -> [x1;x2] :: group3 xs


   let rec group3 = function 
      | []            -> []
      | [x1]          -> []
      | [x1;x2]       -> []
      | x1::x2::x3::xs -> [x1;x2;x3] :: group2 xs 


   let group23 xs = (group2 xs) 



== 22 ==================================================================


(6 p) Using the library functions List.filter and List.map, write an
   F# function

   div57 : int list -> int list

   that takes a list of integers, keeps those that divide by 5 or 7 (or
   both), and then adds to each of the kept elements.

   > div57 [1; 3; 5; 7; 8; 10; 14; 15; 21; 26; 30];;
   val it : int list = [6; 8; 11; 15; 16; 22; 31]


ANSWER:     let div57 xs = List.map (fun x -> x + 1) (List.filter (fun x -> x % 5 = 0 || x % 7 = 0) xs)




== 23 ==================================================================


(5 p) Write an F# function

   safeFind : ('a -> bool) -> 'a list -> 'a option
   
   that returns the first element of given list satisfying the given
   predicate.  It should signal failure (by returning None) if there
   is no such element.

   > safeFind (fun x -> x < 0) [16; 20; -3; 5; 4; -8; 2];;
   val it : (int list) option = Some (-3)

   > safeFind (fun x -> x % 2 = 0) [5; 7; 1; 13];;
   val it : (int list) option = None

ANSWER: 

let rec safeFind func xs = 
    match xs with 
    | []         -> None
    | x1::xs     -> match func x1 with 
                    | true -> Some x1
                    | false -> safeFind func xs 







== 24 ==================================================================

(4 p) What does the expression 

   (let x = (let y = 5 in y - x) in x + y) * x

   evaluate to in the environment [x, 2; y, 100]? 

   Explain in detail.

   (Here and in the subsequent problems, code is given in concrete
   syntax.  The same applies for environments. [x, 2; y, 100] is the
   environment where x has integer value 2 and y has integer value
   100.)

ANSWER:

      (let x = (let y = 5 in y - 2) in x + 100) * 2     ===> (let y = 5 in y - 2) = 3
      (let x = 3 in x + 100) * x  =  103 * 2 = 206

== 25 ==================================================================

(4 p) What state of the stack does the piece of stack machine code

   [RSwap; RPop; RAdd; RMul]

   finish in when executed from the initial stack state [7; 6; 5; 4]?
   (The top of the stack is the first element of the list.)

   Write out all intermediate states of the stack.

ANSWER:

   RSwap 7, 6 => [6;7;5;4]
   RPop 6     => [7;5;4]
   RAdd 7,5   => [12;4]
   RMul 12,4  => 48




========================================================================

STUDENT NAME: Eggert Mar Eggertsson

ID-CODE: 030699-3199

== 26 ==================================================================

(4 p) Find a type environment (types for the free variables---all
  three of them) in which this expression can be typed.

  if x < 3 && b then f x else b

  What is the type of this expression in this type environment?

  Explain.

ANSWER:     

   x is a int 
   b is a bool 
   f (int -> bool)



== 27 ==================================================================

(4 p) What does the expression 

   let f y = x * y in      //f = 3 * y 
     let x = 8 in             
       let g = f in        //g = 3 * y          
         g x               //g 8  = 3 * 8 = 24

   evaluate to under the static scope rule in the environment [x, 3]?

   Explain in detail.  Explained in the comments of the code. 
   Detailed Explanation: f is the func for 3 * y, but we declare g as the function g = 8 * 3. 

ANSWER: 24 




== 28 ==================================================================

(5 p) What is the most general type of the expression

   fun x -> y, let f x = x :: x :: [] in f (f x)

   in the type environment [y, bool]?

   Explain in detail.

ANSWER: 




== 29 ==================================================================

(4 p) Unify this pair of types, i.e., write down both their most
  general common substitution instance as well as the necessary type
  variable substitutions): 

  a -> 'b list * 'c     and     ('c -> 'b) -> 'd * 'd 

  (Do not rename the type variables of the two types apart before
  unifying.)

ANSWER:  






== 30 ==================================================================

(3 p) Calculate the result of this lambda-term substitution:

  (x (\ z. z x) (\ x. y x)) [z y/ x]

  (lambda is written "\".)

  (Pay attention to which occurrences of x in the lambda-term to
  substitute into are free and which are bound. Also make sure you
  avoid variable capture.)

ANSWER: 




========================================================================

STUDENT NAME: Eggert Mar Eggertsson

ID-CODE: 030699-3199

== 31 ==================================================================

(5 p) Normalize this lambda-term (i.e., beta-reduce it in as
  many steps as you need until you reach a normal form) using the
  *leftmost-outermost* reduction strategy.

  (\ x. (\ y. y (x y)) (\ w. w)) (z y)

  (Again make sure you avoid variable capture.)

ANSWER: z y \ w. w




== 32 ==================================================================

(4 p) What does the following program print?

   void main () {
     int i;   
     i = 7;        // 7 
     f (&i);       // f(7) -> gets pointer to 7, changes value to 3
     print i;      // 3
     g (i);        // g(3)
     print i;      // 3
   } 

   void f (int *p) {
     *p = 3;
   }
 
   void g (int j) {
     j = 17;           // does not change the address. 
   }

   Explain in detail. Explanation is found in the lines of code. Easier to understand. 

ANSWER: 3, 3



== 33 ==================================================================

(5 p) What does the following program print?

   int x;                  
   int y;               
   int* p;  
   int* q;  
   x = 8;      
   p = &x;           // p to the address for 8 
   q = &y;           // q to the address of y
   *q = *p + 3;      // 8 + 3 = 11     -> as q is the address for y 
   print y;          // prints 11 
   q = p;            // q = &x -> address for 8   
   x = *q * 2;       // x = 8 * 2 = 16      
   print *p;         // 16          ->  points to x 
   *p = 0;           // as *p has the same address of x 
   print x;          // 0

   Explain!



   
ANSWER: 11, 16, 0 




== END =================================================================
